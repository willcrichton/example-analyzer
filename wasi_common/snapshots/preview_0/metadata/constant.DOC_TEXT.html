<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `DOC_TEXT` constant in crate `wasi_common`."><meta name="keywords" content="rust, rustlang, rust-lang, DOC_TEXT"><title>DOC_TEXT in wasi_common::snapshots::preview_0::metadata - Rust</title><link rel="stylesheet" type="text/css" href="../../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../../../storage.js"></script><script src="../../../../crates.js"></script><noscript><link rel="stylesheet" href="../../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../../favicon.svg"><style type="text/css">#crate-search{background-image:url("../../../../down-arrow.svg");}</style></head><body class="rustdoc constant"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../../../wasi_common/index.html'><div class='logo-container rust-logo'><img src='../../../../rust-logo.png' alt='logo'></div></a><div class="sidebar-elems"><h2 class="location">Other items in<br><a href="../../../index.html">wasi_common</a>::<wbr><a href="../../index.html">snapshots</a>::<wbr><a href="../index.html">preview_0</a>::<wbr><a href="index.html">metadata</a></h2><div id="sidebar-vars" data-name="DOC_TEXT" data-ty="constant" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../../../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Constant <a href="../../../index.html">wasi_common</a>::<wbr><a href="../../index.html">snapshots</a>::<wbr><a href="../index.html">preview_0</a>::<wbr><a href="index.html">metadata</a>::<wbr><a class="constant" href="#">DOC_TEXT</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../../../src/wasi_common/snapshots/preview_0.rs.html#17-22" title="goto source code">[src]</a></span></h1><div class="docblock item-decl"><pre class="rust const"><code>pub const DOC_TEXT: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> = &quot;(typename $size u32)\n(;; Non-negative file size or length of a region within a file.\n ;) (typename $filesize u64)\n(;; Timestamp in nanoseconds.\n ;) (typename $timestamp u64)\n(;; Identifiers for clocks.\n ;) (typename $clockid (enum (@witx tag u32) (;; The clock measuring real time. Time value zero corresponds with\n1970-01-01T00:00:00Z.\n ;) $realtime (;; The store-wide monotonic clock, which is defined as a clock measuring\nreal time, whose value cannot be adjusted and which cannot have negative\nclock jumps. The epoch of this clock is undefined. The absolute time\nvalue of this clock therefore has no meaning.\n ;) $monotonic (;; The CPU-time clock associated with the current process.\n ;) $process_cputime_id (;; The CPU-time clock associated with the current thread.\n ;) $thread_cputime_id))\n(;; Error codes returned by functions.\nNot all of these error codes are returned by the functions provided by this\nAPI; some are used in higher-level library layers, and others are provided\nmerely for alignment with POSIX.\n ;) (typename $errno (enum (@witx tag u16) (;; No error occurred. System call completed successfully.\n ;) $success (;; Argument list too long.\n ;) $2big (;; Permission denied.\n ;) $acces (;; Address in use.\n ;) $addrinuse (;; Address not available.\n ;) $addrnotavail (;; Address family not supported.\n ;) $afnosupport (;; Resource unavailable, or operation would block.\n ;) $again (;; Connection already in progress.\n ;) $already (;; Bad file descriptor.\n ;) $badf (;; Bad message.\n ;) $badmsg (;; Device or resource busy.\n ;) $busy (;; Operation canceled.\n ;) $canceled (;; No child processes.\n ;) $child (;; Connection aborted.\n ;) $connaborted (;; Connection refused.\n ;) $connrefused (;; Connection reset.\n ;) $connreset (;; Resource deadlock would occur.\n ;) $deadlk (;; Destination address required.\n ;) $destaddrreq (;; Mathematics argument out of domain of function.\n ;) $dom (;; Reserved.\n ;) $dquot (;; File exists.\n ;) $exist (;; Bad address.\n ;) $fault (;; File too large.\n ;) $fbig (;; Host is unreachable.\n ;) $hostunreach (;; Identifier removed.\n ;) $idrm (;; Illegal byte sequence.\n ;) $ilseq (;; Operation in progress.\n ;) $inprogress (;; Interrupted function.\n ;) $intr (;; Invalid argument.\n ;) $inval (;; I/O error.\n ;) $io (;; Socket is connected.\n ;) $isconn (;; Is a directory.\n ;) $isdir (;; Too many levels of symbolic links.\n ;) $loop (;; File descriptor value too large.\n ;) $mfile (;; Too many links.\n ;) $mlink (;; Message too large.\n ;) $msgsize (;; Reserved.\n ;) $multihop (;; Filename too long.\n ;) $nametoolong (;; Network is down.\n ;) $netdown (;; Connection aborted by network.\n ;) $netreset (;; Network unreachable.\n ;) $netunreach (;; Too many files open in system.\n ;) $nfile (;; No buffer space available.\n ;) $nobufs (;; No such device.\n ;) $nodev (;; No such file or directory.\n ;) $noent (;; Executable file format error.\n ;) $noexec (;; No locks available.\n ;) $nolck (;; Reserved.\n ;) $nolink (;; Not enough space.\n ;) $nomem (;; No message of the desired type.\n ;) $nomsg (;; Protocol not available.\n ;) $noprotoopt (;; No space left on device.\n ;) $nospc (;; Function not supported.\n ;) $nosys (;; The socket is not connected.\n ;) $notconn (;; Not a directory or a symbolic link to a directory.\n ;) $notdir (;; Directory not empty.\n ;) $notempty (;; State not recoverable.\n ;) $notrecoverable (;; Not a socket.\n ;) $notsock (;; Not supported, or operation not supported on socket.\n ;) $notsup (;; Inappropriate I/O control operation.\n ;) $notty (;; No such device or address.\n ;) $nxio (;; Value too large to be stored in data type.\n ;) $overflow (;; Previous owner died.\n ;) $ownerdead (;; Operation not permitted.\n ;) $perm (;; Broken pipe.\n ;) $pipe (;; Protocol error.\n ;) $proto (;; Protocol not supported.\n ;) $protonosupport (;; Protocol wrong type for socket.\n ;) $prototype (;; Result too large.\n ;) $range (;; Read-only file system.\n ;) $rofs (;; Invalid seek.\n ;) $spipe (;; No such process.\n ;) $srch (;; Reserved.\n ;) $stale (;; Connection timed out.\n ;) $timedout (;; Text file busy.\n ;) $txtbsy (;; Cross-device link.\n ;) $xdev (;; Extension: Capabilities insufficient.\n ;) $notcapable))\n(;; File descriptor rights, determining which actions may be performed.\n ;) (typename $rights (flags (@witx repr u64) (;; The right to invoke `fd_datasync`.\nIf `rights::path_open` is set, includes the right to invoke\n`path_open` with `fdflags::dsync`.\n ;) $fd_datasync (;; The right to invoke `fd_read` and `sock_recv`.\nIf `rights::fd_seek` is set, includes the right to invoke `fd_pread`.\n ;) $fd_read (;; The right to invoke `fd_seek`. This flag implies `rights::fd_tell`.\n ;) $fd_seek (;; The right to invoke `fd_fdstat_set_flags`.\n ;) $fd_fdstat_set_flags (;; The right to invoke `fd_sync`.\nIf `rights::path_open` is set, includes the right to invoke\n`path_open` with `fdflags::rsync` and `fdflags::dsync`.\n ;) $fd_sync (;; The right to invoke `fd_seek` in such a way that the file offset\nremains unaltered (i.e., `whence::cur` with offset zero), or to\ninvoke `fd_tell`.\n ;) $fd_tell (;; The right to invoke `fd_write` and `sock_send`.\nIf `rights::fd_seek` is set, includes the right to invoke `fd_pwrite`.\n ;) $fd_write (;; The right to invoke `fd_advise`.\n ;) $fd_advise (;; The right to invoke `fd_allocate`.\n ;) $fd_allocate (;; The right to invoke `path_create_directory`.\n ;) $path_create_directory (;; If `rights::path_open` is set, the right to invoke `path_open` with `oflags::creat`.\n ;) $path_create_file (;; The right to invoke `path_link` with the file descriptor as the\nsource directory.\n ;) $path_link_source (;; The right to invoke `path_link` with the file descriptor as the\ntarget directory.\n ;) $path_link_target (;; The right to invoke `path_open`.\n ;) $path_open (;; The right to invoke `fd_readdir`.\n ;) $fd_readdir (;; The right to invoke `path_readlink`.\n ;) $path_readlink (;; The right to invoke `path_rename` with the file descriptor as the source directory.\n ;) $path_rename_source (;; The right to invoke `path_rename` with the file descriptor as the target directory.\n ;) $path_rename_target (;; The right to invoke `path_filestat_get`.\n ;) $path_filestat_get (;; The right to change a file\&#39;s size (there is no `path_filestat_set_size`).\nIf `rights::path_open` is set, includes the right to invoke `path_open` with `oflags::trunc`.\n ;) $path_filestat_set_size (;; The right to invoke `path_filestat_set_times`.\n ;) $path_filestat_set_times (;; The right to invoke `fd_filestat_get`.\n ;) $fd_filestat_get (;; The right to invoke `fd_filestat_set_size`.\n ;) $fd_filestat_set_size (;; The right to invoke `fd_filestat_set_times`.\n ;) $fd_filestat_set_times (;; The right to invoke `path_symlink`.\n ;) $path_symlink (;; The right to invoke `path_remove_directory`.\n ;) $path_remove_directory (;; The right to invoke `path_unlink_file`.\n ;) $path_unlink_file (;; If `rights::fd_read` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype::fd_read`.\nIf `rights::fd_write` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype::fd_write`.\n ;) $poll_fd_readwrite (;; The right to invoke `sock_shutdown`.\n ;) $sock_shutdown))\n(;; A file descriptor handle.\n ;) (typename $fd (handle))\n(;; A region of memory for scatter/gather reads.\n ;) (typename $iovec (record (;; The address of the buffer to be filled.\n ;) (field $buf (@witx pointer u8)) (;; The length of the buffer to be filled.\n ;) (field $buf_len $size)))\n(;; A region of memory for scatter/gather writes.\n ;) (typename $ciovec (record (;; The address of the buffer to be written.\n ;) (field $buf (@witx const_pointer u8)) (;; The length of the buffer to be written.\n ;) (field $buf_len $size)))\n(typename $iovec_array (list $iovec))\n(typename $ciovec_array (list $ciovec))\n(;; Relative offset within a file.\n ;) (typename $filedelta s64)\n(;; The position relative to which to set the offset of the file descriptor.\n ;) (typename $whence (enum (@witx tag u8) (;; Seek relative to current position.\n ;) $cur (;; Seek relative to end-of-file.\n ;) $end (;; Seek relative to start-of-file.\n ;) $set))\n(;; A reference to the offset of a directory entry.\n ;) (typename $dircookie u64)\n(;; The type for the `dirent::d_namlen` field of `dirent` struct.\n ;) (typename $dirnamlen u32)\n(;; File serial number that is unique within its file system.\n ;) (typename $inode u64)\n(;; The type of a file descriptor or file.\n ;) (typename $filetype (enum (@witx tag u8) (;; The type of the file descriptor or file is unknown or is different from any of the other types specified.\n ;) $unknown (;; The file descriptor or file refers to a block device inode.\n ;) $block_device (;; The file descriptor or file refers to a character device inode.\n ;) $character_device (;; The file descriptor or file refers to a directory inode.\n ;) $directory (;; The file descriptor or file refers to a regular file inode.\n ;) $regular_file (;; The file descriptor or file refers to a datagram socket.\n ;) $socket_dgram (;; The file descriptor or file refers to a byte-stream socket.\n ;) $socket_stream (;; The file refers to a symbolic link inode.\n ;) $symbolic_link))\n(;; A directory entry.\n ;) (typename $dirent (record (;; The offset of the next directory entry stored in this directory.\n ;) (field $d_next $dircookie) (;; The serial number of the file referred to by this directory entry.\n ;) (field $d_ino $inode) (;; The length of the name of the directory entry.\n ;) (field $d_namlen $dirnamlen) (;; The type of the file referred to by this directory entry.\n ;) (field $d_type $filetype)))\n(;; File or memory access pattern advisory information.\n ;) (typename $advice (enum (@witx tag u8) (;; The application has no advice to give on its behavior with respect to the specified data.\n ;) $normal (;; The application expects to access the specified data sequentially from lower offsets to higher offsets.\n ;) $sequential (;; The application expects to access the specified data in a random order.\n ;) $random (;; The application expects to access the specified data in the near future.\n ;) $willneed (;; The application expects that it will not access the specified data in the near future.\n ;) $dontneed (;; The application expects to access the specified data once and then not reuse it thereafter.\n ;) $noreuse))\n(;; File descriptor flags.\n ;) (typename $fdflags (flags (@witx repr u16) (;; Append mode: Data written to the file is always appended to the file\&#39;s end.\n ;) $append (;; Write according to synchronized I/O data integrity completion. Only the data stored in the file is synchronized.\n ;) $dsync (;; Non-blocking mode.\n ;) $nonblock (;; Synchronized read I/O operations.\n ;) $rsync (;; Write according to synchronized I/O file integrity completion. In\naddition to synchronizing the data stored in the file, the implementation\nmay also synchronously update the file\&#39;s metadata.\n ;) $sync))\n(;; File descriptor attributes.\n ;) (typename $fdstat (record (;; File type.\n ;) (field $fs_filetype $filetype) (;; File descriptor flags.\n ;) (field $fs_flags $fdflags) (;; Rights that apply to this file descriptor.\n ;) (field $fs_rights_base $rights) (;; Maximum set of rights that may be installed on new file descriptors that\nare created through this file descriptor, e.g., through `path_open`.\n ;) (field $fs_rights_inheriting $rights)))\n(;; Identifier for a device containing a file system. Can be used in combination\nwith `inode` to uniquely identify a file or directory in the filesystem.\n ;) (typename $device u64)\n(;; Which file time attributes to adjust.\n ;) (typename $fstflags (flags (@witx repr u16) (;; Adjust the last data access timestamp to the value stored in `filestat::atim`.\n ;) $atim (;; Adjust the last data access timestamp to the time of clock `clockid::realtime`.\n ;) $atim_now (;; Adjust the last data modification timestamp to the value stored in `filestat::mtim`.\n ;) $mtim (;; Adjust the last data modification timestamp to the time of clock `clockid::realtime`.\n ;) $mtim_now))\n(;; Flags determining the method of how paths are resolved.\n ;) (typename $lookupflags (flags (@witx repr u32) (;; As long as the resolved path corresponds to a symbolic link, it is expanded.\n ;) $symlink_follow))\n(;; Open flags used by `path_open`.\n ;) (typename $oflags (flags (@witx repr u16) (;; Create file if it does not exist.\n ;) $creat (;; Fail if not a directory.\n ;) $directory (;; Fail if file already exists.\n ;) $excl (;; Truncate file to size 0.\n ;) $trunc))\n(;; Number of hard links to an inode.\n ;) (typename $linkcount u32)\n(;; File attributes.\n ;) (typename $filestat (record (;; Device ID of device containing the file.\n ;) (field $dev $device) (;; File serial number.\n ;) (field $ino $inode) (;; File type.\n ;) (field $filetype $filetype) (;; Number of hard links to the file.\n ;) (field $nlink $linkcount) (;; For regular files, the file size in bytes. For symbolic links, the length in bytes of the pathname contained in the symbolic link.\n ;) (field $size $filesize) (;; Last data access timestamp.\n ;) (field $atim $timestamp) (;; Last data modification timestamp.\n ;) (field $mtim $timestamp) (;; Last file status change timestamp.\n ;) (field $ctim $timestamp)))\n(;; User-provided value that may be attached to objects that is retained when\nextracted from the implementation.\n ;) (typename $userdata u64)\n(;; Type of a subscription to an event or its occurrence.\n ;) (typename $eventtype (enum (@witx tag u8) (;; The time value of clock `subscription_clock::id` has\nreached timestamp `subscription_clock::timeout`.\n ;) $clock (;; File descriptor `subscription_fd_readwrite::file_descriptor` has data\navailable for reading. This event always triggers for regular files.\n ;) $fd_read (;; File descriptor `subscription_fd_readwrite::file_descriptor` has capacity\navailable for writing. This event always triggers for regular files.\n ;) $fd_write))\n(;; The state of the file descriptor subscribed to with\n`eventtype::fd_read` or `eventtype::fd_write`.\n ;) (typename $eventrwflags (flags (@witx repr u16) (;; The peer of this socket has closed or disconnected.\n ;) $fd_readwrite_hangup))\n(;; The contents of an `event` for the `eventtype::fd_read` and\n`eventtype::fd_write` variants\n ;) (typename $event_fd_readwrite (record (;; The number of bytes available for reading or writing.\n ;) (field $nbytes $filesize) (;; The state of the file descriptor.\n ;) (field $flags $eventrwflags)))\n(;; An event that occurred.\n ;) (typename $event (record (;; User-provided value that got attached to `subscription::userdata`.\n ;) (field $userdata $userdata) (;; If non-zero, an error that occurred while processing the subscription request.\n ;) (field $error $errno) (;; The type of event that occured\n ;) (field $type $eventtype) (;; The contents of the event, if it is an `eventtype::fd_read` or\n`eventtype::fd_write`. `eventtype::clock` events ignore this field.\n ;) (field $fd_readwrite $event_fd_readwrite)))\n(;; Flags determining how to interpret the timestamp provided in\n`subscription_clock::timeout`.\n ;) (typename $subclockflags (flags (@witx repr u16) (;; If set, treat the timestamp provided in\n`subscription_clock::timeout` as an absolute timestamp of clock\n`subscription_clock::id`. If clear, treat the timestamp\nprovided in `subscription_clock::timeout` relative to the\ncurrent time value of clock `subscription_clock::id`.\n ;) $subscription_clock_abstime))\n(;; The contents of a `subscription` when type is `eventtype::clock`.\n ;) (typename $subscription_clock (record (;; The user-defined unique identifier of the clock.\n ;) (field $identifier $userdata) (;; The clock against which to compare the timestamp.\n ;) (field $id $clockid) (;; The absolute or relative timestamp.\n ;) (field $timeout $timestamp) (;; The amount of time that the implementation may wait additionally\nto coalesce with other events.\n ;) (field $precision $timestamp) (;; Flags specifying whether the timeout is absolute or relative\n ;) (field $flags $subclockflags)))\n(;; The contents of a `subscription` when the variant is\n`eventtype::fd_read` or `eventtype::fd_write`.\n ;) (typename $subscription_fd_readwrite (record (;; The file descriptor on which to wait for it to become ready for reading or writing.\n ;) (field $file_descriptor $fd)))\n(;; The contents of a `subscription`.\n ;) (typename $subscription_u (variant (@witx tag u8) (case $clock $subscription_clock) (case $fd_read $subscription_fd_readwrite) (case $fd_write $subscription_fd_readwrite)))\n(;; Subscription to an event.\n ;) (typename $subscription (record (;; User-provided value that is attached to the subscription in the\nimplementation and returned through `event::userdata`.\n ;) (field $userdata $userdata) (;; The type of the event to which to subscribe.\n ;) (field $u $subscription_u)))\n(;; Exit code generated by a process when exiting.\n ;) (typename $exitcode u32)\n(;; Signal condition.\n ;) (typename $signal (enum (@witx tag u8) (;; No signal. Note that POSIX has special semantics for `kill(pid, 0)`,\nso this value is reserved.\n ;) $none (;; Hangup.\nAction: Terminates the process.\n ;) $hup (;; Terminate interrupt signal.\nAction: Terminates the process.\n ;) $int (;; Terminal quit signal.\nAction: Terminates the process.\n ;) $quit (;; Illegal instruction.\nAction: Terminates the process.\n ;) $ill (;; Trace/breakpoint trap.\nAction: Terminates the process.\n ;) $trap (;; Process abort signal.\nAction: Terminates the process.\n ;) $abrt (;; Access to an undefined portion of a memory object.\nAction: Terminates the process.\n ;) $bus (;; Erroneous arithmetic operation.\nAction: Terminates the process.\n ;) $fpe (;; Kill.\nAction: Terminates the process.\n ;) $kill (;; User-defined signal 1.\nAction: Terminates the process.\n ;) $usr1 (;; Invalid memory reference.\nAction: Terminates the process.\n ;) $segv (;; User-defined signal 2.\nAction: Terminates the process.\n ;) $usr2 (;; Write on a pipe with no one to read it.\nAction: Ignored.\n ;) $pipe (;; Alarm clock.\nAction: Terminates the process.\n ;) $alrm (;; Termination signal.\nAction: Terminates the process.\n ;) $term (;; Child process terminated, stopped, or continued.\nAction: Ignored.\n ;) $chld (;; Continue executing, if stopped.\nAction: Continues executing, if stopped.\n ;) $cont (;; Stop executing.\nAction: Stops executing.\n ;) $stop (;; Terminal stop signal.\nAction: Stops executing.\n ;) $tstp (;; Background process attempting read.\nAction: Stops executing.\n ;) $ttin (;; Background process attempting write.\nAction: Stops executing.\n ;) $ttou (;; High bandwidth data is available at a socket.\nAction: Ignored.\n ;) $urg (;; CPU time limit exceeded.\nAction: Terminates the process.\n ;) $xcpu (;; File size limit exceeded.\nAction: Terminates the process.\n ;) $xfsz (;; Virtual timer expired.\nAction: Terminates the process.\n ;) $vtalrm (;; Profiling timer expired.\nAction: Terminates the process.\n ;) $prof (;; Window changed.\nAction: Ignored.\n ;) $winch (;; I/O possible.\nAction: Terminates the process.\n ;) $poll (;; Power failure.\nAction: Terminates the process.\n ;) $pwr (;; Bad system call.\nAction: Terminates the process.\n ;) $sys))\n(;; Flags provided to `sock_recv`.\n ;) (typename $riflags (flags (@witx repr u16) (;; Returns the message without removing it from the socket\&#39;s receive queue.\n ;) $recv_peek (;; On byte-stream sockets, block until the full amount of data can be returned.\n ;) $recv_waitall))\n(;; Flags returned by `sock_recv`.\n ;) (typename $roflags (flags (@witx repr u16) (;; Returned by `sock_recv`: Message data has been truncated.\n ;) $recv_data_truncated))\n(;; Flags provided to `sock_send`. As there are currently no flags\ndefined, it must be set to zero.\n ;) (typename $siflags u16)\n(;; Which channels on a socket to shut down.\n ;) (typename $sdflags (flags (@witx repr u8) (;; Disables further receive operations.\n ;) $rd (;; Disables further send operations.\n ;) $wr))\n(;; Identifiers for preopened capabilities.\n ;) (typename $preopentype (enum (@witx tag u8) (;; A pre-opened directory.\n ;) $dir))\n(;; The contents of a $prestat when type is `preopentype::dir`.\n ;) (typename $prestat_dir (record (;; The length of the directory name for use with `fd_prestat_dir_name`.\n ;) (field $pr_name_len $size)))\n(;; Information about a pre-opened capability.\n ;) (typename $prestat (variant (@witx tag u8) (case $dir $prestat_dir)))\n(;; This API predated the convention of naming modules with a `wasi_unstable_`\nprefix and a version number. It is preserved here for compatibility, but\nwe shouldn\&#39;t follow this pattern in new APIs.\n ;) (module $wasi_unstable (;; Linear memory to be accessed by WASI functions that need it.\n ;) (import \&quot;memory\&quot; (memory)) (;; Read command-line argument data.\nThe size of the array should match that returned by `args_sizes_get`.\nEach argument is expected to be `\\0` terminated.\n ;) (@interface func (export \&quot;args_get\&quot;) (param $argv (@witx pointer (@witx pointer u8))) (param $argv_buf (@witx pointer u8)) (result $error (variant (@witx tag u32) (case $ok) (case $err $errno)))) (;; Return command-line argument data sizes.\n ;) (@interface func (export \&quot;args_sizes_get\&quot;) (;; Returns the number of arguments and the size of the argument string\ndata, or an error.\n ;) (result $error (variant (@witx tag u32) (case $ok (tuple $size $size)) (case $err $errno)))) (;; Read environment variable data.\nThe sizes of the buffers should match that returned by `environ_sizes_get`.\nKey/value pairs are expected to be joined with `=`s, and terminated with `\\0`s.\n ;) (@interface func (export \&quot;environ_get\&quot;) (param $environ (@witx pointer (@witx pointer u8))) (param $environ_buf (@witx pointer u8)) (result $error (variant (@witx tag u32) (case $ok) (case $err $errno)))) (;; Return environment variable data sizes.\n ;) (@interface func (export \&quot;environ_sizes_get\&quot;) (;; Returns the number of environment variable arguments and the size of the\nenvironment variable data.\n ;) (result $error (variant (@witx tag u32) (case $ok (tuple $size $size)) (case $err $errno)))) (;; Return the resolution of a clock.\nImplementations are required to provide a non-zero value for supported clocks. For unsupported clocks, return\n`errno::inval`.\nNote: This is similar to `clock_getres` in POSIX.\n ;) (@interface func (export \&quot;clock_res_get\&quot;) (;; The clock for which to return the resolution.\n ;) (param $id $clockid) (;; The resolution of the clock, or an error if one happened.\n ;) (result $error (variant (@witx tag u32) (case $ok $timestamp) (case $err $errno)))) (;; Return the time value of a clock.\nNote: This is similar to `clock_gettime` in POSIX.\n ;) (@interface func (export \&quot;clock_time_get\&quot;) (;; The clock for which to return the time.\n ;) (param $id $clockid) (;; The maximum lag (exclusive) that the returned time value may have, compared to its actual value.\n ;) (param $precision $timestamp) (;; The time value of the clock.\n ;) (result $error (variant (@witx tag u32) (case $ok $timestamp) (case $err $errno)))) (;; Provide file advisory information on a file descriptor.\nNote: This is similar to `posix_fadvise` in POSIX.\n ;) (@interface func (export \&quot;fd_advise\&quot;) (param $fd $fd) (;; The offset within the file to which the advisory applies.\n ;) (param $offset $filesize) (;; The length of the region to which the advisory applies.\n ;) (param $len $filesize) (;; The advice.\n ;) (param $advice $advice) (result $error (variant (@witx tag u32) (case $ok) (case $err $errno)))) (;; Force the allocation of space in a file.\nNote: This is similar to `posix_fallocate` in POSIX.\n ;) (@interface func (export \&quot;fd_allocate\&quot;) (param $fd $fd) (;; The offset at which to start the allocation.\n ;) (param $offset $filesize) (;; The length of the area that is allocated.\n ;) (param $len $filesize) (result $error (variant (@witx tag u32) (case $ok) (case $err $errno)))) (;; Close a file descriptor.\nNote: This is similar to `close` in POSIX.\n ;) (@interface func (export \&quot;fd_close\&quot;) (param $fd $fd) (result $error (variant (@witx tag u32) (case $ok) (case $err $errno)))) (;; Synchronize the data of a file to disk.\nNote: This is similar to `fdatasync` in POSIX.\n ;) (@interface func (export \&quot;fd_datasync\&quot;) (param $fd $fd) (result $error (variant (@witx tag u32) (case $ok) (case $err $errno)))) (;; Get the attributes of a file descriptor.\nNote: This returns similar flags to `fsync(fd, F_GETFL)` in POSIX, as well as additional fields.\n ;) (@interface func (export \&quot;fd_fdstat_get\&quot;) (param $fd $fd) (;; The buffer where the file descriptor\&#39;s attributes are stored.\n ;) (result $error (variant (@witx tag u32) (case $ok $fdstat) (case $err $errno)))) (;; Adjust the flags associated with a file descriptor.\nNote: This is similar to `fcntl(fd, F_SETFL, flags)` in POSIX.\n ;) (@interface func (export \&quot;fd_fdstat_set_flags\&quot;) (param $fd $fd) (;; The desired values of the file descriptor flags.\n ;) (param $flags $fdflags) (result $error (variant (@witx tag u32) (case $ok) (case $err $errno)))) (;; Adjust the rights associated with a file descriptor.\nThis can only be used to remove rights, and returns `errno::notcapable` if called in a way that would attempt to add rights\n ;) (@interface func (export \&quot;fd_fdstat_set_rights\&quot;) (param $fd $fd) (;; The desired rights of the file descriptor.\n ;) (param $fs_rights_base $rights) (param $fs_rights_inheriting $rights) (result $error (variant (@witx tag u32) (case $ok) (case $err $errno)))) (;; Return the attributes of an open file.\n ;) (@interface func (export \&quot;fd_filestat_get\&quot;) (param $fd $fd) (;; The buffer where the file\&#39;s attributes are stored.\n ;) (result $error (variant (@witx tag u32) (case $ok $filestat) (case $err $errno)))) (;; Adjust the size of an open file. If this increases the file\&#39;s size, the extra bytes are filled with zeros.\nNote: This is similar to `ftruncate` in POSIX.\n ;) (@interface func (export \&quot;fd_filestat_set_size\&quot;) (param $fd $fd) (;; The desired file size.\n ;) (param $size $filesize) (result $error (variant (@witx tag u32) (case $ok) (case $err $errno)))) (;; Adjust the timestamps of an open file or directory.\nNote: This is similar to `futimens` in POSIX.\n ;) (@interface func (export \&quot;fd_filestat_set_times\&quot;) (param $fd $fd) (;; The desired values of the data access timestamp.\n ;) (param $atim $timestamp) (;; The desired values of the data modification timestamp.\n ;) (param $mtim $timestamp) (;; A bitmask indicating which timestamps to adjust.\n ;) (param $fst_flags $fstflags) (result $error (variant (@witx tag u32) (case $ok) (case $err $errno)))) (;; Read from a file descriptor, without using and updating the file descriptor\&#39;s offset.\nNote: This is similar to `preadv` in POSIX.\n ;) (@interface func (export \&quot;fd_pread\&quot;) (param $fd $fd) (;; List of scatter/gather vectors in which to store data.\n ;) (param $iovs $iovec_array) (;; The offset within the file at which to read.\n ;) (param $offset $filesize) (;; The number of bytes read.\n ;) (result $error (variant (@witx tag u32) (case $ok $size) (case $err $errno)))) (;; Return a description of the given preopened file descriptor.\n ;) (@interface func (export \&quot;fd_prestat_get\&quot;) (param $fd $fd) (;; The buffer where the description is stored.\n ;) (result $error (variant (@witx tag u32) (case $ok $prestat) (case $err $errno)))) (;; Return a description of the given preopened file descriptor.\n ;) (@interface func (export \&quot;fd_prestat_dir_name\&quot;) (param $fd $fd) (;; A buffer into which to write the preopened directory name.\n ;) (param $path (@witx pointer u8)) (param $path_len $size) (result $error (variant (@witx tag u32) (case $ok) (case $err $errno)))) (;; Write to a file descriptor, without using and updating the file descriptor\&#39;s offset.\nNote: This is similar to `pwritev` in POSIX.\n ;) (@interface func (export \&quot;fd_pwrite\&quot;) (param $fd $fd) (;; List of scatter/gather vectors from which to retrieve data.\n ;) (param $iovs $ciovec_array) (;; The offset within the file at which to write.\n ;) (param $offset $filesize) (;; The number of bytes written.\n ;) (result $error (variant (@witx tag u32) (case $ok $size) (case $err $errno)))) (;; Read from a file descriptor.\nNote: This is similar to `readv` in POSIX.\n ;) (@interface func (export \&quot;fd_read\&quot;) (param $fd $fd) (;; List of scatter/gather vectors to which to store data.\n ;) (param $iovs $iovec_array) (;; The number of bytes read.\n ;) (result $error (variant (@witx tag u32) (case $ok $size) (case $err $errno)))) (;; Read directory entries from a directory.\nWhen successful, the contents of the output buffer consist of a sequence of\ndirectory entries. Each directory entry consists of a `dirent` object,\nfollowed by `dirent::d_namlen` bytes holding the name of the directory\nentry.\nThis function fills the output buffer as much as possible, potentially\ntruncating the last directory entry. This allows the caller to grow its\nread buffer size in case it\&#39;s too small to fit a single large directory\nentry, or skip the oversized directory entry.\n ;) (@interface func (export \&quot;fd_readdir\&quot;) (param $fd $fd) (;; The buffer where directory entries are stored\n ;) (param $buf (@witx pointer u8)) (param $buf_len $size) (;; The location within the directory to start reading\n ;) (param $cookie $dircookie) (;; The number of bytes stored in the read buffer. If less than the size of the read buffer, the end of the directory has been reached.\n ;) (result $error (variant (@witx tag u32) (case $ok $size) (case $err $errno)))) (;; Atomically replace a file descriptor by renumbering another file descriptor.\nDue to the strong focus on thread safety, this environment does not provide\na mechanism to duplicate or renumber a file descriptor to an arbitrary\nnumber, like `dup2()`. This would be prone to race conditions, as an actual\nfile descriptor with the same number could be allocated by a different\nthread at the same time.\nThis function provides a way to atomically renumber file descriptors, which\nwould disappear if `dup2()` were to be removed entirely.\n ;) (@interface func (export \&quot;fd_renumber\&quot;) (param $fd $fd) (;; The file descriptor to overwrite.\n ;) (param $to $fd) (result $error (variant (@witx tag u32) (case $ok) (case $err $errno)))) (;; Move the offset of a file descriptor.\nNote: This is similar to `lseek` in POSIX.\n ;) (@interface func (export \&quot;fd_seek\&quot;) (param $fd $fd) (;; The number of bytes to move.\n ;) (param $offset $filedelta) (;; The base from which the offset is relative.\n ;) (param $whence $whence) (;; The new offset of the file descriptor, relative to the start of the file.\n ;) (result $error (variant (@witx tag u32) (case $ok $filesize) (case $err $errno)))) (;; Synchronize the data and metadata of a file to disk.\nNote: This is similar to `fsync` in POSIX.\n ;) (@interface func (export \&quot;fd_sync\&quot;) (param $fd $fd) (result $error (variant (@witx tag u32) (case $ok) (case $err $errno)))) (;; Return the current offset of a file descriptor.\nNote: This is similar to `lseek(fd, 0, SEEK_CUR)` in POSIX.\n ;) (@interface func (export \&quot;fd_tell\&quot;) (param $fd $fd) (;; The current offset of the file descriptor, relative to the start of the file.\n ;) (result $error (variant (@witx tag u32) (case $ok $filesize) (case $err $errno)))) (;; Write to a file descriptor.\nNote: This is similar to `writev` in POSIX.\n ;) (@interface func (export \&quot;fd_write\&quot;) (param $fd $fd) (;; List of scatter/gather vectors from which to retrieve data.\n ;) (param $iovs $ciovec_array) (result $error (variant (@witx tag u32) (case $ok $size) (case $err $errno)))) (;; Create a directory.\nNote: This is similar to `mkdirat` in POSIX.\n ;) (@interface func (export \&quot;path_create_directory\&quot;) (param $fd $fd) (;; The path at which to create the directory.\n ;) (param $path (list char)) (result $error (variant (@witx tag u32) (case $ok) (case $err $errno)))) (;; Return the attributes of a file or directory.\nNote: This is similar to `stat` in POSIX.\n ;) (@interface func (export \&quot;path_filestat_get\&quot;) (param $fd $fd) (;; Flags determining the method of how the path is resolved.\n ;) (param $flags $lookupflags) (;; The path of the file or directory to inspect.\n ;) (param $path (list char)) (;; The buffer where the file\&#39;s attributes are stored.\n ;) (result $error (variant (@witx tag u32) (case $ok $filestat) (case $err $errno)))) (;; Adjust the timestamps of a file or directory.\nNote: This is similar to `utimensat` in POSIX.\n ;) (@interface func (export \&quot;path_filestat_set_times\&quot;) (param $fd $fd) (;; Flags determining the method of how the path is resolved.\n ;) (param $flags $lookupflags) (;; The path of the file or directory to operate on.\n ;) (param $path (list char)) (;; The desired values of the data access timestamp.\n ;) (param $atim $timestamp) (;; The desired values of the data modification timestamp.\n ;) (param $mtim $timestamp) (;; A bitmask indicating which timestamps to adjust.\n ;) (param $fst_flags $fstflags) (result $error (variant (@witx tag u32) (case $ok) (case $err $errno)))) (;; Create a hard link.\nNote: This is similar to `linkat` in POSIX.\n ;) (@interface func (export \&quot;path_link\&quot;) (param $old_fd $fd) (;; Flags determining the method of how the path is resolved.\n ;) (param $old_flags $lookupflags) (;; The source path from which to link.\n ;) (param $old_path (list char)) (;; The working directory at which the resolution of the new path starts.\n ;) (param $new_fd $fd) (;; The destination path at which to create the hard link.\n ;) (param $new_path (list char)) (result $error (variant (@witx tag u32) (case $ok) (case $err $errno)))) (;; Open a file or directory.\nThe returned file descriptor is not guaranteed to be the lowest-numbered\nfile descriptor not currently open; it is randomized to prevent\napplications from depending on making assumptions about indexes, since this\nis error-prone in multi-threaded contexts. The returned file descriptor is\nguaranteed to be less than 2**31.\nNote: This is similar to `openat` in POSIX.\n ;) (@interface func (export \&quot;path_open\&quot;) (param $fd $fd) (;; Flags determining the method of how the path is resolved.\n ;) (param $dirflags $lookupflags) (;; The relative path of the file or directory to open, relative to the\n`path_open::fd` directory.\n ;) (param $path (list char)) (;; The method by which to open the file.\n ;) (param $oflags $oflags) (;; The initial rights of the newly created file descriptor. The\nimplementation is allowed to return a file descriptor with fewer rights\nthan specified, if and only if those rights do not apply to the type of\nfile being opened.\nThe *base* rights are rights that will apply to operations using the file\ndescriptor itself, while the *inheriting* rights are rights that apply to\nfile descriptors derived from it.\n ;) (param $fs_rights_base $rights) (param $fs_rights_inheriting $rights) (param $fdflags $fdflags) (;; The file descriptor of the file that has been opened.\n ;) (result $error (variant (@witx tag u32) (case $ok $fd) (case $err $errno)))) (;; Read the contents of a symbolic link.\nNote: This is similar to `readlinkat` in POSIX.\n ;) (@interface func (export \&quot;path_readlink\&quot;) (param $fd $fd) (;; The path of the symbolic link from which to read.\n ;) (param $path (list char)) (;; The buffer to which to write the contents of the symbolic link.\n ;) (param $buf (@witx pointer u8)) (param $buf_len $size) (;; The number of bytes placed in the buffer.\n ;) (result $error (variant (@witx tag u32) (case $ok $size) (case $err $errno)))) (;; Remove a directory.\nReturn `errno::notempty` if the directory is not empty.\nNote: This is similar to `unlinkat(fd, path, AT_REMOVEDIR)` in POSIX.\n ;) (@interface func (export \&quot;path_remove_directory\&quot;) (param $fd $fd) (;; The path to a directory to remove.\n ;) (param $path (list char)) (result $error (variant (@witx tag u32) (case $ok) (case $err $errno)))) (;; Rename a file or directory.\nNote: This is similar to `renameat` in POSIX.\n ;) (@interface func (export \&quot;path_rename\&quot;) (param $fd $fd) (;; The source path of the file or directory to rename.\n ;) (param $old_path (list char)) (;; The working directory at which the resolution of the new path starts.\n ;) (param $new_fd $fd) (;; The destination path to which to rename the file or directory.\n ;) (param $new_path (list char)) (result $error (variant (@witx tag u32) (case $ok) (case $err $errno)))) (;; Create a symbolic link.\nNote: This is similar to `symlinkat` in POSIX.\n ;) (@interface func (export \&quot;path_symlink\&quot;) (;; The contents of the symbolic link.\n ;) (param $old_path (list char)) (param $fd $fd) (;; The destination path at which to create the symbolic link.\n ;) (param $new_path (list char)) (result $error (variant (@witx tag u32) (case $ok) (case $err $errno)))) (;; Unlink a file.\nReturn `errno::isdir` if the path refers to a directory.\nNote: This is similar to `unlinkat(fd, path, 0)` in POSIX.\n ;) (@interface func (export \&quot;path_unlink_file\&quot;) (param $fd $fd) (;; The path to a file to unlink.\n ;) (param $path (list char)) (result $error (variant (@witx tag u32) (case $ok) (case $err $errno)))) (;; Concurrently poll for the occurrence of a set of events.\n ;) (@interface func (export \&quot;poll_oneoff\&quot;) (;; The events to which to subscribe.\n ;) (param $in (@witx const_pointer $subscription)) (;; The events that have occurred.\n ;) (param $out (@witx pointer $event)) (;; Both the number of subscriptions and events.\n ;) (param $nsubscriptions $size) (;; The number of events stored.\n ;) (result $error (variant (@witx tag u32) (case $ok $size) (case $err $errno)))) (;; Terminate the process normally. An exit code of 0 indicates successful\ntermination of the program. The meanings of other values is dependent on\nthe environment.\n ;) (@interface func (export \&quot;proc_exit\&quot;) (;; The exit code returned by the process.\n ;) (param $rval $exitcode) (@witx noreturn)) (;; Send a signal to the process of the calling thread.\nNote: This is similar to `raise` in POSIX.\n ;) (@interface func (export \&quot;proc_raise\&quot;) (;; The signal condition to trigger.\n ;) (param $sig $signal) (result $error (variant (@witx tag u32) (case $ok) (case $err $errno)))) (;; Temporarily yield execution of the calling thread.\nNote: This is similar to `sched_yield` in POSIX.\n ;) (@interface func (export \&quot;sched_yield\&quot;) (result $error (variant (@witx tag u32) (case $ok) (case $err $errno)))) (;; Write high-quality random data into a buffer.\nThis function blocks when the implementation is unable to immediately\nprovide sufficient high-quality random data.\nThis function may execute slowly, so when large mounts of random data are\nrequired, it\&#39;s advisable to use this function to seed a pseudo-random\nnumber generator, rather than to provide the random data directly.\n ;) (@interface func (export \&quot;random_get\&quot;) (;; The buffer to fill with random data.\n ;) (param $buf (@witx pointer u8)) (param $buf_len $size) (result $error (variant (@witx tag u32) (case $ok) (case $err $errno)))) (;; Receive a message from a socket.\nNote: This is similar to `recv` in POSIX, though it also supports reading\nthe data into multiple buffers in the manner of `readv`.\n ;) (@interface func (export \&quot;sock_recv\&quot;) (param $fd $fd) (;; List of scatter/gather vectors to which to store data.\n ;) (param $ri_data $iovec_array) (;; Message flags.\n ;) (param $ri_flags $riflags) (;; Number of bytes stored in ri_data and message flags.\n ;) (result $error (variant (@witx tag u32) (case $ok (tuple $size $roflags)) (case $err $errno)))) (;; Send a message on a socket.\nNote: This is similar to `send` in POSIX, though it also supports writing\nthe data from multiple buffers in the manner of `writev`.\n ;) (@interface func (export \&quot;sock_send\&quot;) (param $fd $fd) (;; List of scatter/gather vectors to which to retrieve data\n ;) (param $si_data $ciovec_array) (;; Message flags.\n ;) (param $si_flags $siflags) (;; Number of bytes transmitted.\n ;) (result $error (variant (@witx tag u32) (case $ok $size) (case $err $errno)))) (;; Shut down socket send and receive channels.\nNote: This is similar to `shutdown` in POSIX.\n ;) (@interface func (export \&quot;sock_shutdown\&quot;) (param $fd $fd) (;; Which channels on the socket to shut down.\n ;) (param $how $sdflags) (result $error (variant (@witx tag u32) (case $ok) (case $err $errno)))))\n&quot;;</code></pre></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../../../" data-current-crate="wasi_common" data-search-index-js="../../../../search-index.js" data-search-js="../../../../search.js"></div>
    <script src="../../../../main.js"></script><script src="../../../../scrape-examples.js"></script>
</body></html>