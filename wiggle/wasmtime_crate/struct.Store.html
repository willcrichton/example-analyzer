<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A [`Store`] is a collection of WebAssembly instances and host-defined state."><meta name="keywords" content="rust, rustlang, rust-lang, Store"><title>Store in wiggle::wasmtime_crate - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../wiggle/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><h2 class="location">Struct Store</h2><div class="sidebar-elems"><div class="block items"><h3 class="sidebar-title"><a href="#implementations">Associated Constants</a></h3><div class="sidebar-links"><a href="#associatedconstant.ALIGN">ALIGN</a></div><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><div class="sidebar-links"><a href="#method.add_fuel">add_fuel</a><a href="#method.call_hook">call_hook</a><a href="#method.consume_fuel">consume_fuel</a><a href="#method.data">data</a><a href="#method.data_mut">data_mut</a><a href="#method.engine">engine</a><a href="#method.fuel_consumed">fuel_consumed</a><a href="#method.gc">gc</a><a href="#method.interrupt_handle">interrupt_handle</a><a href="#method.into_data">into_data</a><a href="#method.limiter">limiter</a><a href="#method.limiter_async">limiter_async</a><a href="#method.new">new</a><a href="#method.out_of_fuel_async_yield">out_of_fuel_async_yield</a><a href="#method.out_of_fuel_trap">out_of_fuel_trap</a></div><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><div class="sidebar-links"><a href="#impl-AsContext">AsContext</a><a href="#impl-AsContextMut">AsContextMut</a><a href="#impl-Debug">Debug</a><a href="#impl-Default">Default</a><a href="#impl-Drop">Drop</a><a href="#impl-StoreExt">StoreExt</a></div><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><div class="sidebar-links"><a href="#impl-RefUnwindSafe">!RefUnwindSafe</a><a href="#impl-Send">Send</a><a href="#impl-Sync">Sync</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">!UnwindSafe</a></div><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Instrument">Instrument</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-Pointable">Pointable</a><a href="#impl-Pointee">Pointee</a><a href="#impl-Same%3CT%3E">Same&lt;T&gt;</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a><a href="#impl-VZip%3CV%3E">VZip&lt;V&gt;</a></div></div><h2 class="location">Other items in<br><a href="../index.html">wiggle</a>::<wbr><a href="index.html">wasmtime_crate</a></h2><div id="sidebar-vars" data-name="Store" data-ty="struct" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Struct <a href="../index.html">wiggle</a>::<wbr><a href="index.html">wasmtime_crate</a>::<wbr><a class="struct" href="#">Store</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></span></h1><div class="docblock item-decl"><pre class="rust struct"><code>pub struct Store&lt;T&gt; { /* fields omitted */ }</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A <a href="struct.Store.html" title="Store"><code>Store</code></a> is a collection of WebAssembly instances and host-defined state.</p>
<p>All WebAssembly instances and items will be attached to and refer to a
<a href="struct.Store.html" title="Store"><code>Store</code></a>. For example instances, functions, globals, and tables are all
attached to a <a href="struct.Store.html" title="Store"><code>Store</code></a>. Instances are created by instantiating a
<a href="struct.Module.html"><code>Module</code></a> within a <a href="struct.Store.html" title="Store"><code>Store</code></a>.</p>
<p>A <a href="struct.Store.html" title="Store"><code>Store</code></a> is intended to be a short-lived object in a program. No form
of GC is implemented at this time so once an instance is created within a
<a href="struct.Store.html" title="Store"><code>Store</code></a> it will not be deallocated until the <a href="struct.Store.html" title="Store"><code>Store</code></a> itself is dropped.
This makes <a href="struct.Store.html" title="Store"><code>Store</code></a> unsuitable for creating an unbounded number of
instances in it because <a href="struct.Store.html" title="Store"><code>Store</code></a> will never release this memory. It’s
recommended to have a <a href="struct.Store.html" title="Store"><code>Store</code></a> correspond roughly to the lifetime of a “main
instance” that an embedding is interested in executing.</p>
<h3 id="type-parameter-t" class="section-header"><a href="#type-parameter-t">Type parameter <code>T</code></a></h3>
<p>Each <a href="struct.Store.html" title="Store"><code>Store</code></a> has a type parameter <code>T</code> associated with it. This <code>T</code>
represents state defined by the host. This state will be accessible through
the <a href="struct.Caller.html"><code>Caller</code></a> type that host-defined functions get access
to. This <code>T</code> is suitable for storing <code>Store</code>-specific information which
imported functions may want access to.</p>
<p>The data <code>T</code> can be accessed through methods like <a href="struct.Store.html#method.data" title="Store::data"><code>Store::data</code></a> and
<a href="struct.Store.html#method.data_mut" title="Store::data_mut"><code>Store::data_mut</code></a>.</p>
<h3 id="stores-contexts-oh-my" class="section-header"><a href="#stores-contexts-oh-my">Stores, contexts, oh my</a></h3>
<p>Most methods in Wasmtime take something of the form
<a href="trait.AsContext.html"><code>AsContext</code></a> or <a href="trait.AsContextMut.html"><code>AsContextMut</code></a> as
the first argument. These two traits allow ergonomically passing in the
context you currently have to any method. The primary two sources of
contexts are:</p>
<ul>
<li><code>Store&lt;T&gt;</code></li>
<li><code>Caller&lt;'_, T&gt;</code></li>
</ul>
<p>corresponding to what you create and what you have access to in a host
function. You can also explicitly acquire a <a href="struct.StoreContext.html" title="StoreContext"><code>StoreContext</code></a> or
<a href="struct.StoreContextMut.html" title="StoreContextMut"><code>StoreContextMut</code></a> and pass that around as well.</p>
<p>Note that all methods on <a href="struct.Store.html" title="Store"><code>Store</code></a> are mirrored onto <a href="struct.StoreContext.html" title="StoreContext"><code>StoreContext</code></a>,
<a href="struct.StoreContextMut.html" title="StoreContextMut"><code>StoreContextMut</code></a>, and <a href="struct.Caller.html"><code>Caller</code></a>. This way no matter what
form of context you have you can call various methods, create objects, etc.</p>
<h3 id="stores-and-default" class="section-header"><a href="#stores-and-default">Stores and <code>Default</code></a></h3>
<p>You can create a store with default configuration settings using
<code>Store::default()</code>. This will create a brand new <a href="struct.Engine.html" title="Engine"><code>Engine</code></a> with default
configuration (see <a href="struct.Config.html"><code>Config</code></a> for more information).</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl" class="impl has-srclink"><div class="rightside"></div><a href="#impl" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="struct" href="struct.Store.html" title="struct wiggle::wasmtime_crate::Store">Store</a>&lt;T&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.new" class="method has-srclink"><div class="rightside"></div><a href="#method.new" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.new" class="fnname">new</a>(engine: &amp;<a class="struct" href="struct.Engine.html" title="struct wiggle::wasmtime_crate::Engine">Engine</a>, data: T) -&gt; <a class="struct" href="struct.Store.html" title="struct wiggle::wasmtime_crate::Store">Store</a>&lt;T&gt;</h4></div></summary><div class="docblock"><p>Creates a new <a href="struct.Store.html" title="Store"><code>Store</code></a> to be associated with the given <a href="struct.Engine.html" title="Engine"><code>Engine</code></a> and
<code>data</code> provided.</p>
<p>The created <a href="struct.Store.html" title="Store"><code>Store</code></a> will place no additional limits on the size of
linear memories or tables at runtime. Linear memories and tables will
be allowed to grow to any upper limit specified in their definitions.
The store will limit the number of instances, linear memories, and
tables created to 10,000. This can be overridden with the
<a href="struct.Store.html#method.limiter" title="Store::limiter"><code>Store::limiter</code></a> configuration method.</p>
</div><div class="docblock scraped-example-list"><span></span><h5 id="scraped-examples" class="section-header"><a href="#scraped-examples">Examples found in repository</a></h5><div class="scraped-example " data-locs="[[[5,5],&quot;../../src/fib_debug/main.rs.html#19&quot;,&quot;line 19&quot;]]"><div class="scraped-example-title">examples/fib-debug/main.rs (<a href="../../src/fib_debug/main.rs.html#19">line 19</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Load our previously compiled wasm file (built previously with Cargo) and</span>
  <span class="comment">// also ensure that we generate debuginfo so this executable can be</span>
  <span class="comment">// debugged in GDB.</span>
  <span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>(<span class="ident">Config::new</span>().<span class="ident">debug_info</span>(<span class="bool-val">true</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="highlight focus"><span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ())</span>;
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, <span class="string">&quot;target/wasm32-unknown-unknown/debug/fib.wasm&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="comment">// Invoke `fib` export</span>
  <span class="kw">let</span> <span class="ident">fib</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;fib&quot;</span>)<span class="question-mark">?</span>;
  <span class="macro">println!</span>(<span class="string">&quot;fib(6) = {}&quot;</span>, <span class="ident">fib</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">6</span>)<span class="question-mark">?</span>);
  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><details class="rustdoc-toggle more-examples-toggle"><summary class="hideme"><span>More examples</span></summary><div class="more-scraped-examples"><div class="toggle-line"><div class="toggle-line-inner"></div></div><div class="more-scraped-examples-inner"><div class="scraped-example " data-locs="[[[4,4],&quot;../../src/threads/threads.rs.html#53&quot;,&quot;line 53&quot;]]"><div class="scraped-example-title">examples/threads.rs (<a href="../../src/threads/threads.rs.html#53">line 53</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
<span>57</span>
<span>58</span>
<span>59</span>
<span>60</span>
<span>61</span>
<span>62</span>
<span>63</span>
<span>64</span>
<span>65</span>
<span>66</span>
<span>67</span>
<span>68</span>
<span>69</span>
<span>70</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">run</span>(<span class="ident">engine</span>: <span class="kw-2">&amp;</span><span class="ident">Engine</span>, <span class="ident">module</span>: <span class="kw-2">&amp;</span><span class="ident">Module</span>, <span class="ident">linker</span>: <span class="kw-2">&amp;</span><span class="ident">Linker</span><span class="op">&lt;</span>()<span class="op">&gt;</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Each sub-thread we have starting out by instantiating the `module`</span>
  <span class="comment">// provided into a fresh `Store`.</span>
  <span class="macro">println!</span>(<span class="string">&quot;Instantiating module...&quot;</span>);
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="highlight focus"><span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ())</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">linker</span>.<span class="ident">instantiate</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="ident">module</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">run</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;run&quot;</span>)<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Executing...&quot;</span>);
  <span class="kw">for</span> <span class="kw">_</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">N_REPS</span> {
    <span class="ident">run</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>;
    <span class="ident">thread::sleep</span>(<span class="ident">time::Duration::from_millis</span>(<span class="number">100</span>));
  }

  <span class="comment">// Also note that that a `Store` can also move between threads:</span>
  <span class="macro">println!</span>(<span class="string">&quot;&gt; Moving {:?} to a new thread&quot;</span>, <span class="ident">thread::current</span>().<span class="ident">id</span>());
  <span class="kw">let</span> <span class="ident">child</span> <span class="op">=</span> <span class="ident">thread::spawn</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span> <span class="ident">run</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ()));

  <span class="ident">child</span>.<span class="ident">join</span>().<span class="ident">unwrap</span>()<span class="question-mark">?</span>;

  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><div class="scraped-example " data-locs="[[[13,13],&quot;../../src/wasi/main.rs.html#23&quot;,&quot;line 23&quot;]]"><div class="scraped-example-title">examples/wasi/main.rs (<a href="../../src/wasi/main.rs.html#23">line 23</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Define the WASI functions globally on the `Config`.</span>
  <span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::default</span>();
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">linker</span> <span class="op">=</span> <span class="ident">Linker::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>);
  <span class="ident">wasmtime_wasi::add_to_linker</span>(<span class="kw-2">&amp;mut</span> <span class="ident">linker</span>, <span class="op">|</span><span class="ident">s</span><span class="op">|</span> <span class="ident">s</span>)<span class="question-mark">?</span>;

  <span class="comment">// Create a WASI context and put it in a Store; all instances in the store</span>
  <span class="comment">// share this context. `WasiCtxBuilder` provides a number of ways to</span>
  <span class="comment">// configure what the target program will have access to.</span>
  <span class="kw">let</span> <span class="ident">wasi</span> <span class="op">=</span> <span class="ident">WasiCtxBuilder::new</span>()
    .<span class="ident">inherit_stdio</span>()
    .<span class="ident">inherit_args</span>()<span class="question-mark">?</span>
    .<span class="ident">build</span>();
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="highlight focus"><span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, <span class="ident">wasi</span>)</span>;

  <span class="comment">// Instantiate our module with the imports we&#39;ve created, and run it.</span>
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, <span class="string">&quot;target/wasm32-wasi/debug/wasi.wasm&quot;</span>)<span class="question-mark">?</span>;
  <span class="ident">linker</span>.<span class="ident">module</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;&quot;</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>)<span class="question-mark">?</span>;
  <span class="ident">linker</span>
    .<span class="ident">get_default</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;&quot;</span>)<span class="question-mark">?</span>
    .<span class="ident">typed</span>::<span class="op">&lt;</span>(), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)<span class="question-mark">?</span>
    .<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>;

  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><div class="scraped-example " data-locs="[[[7,7],&quot;../../src/tokio/main.rs.html#95&quot;,&quot;line 95&quot;]]"><div class="scraped-example-title">examples/tokio/main.rs (<a href="../../src/tokio/main.rs.html#95">line 95</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span>88</span>
<span>89</span>
<span>90</span>
<span>91</span>
<span>92</span>
<span>93</span>
<span>94</span>
<span>95</span>
<span>96</span>
<span>97</span>
<span>98</span>
<span>99</span>
<span>100</span>
<span>101</span>
<span>102</span>
<span>103</span>
<span>104</span>
<span>105</span>
<span>106</span>
<span>107</span>
<span>108</span>
<span>109</span>
<span>110</span>
<span>111</span>
<span>112</span>
<span>113</span>
<span>114</span>
</pre><pre class="rust"><code><span class="kw">async</span> <span class="kw">fn</span> <span class="ident">run_wasm</span>(<span class="ident">inputs</span>: <span class="ident">Inputs</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Error</span><span class="op">&gt;</span> {
  <span class="kw">let</span> <span class="ident">wasi</span> <span class="op">=</span> <span class="ident">WasiCtxBuilder::new</span>()
    <span class="comment">// Let wasi print to this process&#39;s stdout.</span>
    .<span class="ident">inherit_stdout</span>()
    <span class="comment">// Set an environment variable so the wasm knows its name.</span>
    .<span class="ident">env</span>(<span class="string">&quot;NAME&quot;</span>, <span class="kw-2">&amp;</span><span class="ident">inputs</span>.<span class="ident">name</span>)<span class="question-mark">?</span>
    .<span class="ident">build</span>();
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="highlight focus"><span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">inputs</span>.<span class="ident">env</span>.<span class="ident">engine</span>, <span class="ident">wasi</span>)</span>;

  <span class="comment">// WebAssembly execution will be paused for an async yield every time it</span>
  <span class="comment">// consumes 10000 fuel. Fuel will be refilled u64::MAX times.</span>
  <span class="ident">store</span>.<span class="ident">out_of_fuel_async_yield</span>(<span class="ident">u64::MAX</span>, <span class="number">10000</span>);

  <span class="comment">// Instantiate into our own unique store using the shared linker, afterwards</span>
  <span class="comment">// acquiring the `_start` function for the module and executing it.</span>
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">inputs</span>
    .<span class="ident">env</span>
    .<span class="ident">linker</span>
    .<span class="ident">instantiate_async</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">inputs</span>.<span class="ident">env</span>.<span class="ident">module</span>)
    .<span class="kw">await</span><span class="question-mark">?</span>;
  <span class="ident">instance</span>
    .<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;_start&quot;</span>)<span class="question-mark">?</span>
    .<span class="ident">call_async</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())
    .<span class="kw">await</span><span class="question-mark">?</span>;

  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><div class="scraped-example " data-locs="[[[4,4],&quot;../../src/fuel/fuel.rs.html#12&quot;,&quot;line 12&quot;]]"><div class="scraped-example-title">examples/fuel.rs (<a href="../../src/fuel/fuel.rs.html#12">line 12</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span> 8</span>
<span> 9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">config</span> <span class="op">=</span> <span class="ident">Config::new</span>();
  <span class="ident">config</span>.<span class="ident">consume_fuel</span>(<span class="bool-val">true</span>);
  <span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>(<span class="kw-2">&amp;</span><span class="ident">config</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="highlight focus"><span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ())</span>;
  <span class="ident">store</span>.<span class="ident">add_fuel</span>(<span class="number">10_000</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="ident">store</span>.<span class="ident">engine</span>(), <span class="string">&quot;examples/fuel.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="comment">// Invoke `fibonacci` export with higher and higher numbers until we exhaust our fuel.</span>
  <span class="kw">let</span> <span class="ident">fibonacci</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;fibonacci&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">for</span> <span class="ident">n</span> <span class="kw">in</span> <span class="number">1</span>.. {
    <span class="kw">let</span> <span class="ident">fuel_before</span> <span class="op">=</span> <span class="ident">store</span>.<span class="ident">fuel_consumed</span>().<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">fibonacci</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="ident">n</span>) {
      <span class="prelude-val">Ok</span>(<span class="ident">v</span>) =&gt; <span class="ident">v</span>,
      <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; {
        <span class="macro">println!</span>(<span class="string">&quot;Exhausted fuel computing fib({})&quot;</span>, <span class="ident">n</span>);
        <span class="kw">break</span>;
      }
    };
    <span class="kw">let</span> <span class="ident">fuel_consumed</span> <span class="op">=</span> <span class="ident">store</span>.<span class="ident">fuel_consumed</span>().<span class="ident">unwrap</span>() <span class="op">-</span> <span class="ident">fuel_before</span>;
    <span class="macro">println!</span>(<span class="string">&quot;fib({}) = {} [consumed {} fuel]&quot;</span>, <span class="ident">n</span>, <span class="ident">output</span>, <span class="ident">fuel_consumed</span>);
    <span class="ident">store</span>.<span class="ident">add_fuel</span>(<span class="ident">fuel_consumed</span>)<span class="question-mark">?</span>;
  }
  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><div class="scraped-example " data-locs="[[[4,4],&quot;../../src/interrupt/interrupt.rs.html#13&quot;,&quot;line 13&quot;]]"><div class="scraped-example-title">examples/interrupt.rs (<a href="../../src/interrupt/interrupt.rs.html#13">line 13</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span> 9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Enable interruptable code via `Config` and then create an interrupt</span>
  <span class="comment">// handle which we&#39;ll use later to interrupt running code.</span>
  <span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>(<span class="ident">Config::new</span>().<span class="ident">interruptable</span>(<span class="bool-val">true</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="highlight focus"><span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ())</span>;
  <span class="kw">let</span> <span class="ident">interrupt_handle</span> <span class="op">=</span> <span class="ident">store</span>.<span class="ident">interrupt_handle</span>()<span class="question-mark">?</span>;

  <span class="comment">// Compile and instantiate a small example with an infinite loop.</span>
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, <span class="string">&quot;examples/interrupt.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">run</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;run&quot;</span>)<span class="question-mark">?</span>;

  <span class="comment">// Spin up a thread to send us an interrupt in a second</span>
  <span class="ident">std::thread::spawn</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span> {
    <span class="ident">std::thread::sleep</span>(<span class="ident">std::time::Duration::from_secs</span>(<span class="number">1</span>));
    <span class="macro">println!</span>(<span class="string">&quot;Interrupting!&quot;</span>);
    <span class="ident">interrupt_handle</span>.<span class="ident">interrupt</span>();
  });

  <span class="macro">println!</span>(<span class="string">&quot;Entering infinite loop ...&quot;</span>);
  <span class="kw">let</span> <span class="ident">trap</span> <span class="op">=</span> <span class="ident">run</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ()).<span class="ident">unwrap_err</span>();

  <span class="macro">println!</span>(<span class="string">&quot;trap received...&quot;</span>);
  <span class="macro">assert!</span>(<span class="ident">trap</span>.<span class="ident">to_string</span>().<span class="ident">contains</span>(<span class="string">&quot;wasm trap: interrupt&quot;</span>));

  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><div class="example-links">Additional examples can be found in:<br><ul><li><a href="../../src/linking/linking.rs.html#26">examples/linking.rs</a></li><li><a href="../../src/multi/multi.rs.html#17">examples/multi.rs</a></li><li><a href="../../src/externref/externref.rs.html#13">examples/externref.rs</a></li><li><a href="../../src/hello/hello.rs.html#28-34">examples/hello.rs</a></li><li><a href="../../src/multimemory/multimemory.rs.html#21">examples/multimemory.rs</a></li></ul></div></div></div></details></div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.data" class="method has-srclink"><div class="rightside"></div><a href="#method.data" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.data" class="fnname">data</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</h4></div></summary><div class="docblock"><p>Access the underlying data owned by this <code>Store</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.data_mut" class="method has-srclink"><div class="rightside"></div><a href="#method.data_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.data_mut" class="fnname">data_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</h4></div></summary><div class="docblock"><p>Access the underlying data owned by this <code>Store</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.into_data" class="method has-srclink"><div class="rightside"></div><a href="#method.into_data" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.into_data" class="fnname">into_data</a>(self) -&gt; T</h4></div></summary><div class="docblock"><p>Consumes this <a href="struct.Store.html" title="Store"><code>Store</code></a>, destroying it, and returns the underlying data.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.limiter" class="method has-srclink"><div class="rightside"></div><a href="#method.limiter" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.limiter" class="fnname">limiter</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;limiter: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T) -&gt; &amp;mut dyn <a class="trait" href="trait.ResourceLimiter.html" title="trait wiggle::wasmtime_crate::ResourceLimiter">ResourceLimiter</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static<br>)</h4></div></summary><div class="docblock"><p>Configures the <a href="trait.ResourceLimiter.html"><code>ResourceLimiter</code></a> used to limit
resource creation within this <a href="struct.Store.html" title="Store"><code>Store</code></a>.</p>
<p>Note that this limiter is only used to limit the creation/growth of
resources in the future, this does not retroactively attempt to apply
limits to the <a href="struct.Store.html" title="Store"><code>Store</code></a>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.limiter_async" class="method has-srclink"><div class="rightside"></div><a href="#method.limiter_async" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.limiter_async" class="fnname">limiter_async</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;limiter: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T) -&gt; &amp;mut dyn <a class="trait" href="trait.ResourceLimiterAsync.html" title="trait wiggle::wasmtime_crate::ResourceLimiterAsync">ResourceLimiterAsync</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static<br>)</h4></div></summary><div class="docblock"><p>Configures the <a href="trait.ResourceLimiterAsync.html"><code>ResourceLimiterAsync</code></a>
used to limit resource creation within this <a href="struct.Store.html" title="Store"><code>Store</code></a>. Must be used
with an async <code>Store</code>!.</p>
<p>Note that this limiter is only used to limit the creation/growth of
resources in the future, this does not retroactively attempt to apply
limits to the <a href="struct.Store.html" title="Store"><code>Store</code></a>.</p>
<p>This variation on the <a href="trait.ResourceLimiter.html"><code>ResourceLimiter</code></a>
makes the <code>memory_growing</code> and <code>table_growing</code> functions <code>async</code>. This
means that, as part of your resource limiting strategy, the async
resource limiter may yield execution until a resource becomes
available.</p>
<p>By using a <a href="trait.ResourceLimiterAsync.html"><code>ResourceLimiterAsync</code></a>
with a <a href="struct.Store.html" title="Store"><code>Store</code></a>, you can no longer use
<a href="struct.Memory.html#method.new"><code>Memory::new</code></a>,
<a href="struct.Memory.html#method.grow"><code>Memory::grow</code></a>,
<a href="struct.Table.html#method.new"><code>Table::new</code></a>, and
<a href="struct.Table.html#method.grow"><code>Table::grow</code></a>. Instead, you must use their
<code>async</code> variants: <a href="struct.Memory.html#method.new_async"><code>Memory::new_async</code></a>,
<a href="struct.Memory.html#method.grow_async"><code>Memory::grow_async</code></a>,
<a href="struct.Table.html#method.new_async"><code>Table::new_async</code></a>, and
<a href="struct.Table.html#method.grow_async"><code>Table::grow_async</code></a>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.call_hook" class="method has-srclink"><div class="rightside"></div><a href="#method.call_hook" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.call_hook" class="fnname">call_hook</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;hook: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T, <a class="enum" href="enum.CallHook.html" title="enum wiggle::wasmtime_crate::CallHook">CallHook</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.Trap.html" title="struct wiggle::wasmtime_crate::Trap">Trap</a>&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static<br>)</h4></div></summary><div class="docblock"><p>Configure a function that runs on calls and returns between WebAssembly
and host code.</p>
<p>The function is passed a <a href="enum.CallHook.html" title="CallHook"><code>CallHook</code></a> argument, which indicates which
state transition the VM is making.</p>
<p>This function may return a <a href="struct.Trap.html" title="Trap"><code>Trap</code></a>. If a trap is returned when an
import was called, it is immediately raised as-if the host import had
returned the trap. If a trap is returned after wasm returns to the host
then the wasm function’s result is ignored and this trap is returned
instead.</p>
<p>After this function returns a trap, it may be called for subsequent returns
to host or wasm code as the trap propogates to the root call.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.engine" class="method has-srclink"><div class="rightside"></div><a href="#method.engine" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.engine" class="fnname">engine</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.Engine.html" title="struct wiggle::wasmtime_crate::Engine">Engine</a></h4></div></summary><div class="docblock"><p>Returns the <a href="struct.Engine.html" title="Engine"><code>Engine</code></a> that this store is associated with.</p>
</div><div class="docblock scraped-example-list"><span></span><h5 id="scraped-examples-1" class="section-header"><a href="#scraped-examples-1">Examples found in repository</a></h5><div class="scraped-example " data-locs="[[[5,5],&quot;../../src/gcd/gcd.rs.html#14&quot;,&quot;line 14&quot;]]"><div class="scraped-example-title">examples/gcd.rs (<a href="../../src/gcd/gcd.rs.html#14">line 14</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span> 9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Load our WebAssembly (parsed WAT in our case), and then load it into a</span>
  <span class="comment">// `Module` which is attached to a `Store` cache. After we&#39;ve got that we</span>
  <span class="comment">// can instantiate it.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store</span>::<span class="op">&lt;</span>()<span class="op">&gt;</span><span class="ident">::default</span>();
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="ident">store</span>.<span class="highlight focus"><span class="ident">engine</span>()</span>, <span class="string">&quot;examples/gcd.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="comment">// Invoke `gcd` export</span>
  <span class="kw">let</span> <span class="ident">gcd</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;gcd&quot;</span>)<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;gcd(6, 27) = {}&quot;</span>, <span class="ident">gcd</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">6</span>, <span class="number">27</span>))<span class="question-mark">?</span>);
  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><details class="rustdoc-toggle more-examples-toggle"><summary class="hideme"><span>More examples</span></summary><div class="more-scraped-examples"><div class="toggle-line"><div class="toggle-line-inner"></div></div><div class="more-scraped-examples-inner"><div class="scraped-example " data-locs="[[[6,6],&quot;../../src/fuel/fuel.rs.html#14&quot;,&quot;line 14&quot;]]"><div class="scraped-example-title">examples/fuel.rs (<a href="../../src/fuel/fuel.rs.html#14">line 14</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span> 8</span>
<span> 9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">config</span> <span class="op">=</span> <span class="ident">Config::new</span>();
  <span class="ident">config</span>.<span class="ident">consume_fuel</span>(<span class="bool-val">true</span>);
  <span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>(<span class="kw-2">&amp;</span><span class="ident">config</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ());
  <span class="ident">store</span>.<span class="ident">add_fuel</span>(<span class="number">10_000</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="ident">store</span>.<span class="highlight focus"><span class="ident">engine</span>()</span>, <span class="string">&quot;examples/fuel.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="comment">// Invoke `fibonacci` export with higher and higher numbers until we exhaust our fuel.</span>
  <span class="kw">let</span> <span class="ident">fibonacci</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;fibonacci&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">for</span> <span class="ident">n</span> <span class="kw">in</span> <span class="number">1</span>.. {
    <span class="kw">let</span> <span class="ident">fuel_before</span> <span class="op">=</span> <span class="ident">store</span>.<span class="ident">fuel_consumed</span>().<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">fibonacci</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="ident">n</span>) {
      <span class="prelude-val">Ok</span>(<span class="ident">v</span>) =&gt; <span class="ident">v</span>,
      <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; {
        <span class="macro">println!</span>(<span class="string">&quot;Exhausted fuel computing fib({})&quot;</span>, <span class="ident">n</span>);
        <span class="kw">break</span>;
      }
    };
    <span class="kw">let</span> <span class="ident">fuel_consumed</span> <span class="op">=</span> <span class="ident">store</span>.<span class="ident">fuel_consumed</span>().<span class="ident">unwrap</span>() <span class="op">-</span> <span class="ident">fuel_before</span>;
    <span class="macro">println!</span>(<span class="string">&quot;fib({}) = {} [consumed {} fuel]&quot;</span>, <span class="ident">n</span>, <span class="ident">output</span>, <span class="ident">fuel_consumed</span>);
    <span class="ident">store</span>.<span class="ident">add_fuel</span>(<span class="ident">fuel_consumed</span>)<span class="question-mark">?</span>;
  }
  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><div class="scraped-example " data-locs="[[[12,12],&quot;../../src/serialize/serialize.rs.html#37&quot;,&quot;line 37&quot;]]"><div class="scraped-example-title">examples/serialize.rs (<a href="../../src/serialize/serialize.rs.html#37">line 37</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
<span>57</span>
<span>58</span>
<span>59</span>
<span>60</span>
<span>61</span>
<span>62</span>
<span>63</span>
<span>64</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">deserialize</span>(<span class="ident">buffer</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>]) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Configure the initial compilation environment, creating the global</span>
  <span class="comment">// `Store` structure. Note that you can also tweak configuration settings</span>
  <span class="comment">// with a `Config` and an `Engine` if desired.</span>
  <span class="macro">println!</span>(<span class="string">&quot;Initializing...&quot;</span>);
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span>: <span class="ident">Store</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Store::default</span>();

  <span class="comment">// Compile the wasm binary into an in-memory instance of a `Module`. Note</span>
  <span class="comment">// that this is `unsafe` because it is our responsibility for guaranteeing</span>
  <span class="comment">// that these bytes are valid precompiled module bytes. We know that from</span>
  <span class="comment">// the structure of this example program.</span>
  <span class="macro">println!</span>(<span class="string">&quot;Deserialize module...&quot;</span>);
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">Module::deserialize</span>(<span class="ident">store</span>.<span class="highlight focus"><span class="ident">engine</span>()</span>, <span class="ident">buffer</span>)<span class="question-mark">?</span> };

  <span class="comment">// Here we handle the imports of the module, which in this case is our</span>
  <span class="comment">// `HelloCallback` type and its associated implementation of `Callback.</span>
  <span class="macro">println!</span>(<span class="string">&quot;Creating callback...&quot;</span>);
  <span class="kw">let</span> <span class="ident">hello_func</span> <span class="op">=</span> <span class="ident">Func::wrap</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="op">|</span><span class="op">|</span> {
    <span class="macro">println!</span>(<span class="string">&quot;Calling back...&quot;</span>);
    <span class="macro">println!</span>(<span class="string">&quot;&gt; Hello World!&quot;</span>);
  });

  <span class="comment">// Once we&#39;ve got that all set up we can then move to the instantiation</span>
  <span class="comment">// phase, pairing together a compiled module as well as a set of imports.</span>
  <span class="comment">// Note that this is where the wasm `start` function, if any, would run.</span>
  <span class="macro">println!</span>(<span class="string">&quot;Instantiating module...&quot;</span>);
  <span class="kw">let</span> <span class="ident">imports</span> <span class="op">=</span> [<span class="ident">hello_func</span>.<span class="ident">into</span>()];
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span><span class="ident">imports</span>)<span class="question-mark">?</span>;

  <span class="comment">// Next we poke around a bit to extract the `run` function from the module.</span>
  <span class="macro">println!</span>(<span class="string">&quot;Extracting export...&quot;</span>);
  <span class="kw">let</span> <span class="ident">run</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;run&quot;</span>)<span class="question-mark">?</span>;

  <span class="comment">// And last but not least we can call it!</span>
  <span class="macro">println!</span>(<span class="string">&quot;Calling export...&quot;</span>);
  <span class="ident">run</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Done.&quot;</span>);
  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><div class="scraped-example " data-locs="[[[4,4],&quot;../../src/memory/memory.rs.html#16&quot;,&quot;line 16&quot;]]"><div class="scraped-example-title">examples/memory.rs (<a href="../../src/memory/memory.rs.html#16">line 16</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
<span>57</span>
<span>58</span>
<span>59</span>
<span>60</span>
<span>61</span>
<span>62</span>
<span>63</span>
<span>64</span>
<span>65</span>
<span>66</span>
<span>67</span>
<span>68</span>
<span>69</span>
<span>70</span>
<span>71</span>
<span>72</span>
<span>73</span>
<span>74</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Create our `store_fn` context and then compile a module and create an</span>
  <span class="comment">// instance from the compiled module all in one go.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span>: <span class="ident">Store</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Store::default</span>();
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="ident">store</span>.<span class="highlight focus"><span class="ident">engine</span>()</span>, <span class="string">&quot;examples/memory.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="comment">// load_fn up our exports from the instance</span>
  <span class="kw">let</span> <span class="ident">memory</span> <span class="op">=</span> <span class="ident">instance</span>
    .<span class="ident">get_memory</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;memory&quot;</span>)
    .<span class="ident">ok_or</span>(<span class="macro">anyhow::format_err!</span>(<span class="string">&quot;failed to find `memory` export&quot;</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">size</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;size&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">load_fn</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;load&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">store_fn</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;store&quot;</span>)<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Checking memory...&quot;</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x20000</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0</span>], <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1000</span>], <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">4</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">size</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1000</span>)<span class="question-mark">?</span>, <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1ffff</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">println!</span>(<span class="string">&quot;Mutating memory...&quot;</span>);
  <span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>] <span class="op">=</span> <span class="number">5</span>;

  <span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x1002</span>, <span class="number">6</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">5</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">5</span>);

  <span class="comment">// Grow memory.</span>
  <span class="macro">println!</span>(<span class="string">&quot;Growing memory...&quot;</span>);
  <span class="ident">memory</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>)<span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x30000</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x30000</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x30000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>());

  <span class="macro">assert!</span>(<span class="ident">memory</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>).<span class="ident">is_ok</span>());

  <span class="macro">println!</span>(<span class="string">&quot;Creating stand-alone memory...&quot;</span>);
  <span class="kw">let</span> <span class="ident">memorytype</span> <span class="op">=</span> <span class="ident">MemoryType::new</span>(<span class="number">5</span>, <span class="prelude-val">Some</span>(<span class="number">5</span>));
  <span class="kw">let</span> <span class="ident">memory2</span> <span class="op">=</span> <span class="ident">Memory::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="ident">memorytype</span>)<span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory2</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">5</span>);
  <span class="macro">assert!</span>(<span class="ident">memory2</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory2</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>).<span class="ident">is_ok</span>());

  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><div class="scraped-example " data-locs="[[[10,10],&quot;../../src/multimemory/multimemory.rs.html#22&quot;,&quot;line 22&quot;]]"><div class="scraped-example-title">examples/multimemory.rs (<a href="../../src/multimemory/multimemory.rs.html#22">line 22</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span> 12</span>
<span> 13</span>
<span> 14</span>
<span> 15</span>
<span> 16</span>
<span> 17</span>
<span> 18</span>
<span> 19</span>
<span> 20</span>
<span> 21</span>
<span> 22</span>
<span> 23</span>
<span> 24</span>
<span> 25</span>
<span> 26</span>
<span> 27</span>
<span> 28</span>
<span> 29</span>
<span> 30</span>
<span> 31</span>
<span> 32</span>
<span> 33</span>
<span> 34</span>
<span> 35</span>
<span> 36</span>
<span> 37</span>
<span> 38</span>
<span> 39</span>
<span> 40</span>
<span> 41</span>
<span> 42</span>
<span> 43</span>
<span> 44</span>
<span> 45</span>
<span> 46</span>
<span> 47</span>
<span> 48</span>
<span> 49</span>
<span> 50</span>
<span> 51</span>
<span> 52</span>
<span> 53</span>
<span> 54</span>
<span> 55</span>
<span> 56</span>
<span> 57</span>
<span> 58</span>
<span> 59</span>
<span> 60</span>
<span> 61</span>
<span> 62</span>
<span> 63</span>
<span> 64</span>
<span> 65</span>
<span> 66</span>
<span> 67</span>
<span> 68</span>
<span> 69</span>
<span> 70</span>
<span> 71</span>
<span> 72</span>
<span> 73</span>
<span> 74</span>
<span> 75</span>
<span> 76</span>
<span> 77</span>
<span> 78</span>
<span> 79</span>
<span> 80</span>
<span> 81</span>
<span> 82</span>
<span> 83</span>
<span> 84</span>
<span> 85</span>
<span> 86</span>
<span> 87</span>
<span> 88</span>
<span> 89</span>
<span> 90</span>
<span> 91</span>
<span> 92</span>
<span> 93</span>
<span> 94</span>
<span> 95</span>
<span> 96</span>
<span> 97</span>
<span> 98</span>
<span> 99</span>
<span>100</span>
<span>101</span>
<span>102</span>
<span>103</span>
<span>104</span>
<span>105</span>
<span>106</span>
<span>107</span>
<span>108</span>
<span>109</span>
<span>110</span>
<span>111</span>
<span>112</span>
<span>113</span>
<span>114</span>
<span>115</span>
<span>116</span>
<span>117</span>
<span>118</span>
<span>119</span>
<span>120</span>
<span>121</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Enable the multi-memory feature.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">config</span> <span class="op">=</span> <span class="ident">Config::new</span>();
  <span class="ident">config</span>.<span class="ident">wasm_multi_memory</span>(<span class="bool-val">true</span>);

  <span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>(<span class="kw-2">&amp;</span><span class="ident">config</span>)<span class="question-mark">?</span>;

  <span class="comment">// Create our `store_fn` context and then compile a module and create an</span>
  <span class="comment">// instance from the compiled module all in one go.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ());
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="ident">store</span>.<span class="highlight focus"><span class="ident">engine</span>()</span>, <span class="string">&quot;examples/multimemory.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="kw">let</span> <span class="ident">memory0</span> <span class="op">=</span> <span class="ident">instance</span>
    .<span class="ident">get_memory</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;memory0&quot;</span>)
    .<span class="ident">ok_or</span>(<span class="macro">anyhow::format_err!</span>(<span class="string">&quot;failed to find `memory0` export&quot;</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">size0</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;size0&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">load0</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;load0&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">store0</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;store0&quot;</span>)<span class="question-mark">?</span>;

  <span class="kw">let</span> <span class="ident">memory1</span> <span class="op">=</span> <span class="ident">instance</span>
    .<span class="ident">get_memory</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;memory1&quot;</span>)
    .<span class="ident">ok_or</span>(<span class="macro">anyhow::format_err!</span>(<span class="string">&quot;failed to find `memory1` export&quot;</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">size1</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;size1&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">load1</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;load1&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">store1</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;store1&quot;</span>)<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Checking memory...&quot;</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x20000</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0</span>], <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1000</span>], <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1001</span>], <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">4</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">size0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1000</span>)<span class="question-mark">?</span>, <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1001</span>)<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1ffff</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x20000</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0</span>], <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1000</span>], <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1001</span>], <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">1</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">size1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1000</span>)<span class="question-mark">?</span>, <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1001</span>)<span class="question-mark">?</span>, <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1ffff</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">println!</span>(<span class="string">&quot;Mutating memory...&quot;</span>);
  <span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>] <span class="op">=</span> <span class="number">5</span>;

  <span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x1002</span>, <span class="number">6</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">5</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">5</span>);

  <span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>] <span class="op">=</span> <span class="number">7</span>;

  <span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x1002</span>, <span class="number">8</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">8</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">7</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">8</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">7</span>);

  <span class="macro">println!</span>(<span class="string">&quot;Growing memory...&quot;</span>);
  <span class="ident">memory0</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>)<span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x30000</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x30000</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x30000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>());

  <span class="macro">assert!</span>(<span class="ident">memory0</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory0</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>).<span class="ident">is_ok</span>());

  <span class="ident">memory1</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">2</span>)<span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x40000</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x30000</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x30000</span>, <span class="number">0</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x40000</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x40000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>());

  <span class="macro">assert!</span>(<span class="ident">memory1</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory1</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>).<span class="ident">is_ok</span>());

  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div></div></div></details></div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.interrupt_handle" class="method has-srclink"><div class="rightside"></div><a href="#method.interrupt_handle" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.interrupt_handle" class="fnname">interrupt_handle</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.InterruptHandle.html" title="struct wiggle::wasmtime_crate::InterruptHandle">InterruptHandle</a>, <a class="struct" href="https://docs.rs/anyhow/1.0.40/anyhow/struct.Error.html" title="struct anyhow::Error">Error</a>&gt;</h4></div></summary><div class="docblock"><p>Creates an <a href="struct.InterruptHandle.html" title="InterruptHandle"><code>InterruptHandle</code></a> which can be used to interrupt the
execution of instances within this <code>Store</code>.</p>
<p>An <a href="struct.InterruptHandle.html" title="InterruptHandle"><code>InterruptHandle</code></a> handle is a mechanism of ensuring that guest code
doesn’t execute for too long. For example it’s used to prevent wasm
programs for executing infinitely in infinite loops or recursive call
chains.</p>
<p>The <a href="struct.InterruptHandle.html" title="InterruptHandle"><code>InterruptHandle</code></a> type is sendable to other threads so you can
interact with it even while the thread with this <code>Store</code> is executing
wasm code.</p>
<p>There’s one method on an interrupt handle:
<a href="struct.InterruptHandle.html#method.interrupt" title="InterruptHandle::interrupt"><code>InterruptHandle::interrupt</code></a>. This method is used to generate an
interrupt and cause wasm code to exit “soon”.</p>
<h6 id="when-are-interrupts-delivered" class="section-header"><a href="#when-are-interrupts-delivered">When are interrupts delivered?</a></h6>
<p>The term “interrupt” here refers to one of two different behaviors that
are interrupted in wasm:</p>
<ul>
<li>The head of every loop in wasm has a check to see if it’s interrupted.</li>
<li>The prologue of every function has a check to see if it’s interrupted.</li>
</ul>
<p>This interrupt mechanism makes no attempt to signal interrupts to
native code. For example if a host function is blocked, then sending
an interrupt will not interrupt that operation.</p>
<p>Interrupts are consumed as soon as possible when wasm itself starts
executing. This means that if you interrupt wasm code then it basically
guarantees that the next time wasm is executing on the target thread it
will return quickly (either normally if it were already in the process
of returning or with a trap from the interrupt). Once an interrupt
trap is generated then an interrupt is consumed, and further execution
will not be interrupted (unless another interrupt is set).</p>
<p>When implementing interrupts you’ll want to ensure that the delivery of
interrupts into wasm code is also handled in your host imports and
functionality. Host functions need to either execute for bounded amounts
of time or you’ll need to arrange for them to be interrupted as well.</p>
<h6 id="return-value" class="section-header"><a href="#return-value">Return Value</a></h6>
<p>This function returns a <code>Result</code> since interrupts are not always
enabled. Interrupts are enabled via the
<a href="struct.Config.html#method.interruptable"><code>Config::interruptable</code></a> method, and if
this store’s <a href="struct.Config.html"><code>Config</code></a> hasn’t been configured to enable
interrupts then an error is returned.</p>
<h6 id="examples" class="section-header"><a href="#examples">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Enable interruptable code via `Config` and then create an interrupt</span>
<span class="comment">// handle which we&#39;ll use later to interrupt running code.</span>
<span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>(<span class="ident">Config::new</span>().<span class="ident">interruptable</span>(<span class="bool-val">true</span>))<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ());
<span class="kw">let</span> <span class="ident">interrupt_handle</span> <span class="op">=</span> <span class="ident">store</span>.<span class="ident">interrupt_handle</span>()<span class="question-mark">?</span>;

<span class="comment">// Compile and instantiate a small example with an infinite loop.</span>
<span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, <span class="string">r#&quot;
    (func (export &quot;run&quot;) (loop br 0))
&quot;#</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">run</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;run&quot;</span>)<span class="question-mark">?</span>;

<span class="comment">// Spin up a thread to send us an interrupt in a second</span>
<span class="ident">std::thread::spawn</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span> {
    <span class="ident">std::thread::sleep</span>(<span class="ident">std::time::Duration::from_secs</span>(<span class="number">1</span>));
    <span class="ident">interrupt_handle</span>.<span class="ident">interrupt</span>();
});

<span class="kw">let</span> <span class="ident">trap</span> <span class="op">=</span> <span class="ident">run</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ()).<span class="ident">unwrap_err</span>();
<span class="macro">assert!</span>(<span class="ident">trap</span>.<span class="ident">to_string</span>().<span class="ident">contains</span>(<span class="string">&quot;wasm trap: interrupt&quot;</span>));</code></pre></div>
</div><div class="docblock scraped-example-list"><span></span><h5 id="scraped-examples-2" class="section-header"><a href="#scraped-examples-2">Examples found in repository</a></h5><div class="scraped-example " data-locs="[[[5,5],&quot;../../src/interrupt/interrupt.rs.html#14&quot;,&quot;line 14&quot;]]"><div class="scraped-example-title">examples/interrupt.rs (<a href="../../src/interrupt/interrupt.rs.html#14">line 14</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span> 9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Enable interruptable code via `Config` and then create an interrupt</span>
  <span class="comment">// handle which we&#39;ll use later to interrupt running code.</span>
  <span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>(<span class="ident">Config::new</span>().<span class="ident">interruptable</span>(<span class="bool-val">true</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ());
  <span class="kw">let</span> <span class="ident">interrupt_handle</span> <span class="op">=</span> <span class="ident">store</span>.<span class="highlight focus"><span class="ident">interrupt_handle</span>()</span><span class="question-mark">?</span>;

  <span class="comment">// Compile and instantiate a small example with an infinite loop.</span>
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, <span class="string">&quot;examples/interrupt.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">run</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;run&quot;</span>)<span class="question-mark">?</span>;

  <span class="comment">// Spin up a thread to send us an interrupt in a second</span>
  <span class="ident">std::thread::spawn</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span> {
    <span class="ident">std::thread::sleep</span>(<span class="ident">std::time::Duration::from_secs</span>(<span class="number">1</span>));
    <span class="macro">println!</span>(<span class="string">&quot;Interrupting!&quot;</span>);
    <span class="ident">interrupt_handle</span>.<span class="ident">interrupt</span>();
  });

  <span class="macro">println!</span>(<span class="string">&quot;Entering infinite loop ...&quot;</span>);
  <span class="kw">let</span> <span class="ident">trap</span> <span class="op">=</span> <span class="ident">run</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ()).<span class="ident">unwrap_err</span>();

  <span class="macro">println!</span>(<span class="string">&quot;trap received...&quot;</span>);
  <span class="macro">assert!</span>(<span class="ident">trap</span>.<span class="ident">to_string</span>().<span class="ident">contains</span>(<span class="string">&quot;wasm trap: interrupt&quot;</span>));

  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div></div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.gc" class="method has-srclink"><div class="rightside"></div><a href="#method.gc" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.gc" class="fnname">gc</a>(&amp;mut self)</h4></div></summary><div class="docblock"><p>Perform garbage collection of <code>ExternRef</code>s.</p>
<p>Note that it is not required to actively call this function. GC will
automatically happen when internal buffers fill up. This is provided if
fine-grained control over the GC is desired.</p>
</div><div class="docblock scraped-example-list"><span></span><h5 id="scraped-examples-3" class="section-header"><a href="#scraped-examples-3">Examples found in repository</a></h5><div class="scraped-example " data-locs="[[[45,45],&quot;../../src/externref/externref.rs.html#53&quot;,&quot;line 53&quot;]]"><div class="scraped-example-title">examples/externref.rs (<a href="../../src/externref/externref.rs.html#53">line 53</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span> 8</span>
<span> 9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
<span>57</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="macro">println!</span>(<span class="string">&quot;Initializing...&quot;</span>);
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">config</span> <span class="op">=</span> <span class="ident">Config::new</span>();
  <span class="ident">config</span>.<span class="ident">wasm_reference_types</span>(<span class="bool-val">true</span>);
  <span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>(<span class="kw-2">&amp;</span><span class="ident">config</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ());

  <span class="macro">println!</span>(<span class="string">&quot;Compiling module...&quot;</span>);
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, <span class="string">&quot;examples/externref.wat&quot;</span>)<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Instantiating module...&quot;</span>);
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Creating new `externref`...&quot;</span>);
  <span class="kw">let</span> <span class="ident">externref</span> <span class="op">=</span> <span class="ident">ExternRef::new</span>(<span class="string">&quot;Hello, World!&quot;</span>);
  <span class="macro">assert!</span>(<span class="ident">externref</span>.<span class="ident">data</span>().<span class="ident">is</span>::<span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span><span class="op">&gt;</span>());
  <span class="macro">assert_eq!</span>(
    <span class="kw-2">*</span><span class="ident">externref</span>.<span class="ident">data</span>().<span class="ident">downcast_ref</span>::<span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span><span class="op">&gt;</span>().<span class="ident">unwrap</span>(),
    <span class="string">&quot;Hello, World!&quot;</span>
  );

  <span class="macro">println!</span>(<span class="string">&quot;Touching `externref` table...&quot;</span>);
  <span class="kw">let</span> <span class="ident">table</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_table</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;table&quot;</span>).<span class="ident">unwrap</span>();
  <span class="ident">table</span>.<span class="ident">set</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">3</span>, <span class="prelude-val">Some</span>(<span class="ident">externref</span>.<span class="ident">clone</span>()).<span class="ident">into</span>())<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">elem</span> <span class="op">=</span> <span class="ident">table</span>
    .<span class="ident">get</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">3</span>)
    .<span class="ident">unwrap</span>() <span class="comment">// assert in bounds</span>
    .<span class="ident">unwrap_externref</span>() <span class="comment">// assert it&#39;s an externref table</span>
    .<span class="ident">unwrap</span>(); <span class="comment">// assert the externref isn&#39;t null</span>
  <span class="macro">assert!</span>(<span class="ident">elem</span>.<span class="ident">ptr_eq</span>(<span class="kw-2">&amp;</span><span class="ident">externref</span>));

  <span class="macro">println!</span>(<span class="string">&quot;Touching `externref` global...&quot;</span>);
  <span class="kw">let</span> <span class="ident">global</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_global</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;global&quot;</span>).<span class="ident">unwrap</span>();
  <span class="ident">global</span>.<span class="ident">set</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="prelude-val">Some</span>(<span class="ident">externref</span>.<span class="ident">clone</span>()).<span class="ident">into</span>())<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">global_val</span> <span class="op">=</span> <span class="ident">global</span>.<span class="ident">get</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>).<span class="ident">unwrap_externref</span>().<span class="ident">unwrap</span>();
  <span class="macro">assert!</span>(<span class="ident">global_val</span>.<span class="ident">ptr_eq</span>(<span class="kw-2">&amp;</span><span class="ident">externref</span>));

  <span class="macro">println!</span>(<span class="string">&quot;Calling `externref` func...&quot;</span>);
  <span class="kw">let</span> <span class="ident">func</span> <span class="op">=</span>
    <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">ExternRef</span><span class="op">&gt;</span>, <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">ExternRef</span><span class="op">&gt;</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;func&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">ret</span> <span class="op">=</span> <span class="ident">func</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="prelude-val">Some</span>(<span class="ident">externref</span>.<span class="ident">clone</span>()))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">ret</span>.<span class="ident">is_some</span>());
  <span class="macro">assert!</span>(<span class="ident">ret</span>.<span class="ident">unwrap</span>().<span class="ident">ptr_eq</span>(<span class="kw-2">&amp;</span><span class="ident">externref</span>));

  <span class="macro">println!</span>(<span class="string">&quot;GCing within the store...&quot;</span>);
  <span class="ident">store</span>.<span class="highlight focus"><span class="ident">gc</span>()</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Done.&quot;</span>);
  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div></div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.fuel_consumed" class="method has-srclink"><div class="rightside"></div><a href="#method.fuel_consumed" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.fuel_consumed" class="fnname">fuel_consumed</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>&gt;</h4></div></summary><div class="docblock"><p>Returns the amount of fuel consumed by this store’s execution so far.</p>
<p>If fuel consumption is not enabled via
<a href="struct.Config.html#method.consume_fuel"><code>Config::consume_fuel</code></a> then this
function will return <code>None</code>. Also note that fuel, if enabled, must be
originally configured via <a href="struct.Store.html#method.add_fuel" title="Store::add_fuel"><code>Store::add_fuel</code></a>.</p>
</div><div class="docblock scraped-example-list"><span></span><h5 id="scraped-examples-4" class="section-header"><a href="#scraped-examples-4">Examples found in repository</a></h5><div class="scraped-example " data-locs="[[[12,12],&quot;../../src/fuel/fuel.rs.html#20&quot;,&quot;line 20&quot;],[[20,20],&quot;../../src/fuel/fuel.rs.html#28&quot;,&quot;line 28&quot;]]"><div class="scraped-example-title">examples/fuel.rs (<a href="../../src/fuel/fuel.rs.html#20">line 20</a>)</div><div class="code-wrapper"><span class="prev">&pr;</span> <span class="next">&sc;</span><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span> 8</span>
<span> 9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">config</span> <span class="op">=</span> <span class="ident">Config::new</span>();
  <span class="ident">config</span>.<span class="ident">consume_fuel</span>(<span class="bool-val">true</span>);
  <span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>(<span class="kw-2">&amp;</span><span class="ident">config</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ());
  <span class="ident">store</span>.<span class="ident">add_fuel</span>(<span class="number">10_000</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="ident">store</span>.<span class="ident">engine</span>(), <span class="string">&quot;examples/fuel.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="comment">// Invoke `fibonacci` export with higher and higher numbers until we exhaust our fuel.</span>
  <span class="kw">let</span> <span class="ident">fibonacci</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;fibonacci&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">for</span> <span class="ident">n</span> <span class="kw">in</span> <span class="number">1</span>.. {
    <span class="kw">let</span> <span class="ident">fuel_before</span> <span class="op">=</span> <span class="ident">store</span>.<span class="highlight focus"><span class="ident">fuel_consumed</span>()</span>.<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">fibonacci</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="ident">n</span>) {
      <span class="prelude-val">Ok</span>(<span class="ident">v</span>) =&gt; <span class="ident">v</span>,
      <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; {
        <span class="macro">println!</span>(<span class="string">&quot;Exhausted fuel computing fib({})&quot;</span>, <span class="ident">n</span>);
        <span class="kw">break</span>;
      }
    };
    <span class="kw">let</span> <span class="ident">fuel_consumed</span> <span class="op">=</span> <span class="ident">store</span>.<span class="highlight"><span class="ident">fuel_consumed</span>()</span>.<span class="ident">unwrap</span>() <span class="op">-</span> <span class="ident">fuel_before</span>;
    <span class="macro">println!</span>(<span class="string">&quot;fib({}) = {} [consumed {} fuel]&quot;</span>, <span class="ident">n</span>, <span class="ident">output</span>, <span class="ident">fuel_consumed</span>);
    <span class="ident">store</span>.<span class="ident">add_fuel</span>(<span class="ident">fuel_consumed</span>)<span class="question-mark">?</span>;
  }
  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div></div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.add_fuel" class="method has-srclink"><div class="rightside"></div><a href="#method.add_fuel" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.add_fuel" class="fnname">add_fuel</a>(&amp;mut self, fuel: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://docs.rs/anyhow/1.0.40/anyhow/struct.Error.html" title="struct anyhow::Error">Error</a>&gt;</h4></div></summary><div class="docblock"><p>Adds fuel to this <a href="struct.Store.html" title="Store"><code>Store</code></a> for wasm to consume while executing.</p>
<p>For this method to work fuel consumption must be enabled via
<a href="struct.Config.html#method.consume_fuel"><code>Config::consume_fuel</code></a>. By default a
<a href="struct.Store.html" title="Store"><code>Store</code></a> starts with 0 fuel for wasm to execute with (meaning it will
immediately trap). This function must be called for the store to have
some fuel to allow WebAssembly to execute.</p>
<p>Most WebAssembly instructions consume 1 unit of fuel. Some
instructions, such as <code>nop</code>, <code>drop</code>, <code>block</code>, and <code>loop</code>, consume 0
units, as any execution cost associated with them involves other
instructions which do consume fuel.</p>
<p>Note that at this time when fuel is entirely consumed it will cause
wasm to trap. More usages of fuel are planned for the future.</p>
<h5 id="panics" class="section-header"><a href="#panics">Panics</a></h5>
<p>This function will panic if the store’s <a href="struct.Config.html"><code>Config</code></a> did
not have fuel consumption enabled.</p>
</div><div class="docblock scraped-example-list"><span></span><h5 id="scraped-examples-5" class="section-header"><a href="#scraped-examples-5">Examples found in repository</a></h5><div class="scraped-example " data-locs="[[[5,5],&quot;../../src/fuel/fuel.rs.html#13&quot;,&quot;line 13&quot;],[[22,22],&quot;../../src/fuel/fuel.rs.html#30&quot;,&quot;line 30&quot;]]"><div class="scraped-example-title">examples/fuel.rs (<a href="../../src/fuel/fuel.rs.html#13">line 13</a>)</div><div class="code-wrapper"><span class="prev">&pr;</span> <span class="next">&sc;</span><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span> 8</span>
<span> 9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">config</span> <span class="op">=</span> <span class="ident">Config::new</span>();
  <span class="ident">config</span>.<span class="ident">consume_fuel</span>(<span class="bool-val">true</span>);
  <span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>(<span class="kw-2">&amp;</span><span class="ident">config</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ());
  <span class="ident">store</span>.<span class="highlight focus"><span class="ident">add_fuel</span>(<span class="number">10_000</span>)</span><span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="ident">store</span>.<span class="ident">engine</span>(), <span class="string">&quot;examples/fuel.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="comment">// Invoke `fibonacci` export with higher and higher numbers until we exhaust our fuel.</span>
  <span class="kw">let</span> <span class="ident">fibonacci</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;fibonacci&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">for</span> <span class="ident">n</span> <span class="kw">in</span> <span class="number">1</span>.. {
    <span class="kw">let</span> <span class="ident">fuel_before</span> <span class="op">=</span> <span class="ident">store</span>.<span class="ident">fuel_consumed</span>().<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">fibonacci</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="ident">n</span>) {
      <span class="prelude-val">Ok</span>(<span class="ident">v</span>) =&gt; <span class="ident">v</span>,
      <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; {
        <span class="macro">println!</span>(<span class="string">&quot;Exhausted fuel computing fib({})&quot;</span>, <span class="ident">n</span>);
        <span class="kw">break</span>;
      }
    };
    <span class="kw">let</span> <span class="ident">fuel_consumed</span> <span class="op">=</span> <span class="ident">store</span>.<span class="ident">fuel_consumed</span>().<span class="ident">unwrap</span>() <span class="op">-</span> <span class="ident">fuel_before</span>;
    <span class="macro">println!</span>(<span class="string">&quot;fib({}) = {} [consumed {} fuel]&quot;</span>, <span class="ident">n</span>, <span class="ident">output</span>, <span class="ident">fuel_consumed</span>);
    <span class="ident">store</span>.<span class="highlight"><span class="ident">add_fuel</span>(<span class="ident">fuel_consumed</span>)</span><span class="question-mark">?</span>;
  }
  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div></div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.consume_fuel" class="method has-srclink"><div class="rightside"></div><a href="#method.consume_fuel" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.consume_fuel" class="fnname">consume_fuel</a>(&amp;mut self, fuel: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>, <a class="struct" href="https://docs.rs/anyhow/1.0.40/anyhow/struct.Error.html" title="struct anyhow::Error">Error</a>&gt;</h4></div></summary><div class="docblock"><p>Synthetically consumes fuel from this <a href="struct.Store.html" title="Store"><code>Store</code></a>.</p>
<p>For this method to work fuel consumption must be enabled via
<a href="struct.Config.html#method.consume_fuel"><code>Config::consume_fuel</code></a>.</p>
<p>WebAssembly execution will automatically consume fuel but if so desired
the embedder can also consume fuel manually to account for relative
costs of host functions, for example.</p>
<p>This function will attempt to consume <code>fuel</code> units of fuel from within
this store. If the remaining amount of fuel allows this then <code>Ok(N)</code> is
returned where <code>N</code> is the amount of remaining fuel. Otherwise an error
is returned and no fuel is consumed.</p>
<h5 id="errors" class="section-header"><a href="#errors">Errors</a></h5>
<p>This function will return an either either if fuel consumption via
<a href="struct.Config.html"><code>Config</code></a> is disabled or if <code>fuel</code> exceeds the amount
of remaining fuel within this store.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.out_of_fuel_trap" class="method has-srclink"><div class="rightside"></div><a href="#method.out_of_fuel_trap" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.out_of_fuel_trap" class="fnname">out_of_fuel_trap</a>(&amp;mut self)</h4></div></summary><div class="docblock"><p>Configures a <a href="struct.Store.html" title="Store"><code>Store</code></a> to generate a <a href="struct.Trap.html" title="Trap"><code>Trap</code></a> whenever it runs out of
fuel.</p>
<p>When a <a href="struct.Store.html" title="Store"><code>Store</code></a> is configured to consume fuel with
<a href="struct.Config.html#method.consume_fuel"><code>Config::consume_fuel</code></a> this method will
configure what happens when fuel runs out. Specifically a WebAssembly
trap will be raised and the current execution of WebAssembly will be
aborted.</p>
<p>This is the default behavior for running out of fuel.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.out_of_fuel_async_yield" class="method has-srclink"><div class="rightside"></div><a href="#method.out_of_fuel_async_yield" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.out_of_fuel_async_yield" class="fnname">out_of_fuel_async_yield</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;injection_count: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;fuel_to_inject: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a><br>)</h4></div></summary><div class="docblock"><p>Configures a <a href="struct.Store.html" title="Store"><code>Store</code></a> to yield execution of async WebAssembly code
periodically.</p>
<p>When a <a href="struct.Store.html" title="Store"><code>Store</code></a> is configured to consume fuel with
<a href="struct.Config.html#method.consume_fuel"><code>Config::consume_fuel</code></a> this method will
configure what happens when fuel runs out. Specifically executing
WebAssembly will be suspended and control will be yielded back to the
caller. This is only suitable with use of a store associated with an <a href="struct.Config.html#method.async_support">async
config</a> because only then are futures used and yields
are possible.</p>
<p>The purpose of this behavior is to ensure that futures which represent
execution of WebAssembly do not execute too long inside their
<code>Future::poll</code> method. This allows for some form of cooperative
multitasking where WebAssembly will voluntarily yield control
periodically (based on fuel consumption) back to the running thread.</p>
<p>Note that futures returned by this crate will automatically flag
themselves to get re-polled if a yield happens. This means that
WebAssembly will continue to execute, just after giving the host an
opportunity to do something else.</p>
<p>The <code>fuel_to_inject</code> parameter indicates how much fuel should be
automatically re-injected after fuel runs out. This is how much fuel
will be consumed between yields of an async future.</p>
<p>The <code>injection_count</code> parameter indicates how many times this fuel will
be injected. Multiplying the two parameters is the total amount of fuel
this store is allowed before wasm traps.</p>
<h5 id="panics-1" class="section-header"><a href="#panics-1">Panics</a></h5>
<p>This method will panic if it is not called on a store associated with an <a href="struct.Config.html#method.async_support">async
config</a>.</p>
</div><div class="docblock scraped-example-list"><span></span><h5 id="scraped-examples-6" class="section-header"><a href="#scraped-examples-6">Examples found in repository</a></h5><div class="scraped-example " data-locs="[[[11,11],&quot;../../src/tokio/main.rs.html#99&quot;,&quot;line 99&quot;]]"><div class="scraped-example-title">examples/tokio/main.rs (<a href="../../src/tokio/main.rs.html#99">line 99</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span>88</span>
<span>89</span>
<span>90</span>
<span>91</span>
<span>92</span>
<span>93</span>
<span>94</span>
<span>95</span>
<span>96</span>
<span>97</span>
<span>98</span>
<span>99</span>
<span>100</span>
<span>101</span>
<span>102</span>
<span>103</span>
<span>104</span>
<span>105</span>
<span>106</span>
<span>107</span>
<span>108</span>
<span>109</span>
<span>110</span>
<span>111</span>
<span>112</span>
<span>113</span>
<span>114</span>
</pre><pre class="rust"><code><span class="kw">async</span> <span class="kw">fn</span> <span class="ident">run_wasm</span>(<span class="ident">inputs</span>: <span class="ident">Inputs</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Error</span><span class="op">&gt;</span> {
  <span class="kw">let</span> <span class="ident">wasi</span> <span class="op">=</span> <span class="ident">WasiCtxBuilder::new</span>()
    <span class="comment">// Let wasi print to this process&#39;s stdout.</span>
    .<span class="ident">inherit_stdout</span>()
    <span class="comment">// Set an environment variable so the wasm knows its name.</span>
    .<span class="ident">env</span>(<span class="string">&quot;NAME&quot;</span>, <span class="kw-2">&amp;</span><span class="ident">inputs</span>.<span class="ident">name</span>)<span class="question-mark">?</span>
    .<span class="ident">build</span>();
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">inputs</span>.<span class="ident">env</span>.<span class="ident">engine</span>, <span class="ident">wasi</span>);

  <span class="comment">// WebAssembly execution will be paused for an async yield every time it</span>
  <span class="comment">// consumes 10000 fuel. Fuel will be refilled u64::MAX times.</span>
  <span class="ident">store</span>.<span class="highlight focus"><span class="ident">out_of_fuel_async_yield</span>(<span class="ident">u64::MAX</span>, <span class="number">10000</span>)</span>;

  <span class="comment">// Instantiate into our own unique store using the shared linker, afterwards</span>
  <span class="comment">// acquiring the `_start` function for the module and executing it.</span>
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">inputs</span>
    .<span class="ident">env</span>
    .<span class="ident">linker</span>
    .<span class="ident">instantiate_async</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">inputs</span>.<span class="ident">env</span>.<span class="ident">module</span>)
    .<span class="kw">await</span><span class="question-mark">?</span>;
  <span class="ident">instance</span>
    .<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;_start&quot;</span>)<span class="question-mark">?</span>
    .<span class="ident">call_async</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())
    .<span class="kw">await</span><span class="question-mark">?</span>;

  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div></div></details></div></details><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-AsContext" class="impl has-srclink"><div class="rightside"></div><a href="#impl-AsContext" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="trait.AsContext.html" title="trait wiggle::wasmtime_crate::AsContext">AsContext</a> for <a class="struct" href="struct.Store.html" title="struct wiggle::wasmtime_crate::Store">Store</a>&lt;T&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Data" class="type trait-impl has-srclink"><a href="#associatedtype.Data" class="anchor"></a><h4 class="code-header">type <a href="trait.AsContext.html#associatedtype.Data" class="type">Data</a> = T</h4></div></summary><div class='docblock'><p>The host information associated with the <a href="struct.Store.html" title="Store"><code>Store</code></a>, aka the <code>T</code> in
<a href="struct.Store.html" title="Store&lt;T&gt;"><code>Store&lt;T&gt;</code></a>. <a href="trait.AsContext.html#associatedtype.Data">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_context" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.as_context" class="anchor"></a><h4 class="code-header">pub fn <a href="trait.AsContext.html#tymethod.as_context" class="fnname">as_context</a>(&amp;self) -&gt; <a class="struct" href="struct.StoreContext.html" title="struct wiggle::wasmtime_crate::StoreContext">StoreContext</a>&lt;'_, T&gt;</h4></div></summary><div class='docblock'><p>Returns the store context that this type provides access to.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-AsContextMut" class="impl has-srclink"><div class="rightside"></div><a href="#impl-AsContextMut" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="trait.AsContextMut.html" title="trait wiggle::wasmtime_crate::AsContextMut">AsContextMut</a> for <a class="struct" href="struct.Store.html" title="struct wiggle::wasmtime_crate::Store">Store</a>&lt;T&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_context_mut" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.as_context_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="trait.AsContextMut.html#tymethod.as_context_mut" class="fnname">as_context_mut</a>(&amp;mut self) -&gt; <a class="struct" href="struct.StoreContextMut.html" title="struct wiggle::wasmtime_crate::StoreContextMut">StoreContextMut</a>&lt;'_, T&gt;</h4></div></summary><div class='docblock'><p>Returns the store context that this type provides access to.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Debug" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Debug" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Store.html" title="struct wiggle::wasmtime_crate::Store">Store</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.fmt" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.fmt" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Default" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Default" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="struct.Store.html" title="struct wiggle::wasmtime_crate::Store">Store</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html" title="trait core::default::Default">Default</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.default" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.default" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default" class="fnname">default</a>() -&gt; <a class="struct" href="struct.Store.html" title="struct wiggle::wasmtime_crate::Store">Store</a>&lt;T&gt;</h4></div></summary><div class='docblock'><p>Returns the “default value” for a type. <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Drop" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Drop" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop">Drop</a> for <a class="struct" href="struct.Store.html" title="struct wiggle::wasmtime_crate::Store">Store</a>&lt;T&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.drop" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.drop" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html#tymethod.drop" class="fnname">drop</a>(&amp;mut self)</h4></div></summary><div class='docblock'><p>Executes the destructor for this type. <a href="https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html#tymethod.drop">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-StoreExt" class="impl has-srclink"><div class="rightside"></div><a href="#impl-StoreExt" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="unix/trait.StoreExt.html" title="trait wiggle::wasmtime_crate::unix::StoreExt">StoreExt</a> for <a class="struct" href="struct.Store.html" title="struct wiggle::wasmtime_crate::Store">Store</a>&lt;T&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.set_signal_handler" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.set_signal_handler" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="unix/trait.StoreExt.html#tymethod.set_signal_handler" class="fnname">set_signal_handler</a>&lt;H&gt;(&amp;mut self, handler: H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: 'static + <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*const </a>siginfo_t, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*const </a><a class="enum" href="https://doc.rust-lang.org/nightly/core/ffi/enum.c_void.html" title="enum core::ffi::c_void">c_void</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,&nbsp;</span></h4></div></summary><div class='docblock'><p>The signal handler must be
<a href="http://man7.org/linux/man-pages/man7/signal-safety.7.html">async-signal-safe</a>. <a href="unix/trait.StoreExt.html#tymethod.set_signal_handler">Read more</a></p>
</div></details></div></details></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><div id="impl-RefUnwindSafe" class="impl has-srclink"><div class="rightside"></div><a href="#impl-RefUnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Store.html" title="struct wiggle::wasmtime_crate::Store">Store</a>&lt;T&gt;</h3></div><div id="impl-Send" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Send" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Store.html" title="struct wiggle::wasmtime_crate::Store">Store</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,&nbsp;</span></h3></div><div id="impl-Sync" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Sync" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Store.html" title="struct wiggle::wasmtime_crate::Store">Store</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,&nbsp;</span></h3></div><div id="impl-Unpin" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Unpin" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Store.html" title="struct wiggle::wasmtime_crate::Store">Store</a>&lt;T&gt;</h3></div><div id="impl-UnwindSafe" class="impl has-srclink"><div class="rightside"></div><a href="#impl-UnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Store.html" title="struct wiggle::wasmtime_crate::Store">Store</a>&lt;T&gt;</h3></div></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Any" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#132-136" title="goto source code">[src]</a></div><a href="#impl-Any" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.type_id" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#133" title="goto source code">[src]</a></div><a href="#method.type_id" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></div></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Borrow%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#208-213" title="goto source code">[src]</a></div><a href="#impl-Borrow%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#210" title="goto source code">[src]</a></div><a href="#method.borrow" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</h4></div></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#216-220" title="goto source code">[src]</a></div><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow_mut" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217" title="goto source code">[src]</a></div><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</h4></div></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-From%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#549-553" title="goto source code">[src]</a></div><a href="#impl-From%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#550" title="goto source code">[src]</a></div><a href="#method.from" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Instrument" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://docs.rs/tracing/0.1.26/src/tracing/instrument.rs.html#155" title="goto source code">[src]</a></div><a href="#impl-Instrument" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://docs.rs/tracing/0.1.26/tracing/instrument/trait.Instrument.html" title="trait tracing::instrument::Instrument">Instrument</a> for T</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.instrument" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://docs.rs/tracing/0.1.26/src/tracing/instrument.rs.html#38" title="goto source code">[src]</a></div><a href="#method.instrument" class="anchor"></a><h4 class="code-header">fn <a href="https://docs.rs/tracing/0.1.26/tracing/instrument/trait.Instrument.html#method.instrument" class="fnname">instrument</a>(self, span: <a class="struct" href="https://docs.rs/tracing/0.1.26/tracing/span/struct.Span.html" title="struct tracing::span::Span">Span</a>) -&gt; <a class="struct" href="https://docs.rs/tracing/0.1.26/tracing/instrument/struct.Instrumented.html" title="struct tracing::instrument::Instrumented">Instrumented</a>&lt;Self&gt;</h4></div></summary><div class='docblock'><p>Instruments this type with the provided <code>Span</code>, returning an
<code>Instrumented</code> wrapper. <a href="https://docs.rs/tracing/0.1.26/tracing/instrument/trait.Instrument.html#method.instrument">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.in_current_span" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://docs.rs/tracing/0.1.26/src/tracing/instrument.rs.html#74" title="goto source code">[src]</a></div><a href="#method.in_current_span" class="anchor"></a><h4 class="code-header">fn <a href="https://docs.rs/tracing/0.1.26/tracing/instrument/trait.Instrument.html#method.in_current_span" class="fnname">in_current_span</a>(self) -&gt; <a class="struct" href="https://docs.rs/tracing/0.1.26/tracing/instrument/struct.Instrumented.html" title="struct tracing::instrument::Instrumented">Instrumented</a>&lt;Self&gt;</h4></div></summary><div class='docblock'><p>Instruments this type with the <a href="../struct.Span.html#method.current">current</a> <code>Span</code>, returning an
<code>Instrumented</code> wrapper. <a href="https://docs.rs/tracing/0.1.26/tracing/instrument/trait.Instrument.html#method.in_current_span">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Into%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#537-544" title="goto source code">[src]</a></div><a href="#impl-Into%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.into" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#541" title="goto source code">[src]</a></div><a href="#method.into" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Pointable" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Pointable" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; Pointable for T</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedconstant.ALIGN" class="associatedconstant trait-impl has-srclink"><div class="rightside"></div><a href="#associatedconstant.ALIGN" class="anchor"></a><h4 class="code-header">pub const <a href="#associatedconstant.ALIGN" class="constant">ALIGN</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></div></summary><div class='docblock'><p>The alignment of pointer.</p>
</div></details><details class="rustdoc-toggle" open><summary><div id="associatedtype.Init" class="type trait-impl has-srclink"><a href="#associatedtype.Init" class="anchor"></a><h4 class="code-header">type <a href="#associatedtype.Init" class="type">Init</a> = T</h4></div></summary><div class='docblock'><p>The type for initializers.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.init" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.init" class="anchor"></a><h4 class="code-header">pub unsafe fn <a  class="fnname">init</a>(init: &lt;T as Pointable&gt;::Init) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></div></summary><div class='docblock'><p>Initializes a with the given initializer. <a href="#tymethod.init">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.deref" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.deref" class="anchor"></a><h4 class="code-header">pub unsafe fn <a  class="fnname">deref</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T</h4></div></summary><div class='docblock'><p>Dereferences the given pointer. <a href="#tymethod.deref">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.deref_mut" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.deref_mut" class="anchor"></a><h4 class="code-header">pub unsafe fn <a  class="fnname">deref_mut</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a mut </a>T</h4></div></summary><div class='docblock'><p>Mutably dereferences the given pointer. <a href="#tymethod.deref_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.drop-1" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.drop-1" class="anchor"></a><h4 class="code-header">pub unsafe fn <a  class="fnname">drop</a>(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></div></summary><div class='docblock'><p>Drops the object pointed to by the given pointer. <a href="#tymethod.drop">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Pointee" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/wiggle/lib.rs.html#898-903" title="goto source code">[src]</a></div><a href="#impl-Pointee" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../trait.Pointee.html" title="trait wiggle::Pointee">Pointee</a> for T</h3></div></summary><div class="impl-items"><div id="associatedtype.Pointer" class="type trait-impl has-srclink"><a href="#associatedtype.Pointer" class="anchor"></a><h4 class="code-header">type <a href="../trait.Pointee.html#associatedtype.Pointer" class="type">Pointer</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></h4></div><div id="method.debug" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/wiggle/lib.rs.html#900-902" title="goto source code">[src]</a></div><a href="#method.debug" class="anchor"></a><h4 class="code-header">pub fn <a href="../trait.Pointee.html#tymethod.debug" class="fnname">debug</a>(&lt;T as <a class="trait" href="../trait.Pointee.html" title="trait wiggle::Pointee">Pointee</a>&gt;::<a class="type" href="../trait.Pointee.html#associatedtype.Pointer" title="type wiggle::Pointee::Pointer">Pointer</a>, &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></div></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Same%3CT%3E" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Same%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; Same&lt;T&gt; for T</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Output" class="type trait-impl has-srclink"><a href="#associatedtype.Output" class="anchor"></a><h4 class="code-header">type <a href="#associatedtype.Output" class="type">Output</a> = T</h4></div></summary><div class='docblock'><p>Should always be <code>Self</code></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-TryFrom%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#587-596" title="goto source code">[src]</a></div><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Error" class="type trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.try_from" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#593" title="goto source code">[src]</a></div><a href="#method.try_from" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-TryInto%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#573-582" title="goto source code">[src]</a></div><a href="#impl-TryInto%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Error-1" class="type trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.try_into" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#579" title="goto source code">[src]</a></div><a href="#method.try_into" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-VZip%3CV%3E" class="impl has-srclink"><div class="rightside"></div><a href="#impl-VZip%3CV%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;V, T&gt; VZip&lt;V&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;V: MultiLane&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><div id="method.vzip" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.vzip" class="anchor"></a><h4 class="code-header">pub fn <a  class="fnname">vzip</a>(self) -&gt; V</h4></div></div></details></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="wiggle" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div>
    <script src="../../main.js"></script><script src="../../scrape-examples.js"></script>
</body></html>