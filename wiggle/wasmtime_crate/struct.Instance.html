<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="An instantiated WebAssembly module."><meta name="keywords" content="rust, rustlang, rust-lang, Instance"><title>Instance in wiggle::wasmtime_crate - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../wiggle/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><h2 class="location">Struct Instance</h2><div class="sidebar-elems"><div class="block items"><h3 class="sidebar-title"><a href="#implementations">Associated Constants</a></h3><div class="sidebar-links"><a href="#associatedconstant.ALIGN">ALIGN</a></div><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><div class="sidebar-links"><a href="#method.exports">exports</a><a href="#method.get_export">get_export</a><a href="#method.get_func">get_func</a><a href="#method.get_global">get_global</a><a href="#method.get_memory">get_memory</a><a href="#method.get_table">get_table</a><a href="#method.get_typed_func">get_typed_func</a><a href="#method.new">new</a><a href="#method.new_async">new_async</a><a href="#method.ty">ty</a></div><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><div class="sidebar-links"><a href="#impl-Clone">Clone</a><a href="#impl-Copy">Copy</a><a href="#impl-Debug">Debug</a><a href="#impl-From%3CInstance%3E">From&lt;Instance&gt;</a></div><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><div class="sidebar-links"><a href="#impl-RefUnwindSafe">RefUnwindSafe</a><a href="#impl-Send">Send</a><a href="#impl-Sync">Sync</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">UnwindSafe</a></div><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Instrument">Instrument</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-Pointable">Pointable</a><a href="#impl-Pointee">Pointee</a><a href="#impl-Same%3CT%3E">Same&lt;T&gt;</a><a href="#impl-ToOwned">ToOwned</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a><a href="#impl-VZip%3CV%3E">VZip&lt;V&gt;</a></div></div><h2 class="location">Other items in<br><a href="../index.html">wiggle</a>::<wbr><a href="index.html">wasmtime_crate</a></h2><div id="sidebar-vars" data-name="Instance" data-ty="struct" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Struct <a href="../index.html">wiggle</a>::<wbr><a href="index.html">wasmtime_crate</a>::<wbr><a class="struct" href="#">Instance</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></span></h1><div class="docblock item-decl"><pre class="rust struct"><code><div class="code-attribute">#[repr(transparent)]</div>pub struct Instance(_);</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>An instantiated WebAssembly module.</p>
<p>This type represents the instantiation of a <a href="struct.Module.html" title="Module"><code>Module</code></a>. Once instantiated
you can access the <a href="struct.Instance.html#method.exports"><code>exports</code></a> which are of type
<a href="enum.Extern.html" title="Extern"><code>Extern</code></a> and provide the ability to call functions, set globals, read
memory, etc. When interacting with any wasm code you’ll want to make an
<a href="struct.Instance.html" title="Instance"><code>Instance</code></a> to call any code or execute anything.</p>
<p>Instances are owned by a <a href="struct.Store.html"><code>Store</code></a> which is passed in at
creation time. It’s recommended to create instances with
<a href="struct.Linker.html#method.instantiate"><code>Linker::instantiate</code></a> or similar
<a href="struct.Linker.html"><code>Linker</code></a> methods, but a more low-level constructor is also
available as <a href="struct.Instance.html#method.new" title="Instance::new"><code>Instance::new</code></a>.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl" class="impl has-srclink"><div class="rightside"></div><a href="#impl" class="anchor"></a><h3 class="code-header in-band">impl <a class="struct" href="struct.Instance.html" title="struct wiggle::wasmtime_crate::Instance">Instance</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.new" class="method has-srclink"><div class="rightside"></div><a href="#method.new" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.new" class="fnname">new</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;store: impl <a class="trait" href="trait.AsContextMut.html" title="trait wiggle::wasmtime_crate::AsContextMut">AsContextMut</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;module: &amp;<a class="struct" href="struct.Module.html" title="struct wiggle::wasmtime_crate::Module">Module</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;imports: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="enum" href="enum.Extern.html" title="enum wiggle::wasmtime_crate::Extern">Extern</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Instance.html" title="struct wiggle::wasmtime_crate::Instance">Instance</a>, <a class="struct" href="https://docs.rs/anyhow/1.0.40/anyhow/struct.Error.html" title="struct anyhow::Error">Error</a>&gt;</h4></div></summary><div class="docblock"><p>Creates a new <a href="struct.Instance.html" title="Instance"><code>Instance</code></a> from the previously compiled <a href="struct.Module.html" title="Module"><code>Module</code></a> and
list of <code>imports</code> specified.</p>
<p>This method instantiates the <code>module</code> provided with the <code>imports</code>,
following the procedure in the <a href="https://webassembly.github.io/spec/core/exec/modules.html#exec-instantiation">core specification</a> to
instantiate. Instantiation can fail for a number of reasons (many
specified below), but if successful the <code>start</code> function will be
automatically run (if specified in the <code>module</code>) and then the
<a href="struct.Instance.html" title="Instance"><code>Instance</code></a> will be returned.</p>
<p>Per the WebAssembly spec, instantiation includes running the module’s
start function, if it has one (not to be confused with the <code>_start</code>
function, which is not run).</p>
<p>Note that this is a low-level function that just performs an
instantiation. See the <a href="struct.Linker.html"><code>Linker</code></a> struct for an API which
provides a convenient way to link imports and provides automatic Command
and Reactor behavior.</p>
<h6 id="providing-imports" class="section-header"><a href="#providing-imports">Providing Imports</a></h6>
<p>The entries in the list of <code>imports</code> are intended to correspond 1:1
with the list of imports returned by <a href="struct.Module.html#method.imports" title="Module::imports"><code>Module::imports</code></a>. Before
calling <a href="struct.Instance.html#method.new" title="Instance::new"><code>Instance::new</code></a> you’ll want to inspect the return value of
<a href="struct.Module.html#method.imports" title="Module::imports"><code>Module::imports</code></a> and, for each import type, create an <a href="enum.Extern.html" title="Extern"><code>Extern</code></a>
which corresponds to that type.  These <a href="enum.Extern.html" title="Extern"><code>Extern</code></a> values are all then
collected into a list and passed to this function.</p>
<p>Note that this function is intentionally relatively low level. For an
easier time passing imports by doing name-based resolution it’s
recommended to instead use the <a href="struct.Linker.html"><code>Linker</code></a> type.</p>
<h6 id="errors" class="section-header"><a href="#errors">Errors</a></h6>
<p>This function can fail for a number of reasons, including, but not
limited to:</p>
<ul>
<li>The number of <code>imports</code> provided doesn’t match the number of imports
returned by the <code>module</code>’s <a href="struct.Module.html#method.imports" title="Module::imports"><code>Module::imports</code></a> method.</li>
<li>The type of any <a href="enum.Extern.html" title="Extern"><code>Extern</code></a> doesn’t match the corresponding
<a href="enum.ExternType.html"><code>ExternType</code></a> entry that it maps to.</li>
<li>The <code>start</code> function in the instance, if present, traps.</li>
<li>Module/instance resource limits are exceeded.</li>
</ul>
<p>When instantiation fails it’s recommended to inspect the return value to
see why it failed, or bubble it upwards. If you’d like to specifically
check for trap errors, you can use <code>error.downcast::&lt;Trap&gt;()</code>.</p>
<h5 id="panics" class="section-header"><a href="#panics">Panics</a></h5>
<p>This function will panic if called with a store associated with a
<a href="struct.Config.html#method.async_support"><code>asynchronous config</code></a>. This function
will also panic if any <a href="enum.Extern.html" title="Extern"><code>Extern</code></a> supplied is not owned by <code>store</code>.</p>
</div><div class="docblock scraped-example-list"><span></span><h5 id="scraped-examples" class="section-header"><a href="#scraped-examples">Examples found in repository</a></h5><div class="scraped-example " data-locs="[[[6,6],&quot;../../src/gcd/gcd.rs.html#15&quot;,&quot;line 15&quot;]]"><div class="scraped-example-title">examples/gcd.rs (<a href="../../src/gcd/gcd.rs.html#15">line 15</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span> 9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Load our WebAssembly (parsed WAT in our case), and then load it into a</span>
  <span class="comment">// `Module` which is attached to a `Store` cache. After we&#39;ve got that we</span>
  <span class="comment">// can instantiate it.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store</span>::<span class="op">&lt;</span>()<span class="op">&gt;</span><span class="ident">::default</span>();
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="ident">store</span>.<span class="ident">engine</span>(), <span class="string">&quot;examples/gcd.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="highlight focus"><span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])</span><span class="question-mark">?</span>;

  <span class="comment">// Invoke `gcd` export</span>
  <span class="kw">let</span> <span class="ident">gcd</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;gcd&quot;</span>)<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;gcd(6, 27) = {}&quot;</span>, <span class="ident">gcd</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">6</span>, <span class="number">27</span>))<span class="question-mark">?</span>);
  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><details class="rustdoc-toggle more-examples-toggle"><summary class="hideme"><span>More examples</span></summary><div class="more-scraped-examples"><div class="toggle-line"><div class="toggle-line-inner"></div></div><div class="more-scraped-examples-inner"><div class="scraped-example " data-locs="[[[7,7],&quot;../../src/fib_debug/main.rs.html#21&quot;,&quot;line 21&quot;]]"><div class="scraped-example-title">examples/fib-debug/main.rs (<a href="../../src/fib_debug/main.rs.html#21">line 21</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Load our previously compiled wasm file (built previously with Cargo) and</span>
  <span class="comment">// also ensure that we generate debuginfo so this executable can be</span>
  <span class="comment">// debugged in GDB.</span>
  <span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>(<span class="ident">Config::new</span>().<span class="ident">debug_info</span>(<span class="bool-val">true</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ());
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, <span class="string">&quot;target/wasm32-unknown-unknown/debug/fib.wasm&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="highlight focus"><span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])</span><span class="question-mark">?</span>;

  <span class="comment">// Invoke `fib` export</span>
  <span class="kw">let</span> <span class="ident">fib</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;fib&quot;</span>)<span class="question-mark">?</span>;
  <span class="macro">println!</span>(<span class="string">&quot;fib(6) = {}&quot;</span>, <span class="ident">fib</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">6</span>)<span class="question-mark">?</span>);
  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><div class="scraped-example " data-locs="[[[7,7],&quot;../../src/fuel/fuel.rs.html#15&quot;,&quot;line 15&quot;]]"><div class="scraped-example-title">examples/fuel.rs (<a href="../../src/fuel/fuel.rs.html#15">line 15</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span> 8</span>
<span> 9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">config</span> <span class="op">=</span> <span class="ident">Config::new</span>();
  <span class="ident">config</span>.<span class="ident">consume_fuel</span>(<span class="bool-val">true</span>);
  <span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>(<span class="kw-2">&amp;</span><span class="ident">config</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ());
  <span class="ident">store</span>.<span class="ident">add_fuel</span>(<span class="number">10_000</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="ident">store</span>.<span class="ident">engine</span>(), <span class="string">&quot;examples/fuel.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="highlight focus"><span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])</span><span class="question-mark">?</span>;

  <span class="comment">// Invoke `fibonacci` export with higher and higher numbers until we exhaust our fuel.</span>
  <span class="kw">let</span> <span class="ident">fibonacci</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;fibonacci&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">for</span> <span class="ident">n</span> <span class="kw">in</span> <span class="number">1</span>.. {
    <span class="kw">let</span> <span class="ident">fuel_before</span> <span class="op">=</span> <span class="ident">store</span>.<span class="ident">fuel_consumed</span>().<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">fibonacci</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="ident">n</span>) {
      <span class="prelude-val">Ok</span>(<span class="ident">v</span>) =&gt; <span class="ident">v</span>,
      <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; {
        <span class="macro">println!</span>(<span class="string">&quot;Exhausted fuel computing fib({})&quot;</span>, <span class="ident">n</span>);
        <span class="kw">break</span>;
      }
    };
    <span class="kw">let</span> <span class="ident">fuel_consumed</span> <span class="op">=</span> <span class="ident">store</span>.<span class="ident">fuel_consumed</span>().<span class="ident">unwrap</span>() <span class="op">-</span> <span class="ident">fuel_before</span>;
    <span class="macro">println!</span>(<span class="string">&quot;fib({}) = {} [consumed {} fuel]&quot;</span>, <span class="ident">n</span>, <span class="ident">output</span>, <span class="ident">fuel_consumed</span>);
    <span class="ident">store</span>.<span class="ident">add_fuel</span>(<span class="ident">fuel_consumed</span>)<span class="question-mark">?</span>;
  }
  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><div class="scraped-example " data-locs="[[[9,9],&quot;../../src/interrupt/interrupt.rs.html#18&quot;,&quot;line 18&quot;]]"><div class="scraped-example-title">examples/interrupt.rs (<a href="../../src/interrupt/interrupt.rs.html#18">line 18</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span> 9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Enable interruptable code via `Config` and then create an interrupt</span>
  <span class="comment">// handle which we&#39;ll use later to interrupt running code.</span>
  <span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>(<span class="ident">Config::new</span>().<span class="ident">interruptable</span>(<span class="bool-val">true</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ());
  <span class="kw">let</span> <span class="ident">interrupt_handle</span> <span class="op">=</span> <span class="ident">store</span>.<span class="ident">interrupt_handle</span>()<span class="question-mark">?</span>;

  <span class="comment">// Compile and instantiate a small example with an infinite loop.</span>
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, <span class="string">&quot;examples/interrupt.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="highlight focus"><span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])</span><span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">run</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;run&quot;</span>)<span class="question-mark">?</span>;

  <span class="comment">// Spin up a thread to send us an interrupt in a second</span>
  <span class="ident">std::thread::spawn</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span> {
    <span class="ident">std::thread::sleep</span>(<span class="ident">std::time::Duration::from_secs</span>(<span class="number">1</span>));
    <span class="macro">println!</span>(<span class="string">&quot;Interrupting!&quot;</span>);
    <span class="ident">interrupt_handle</span>.<span class="ident">interrupt</span>();
  });

  <span class="macro">println!</span>(<span class="string">&quot;Entering infinite loop ...&quot;</span>);
  <span class="kw">let</span> <span class="ident">trap</span> <span class="op">=</span> <span class="ident">run</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ()).<span class="ident">unwrap_err</span>();

  <span class="macro">println!</span>(<span class="string">&quot;trap received...&quot;</span>);
  <span class="macro">assert!</span>(<span class="ident">trap</span>.<span class="ident">to_string</span>().<span class="ident">contains</span>(<span class="string">&quot;wasm trap: interrupt&quot;</span>));

  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><div class="scraped-example " data-locs="[[[20,20],&quot;../../src/multi/multi.rs.html#32&quot;,&quot;line 32&quot;]]"><div class="scraped-example-title">examples/multi.rs (<a href="../../src/multi/multi.rs.html#32">line 32</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
<span>57</span>
<span>58</span>
<span>59</span>
<span>60</span>
<span>61</span>
<span>62</span>
<span>63</span>
<span>64</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="kw">use</span> <span class="ident">wasmtime</span>::<span class="kw-2">*</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Initializing...&quot;</span>);
  <span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::default</span>();
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ());

  <span class="comment">// Compile.</span>
  <span class="macro">println!</span>(<span class="string">&quot;Compiling module...&quot;</span>);
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, <span class="string">&quot;examples/multi.wat&quot;</span>)<span class="question-mark">?</span>;

  <span class="comment">// Create a host function which takes multiple parameters and returns</span>
  <span class="comment">// multiple results.</span>
  <span class="macro">println!</span>(<span class="string">&quot;Creating callback...&quot;</span>);
  <span class="kw">let</span> <span class="ident">callback_func</span> <span class="op">=</span> <span class="ident">Func::wrap</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="op">|</span><span class="ident">a</span>: <span class="ident">i32</span>, <span class="ident">b</span>: <span class="ident">i64</span><span class="op">|</span> -&gt; (<span class="ident">i64</span>, <span class="ident">i32</span>) {
    (<span class="ident">b</span> <span class="op">+</span> <span class="number">1</span>, <span class="ident">a</span> <span class="op">+</span> <span class="number">1</span>)
  });

  <span class="comment">// Instantiate.</span>
  <span class="macro">println!</span>(<span class="string">&quot;Instantiating module...&quot;</span>);
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="highlight focus"><span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[<span class="ident">callback_func</span>.<span class="ident">into</span>()])</span><span class="question-mark">?</span>;

  <span class="comment">// Extract exports.</span>
  <span class="macro">println!</span>(<span class="string">&quot;Extracting export...&quot;</span>);
  <span class="kw">let</span> <span class="ident">g</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i64</span>), (<span class="ident">i64</span>, <span class="ident">i32</span>), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;g&quot;</span>)<span class="question-mark">?</span>;

  <span class="comment">// Call `$g`.</span>
  <span class="macro">println!</span>(<span class="string">&quot;Calling export \&quot;g\&quot;...&quot;</span>);
  <span class="kw">let</span> (<span class="ident">a</span>, <span class="ident">b</span>) <span class="op">=</span> <span class="ident">g</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">1</span>, <span class="number">3</span>))<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Printing result...&quot;</span>);
  <span class="macro">println!</span>(<span class="string">&quot;&gt; {} {}&quot;</span>, <span class="ident">a</span>, <span class="ident">b</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">a</span>, <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">b</span>, <span class="number">2</span>);

  <span class="comment">// Call `$round_trip_many`.</span>
  <span class="macro">println!</span>(<span class="string">&quot;Calling export \&quot;round_trip_many\&quot;...&quot;</span>);
  <span class="kw">let</span> <span class="ident">round_trip_many</span> <span class="op">=</span> <span class="ident">instance</span>
        .<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>
        (<span class="ident">i64</span>, <span class="ident">i64</span>, <span class="ident">i64</span>, <span class="ident">i64</span>, <span class="ident">i64</span>, <span class="ident">i64</span>, <span class="ident">i64</span>, <span class="ident">i64</span>, <span class="ident">i64</span>, <span class="ident">i64</span>),
        (<span class="ident">i64</span>, <span class="ident">i64</span>, <span class="ident">i64</span>, <span class="ident">i64</span>, <span class="ident">i64</span>, <span class="ident">i64</span>, <span class="ident">i64</span>, <span class="ident">i64</span>, <span class="ident">i64</span>, <span class="ident">i64</span>),
        <span class="kw">_</span>,
        <span class="op">&gt;</span>
        (<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;round_trip_many&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">results</span> <span class="op">=</span> <span class="ident">round_trip_many</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>))<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Printing result...&quot;</span>);
  <span class="macro">println!</span>(<span class="string">&quot;&gt; {:?}&quot;</span>, <span class="ident">results</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">results</span>, (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>));

  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><div class="scraped-example " data-locs="[[[27,27],&quot;../../src/serialize/serialize.rs.html#52&quot;,&quot;line 52&quot;]]"><div class="scraped-example-title">examples/serialize.rs (<a href="../../src/serialize/serialize.rs.html#52">line 52</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
<span>57</span>
<span>58</span>
<span>59</span>
<span>60</span>
<span>61</span>
<span>62</span>
<span>63</span>
<span>64</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">deserialize</span>(<span class="ident">buffer</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>]) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Configure the initial compilation environment, creating the global</span>
  <span class="comment">// `Store` structure. Note that you can also tweak configuration settings</span>
  <span class="comment">// with a `Config` and an `Engine` if desired.</span>
  <span class="macro">println!</span>(<span class="string">&quot;Initializing...&quot;</span>);
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span>: <span class="ident">Store</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Store::default</span>();

  <span class="comment">// Compile the wasm binary into an in-memory instance of a `Module`. Note</span>
  <span class="comment">// that this is `unsafe` because it is our responsibility for guaranteeing</span>
  <span class="comment">// that these bytes are valid precompiled module bytes. We know that from</span>
  <span class="comment">// the structure of this example program.</span>
  <span class="macro">println!</span>(<span class="string">&quot;Deserialize module...&quot;</span>);
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">Module::deserialize</span>(<span class="ident">store</span>.<span class="ident">engine</span>(), <span class="ident">buffer</span>)<span class="question-mark">?</span> };

  <span class="comment">// Here we handle the imports of the module, which in this case is our</span>
  <span class="comment">// `HelloCallback` type and its associated implementation of `Callback.</span>
  <span class="macro">println!</span>(<span class="string">&quot;Creating callback...&quot;</span>);
  <span class="kw">let</span> <span class="ident">hello_func</span> <span class="op">=</span> <span class="ident">Func::wrap</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="op">|</span><span class="op">|</span> {
    <span class="macro">println!</span>(<span class="string">&quot;Calling back...&quot;</span>);
    <span class="macro">println!</span>(<span class="string">&quot;&gt; Hello World!&quot;</span>);
  });

  <span class="comment">// Once we&#39;ve got that all set up we can then move to the instantiation</span>
  <span class="comment">// phase, pairing together a compiled module as well as a set of imports.</span>
  <span class="comment">// Note that this is where the wasm `start` function, if any, would run.</span>
  <span class="macro">println!</span>(<span class="string">&quot;Instantiating module...&quot;</span>);
  <span class="kw">let</span> <span class="ident">imports</span> <span class="op">=</span> [<span class="ident">hello_func</span>.<span class="ident">into</span>()];
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="highlight focus"><span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span><span class="ident">imports</span>)</span><span class="question-mark">?</span>;

  <span class="comment">// Next we poke around a bit to extract the `run` function from the module.</span>
  <span class="macro">println!</span>(<span class="string">&quot;Extracting export...&quot;</span>);
  <span class="kw">let</span> <span class="ident">run</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;run&quot;</span>)<span class="question-mark">?</span>;

  <span class="comment">// And last but not least we can call it!</span>
  <span class="macro">println!</span>(<span class="string">&quot;Calling export...&quot;</span>);
  <span class="ident">run</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Done.&quot;</span>);
  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><div class="example-links">Additional examples can be found in:<br><ul><li><a href="../../src/externref/externref.rs.html#19">examples/externref.rs</a></li><li><a href="../../src/hello/hello.rs.html#52">examples/hello.rs</a></li><li><a href="../../src/memory/memory.rs.html#17">examples/memory.rs</a></li><li><a href="../../src/multimemory/multimemory.rs.html#23">examples/multimemory.rs</a></li></ul></div></div></div></details></div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.new_async" class="method has-srclink"><div class="rightside"></div><a href="#method.new_async" class="anchor"></a><h4 class="code-header">pub async fn <a href="#method.new_async" class="fnname">new_async</a>&lt;T&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;store: impl <a class="trait" href="trait.AsContextMut.html" title="trait wiggle::wasmtime_crate::AsContextMut">AsContextMut</a>&lt;Data = T&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;module: &amp;'_ <a class="struct" href="struct.Module.html" title="struct wiggle::wasmtime_crate::Module">Module</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;imports: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'_ [</a><a class="enum" href="enum.Extern.html" title="enum wiggle::wasmtime_crate::Extern">Extern</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Instance.html" title="struct wiggle::wasmtime_crate::Instance">Instance</a>, <a class="struct" href="https://docs.rs/anyhow/1.0.40/anyhow/struct.Error.html" title="struct anyhow::Error">Error</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,&nbsp;</span></h4></div></summary><div class="docblock"><p>Same as <a href="struct.Instance.html#method.new" title="Instance::new"><code>Instance::new</code></a>, except for usage in [asynchronous stores].</p>
<p>For more details about this function see the documentation on
<a href="struct.Instance.html#method.new" title="Instance::new"><code>Instance::new</code></a>. The only difference between these two methods is that
this one will asynchronously invoke the wasm start function in case it
calls any imported function which is an asynchronous host function (e.g.
created with <a href="struct.Func.html#method.new_async"><code>Func::new_async</code></a>.</p>
<h5 id="panics-1" class="section-header"><a href="#panics-1">Panics</a></h5>
<p>This function will panic if called with a store associated with a
<a href="struct.Config.html#method.new"><code>synchronous config</code></a>. This is only compatible with
stores associated with an <a href="struct.Config.html#method.async_support"><code>asynchronous config</code></a>.</p>
<p>This function will also panic, like <a href="struct.Instance.html#method.new" title="Instance::new"><code>Instance::new</code></a>, if any <a href="enum.Extern.html" title="Extern"><code>Extern</code></a>
specified does not belong to <code>store</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.ty" class="method has-srclink"><div class="rightside"></div><a href="#method.ty" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.ty" class="fnname">ty</a>(&amp;self, store: impl <a class="trait" href="trait.AsContext.html" title="trait wiggle::wasmtime_crate::AsContext">AsContext</a>) -&gt; <a class="struct" href="struct.InstanceType.html" title="struct wiggle::wasmtime_crate::InstanceType">InstanceType</a></h4></div></summary><div class="docblock"><p>Returns the type signature of this instance.</p>
<h5 id="panics-2" class="section-header"><a href="#panics-2">Panics</a></h5>
<p>Panics if <code>store</code> does not own this instance.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.exports" class="method has-srclink"><div class="rightside"></div><a href="#method.exports" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.exports" class="fnname">exports</a>&lt;'a, T&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a self, <br>&nbsp;&nbsp;&nbsp;&nbsp;store: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.StoreContextMut.html" title="struct wiggle::wasmtime_crate::StoreContextMut">StoreContextMut</a>&lt;'a, T&gt;&gt;<br>) -&gt; impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/exact_size/trait.ExactSizeIterator.html" title="trait core::iter::traits::exact_size::ExactSizeIterator">ExactSizeIterator</a> + 'a <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a,&nbsp;</span></h4></div></summary><div class="docblock"><p>Returns the list of exported items from this <a href="struct.Instance.html" title="Instance"><code>Instance</code></a>.</p>
<h5 id="panics-3" class="section-header"><a href="#panics-3">Panics</a></h5>
<p>Panics if <code>store</code> does not own this instance.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_export" class="method has-srclink"><div class="rightside"></div><a href="#method.get_export" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_export" class="fnname">get_export</a>(&amp;self, store: impl <a class="trait" href="trait.AsContextMut.html" title="trait wiggle::wasmtime_crate::AsContextMut">AsContextMut</a>, name: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="enum.Extern.html" title="enum wiggle::wasmtime_crate::Extern">Extern</a>&gt;</h4></div></summary><div class="docblock"><p>Looks up an exported <a href="enum.Extern.html" title="Extern"><code>Extern</code></a> value by name.</p>
<p>This method will search the module for an export named <code>name</code> and return
the value, if found.</p>
<p>Returns <code>None</code> if there was no export named <code>name</code>.</p>
<h5 id="panics-4" class="section-header"><a href="#panics-4">Panics</a></h5>
<p>Panics if <code>store</code> does not own this instance.</p>
<h5 id="why-does-get_export-take-a-mutable-context" class="section-header"><a href="#why-does-get_export-take-a-mutable-context">Why does <code>get_export</code> take a mutable context?</a></h5>
<p>This method requires a mutable context because an instance’s exports are
lazily populated, and we cache them as they are accessed. This makes
instantiating a module faster, but also means this method requires a
mutable context.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_func" class="method has-srclink"><div class="rightside"></div><a href="#method.get_func" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_func" class="fnname">get_func</a>(&amp;self, store: impl <a class="trait" href="trait.AsContextMut.html" title="trait wiggle::wasmtime_crate::AsContextMut">AsContextMut</a>, name: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Func.html" title="struct wiggle::wasmtime_crate::Func">Func</a>&gt;</h4></div></summary><div class="docblock"><p>Looks up an exported <a href="struct.Func.html" title="Func"><code>Func</code></a> value by name.</p>
<p>Returns <code>None</code> if there was no export named <code>name</code>, or if there was but
it wasn’t a function.</p>
<h5 id="panics-5" class="section-header"><a href="#panics-5">Panics</a></h5>
<p>Panics if <code>store</code> does not own this instance.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_typed_func" class="method has-srclink"><div class="rightside"></div><a href="#method.get_typed_func" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_typed_func" class="fnname">get_typed_func</a>&lt;Params, Results, S&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;store: S, <br>&nbsp;&nbsp;&nbsp;&nbsp;name: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.TypedFunc.html" title="struct wiggle::wasmtime_crate::TypedFunc">TypedFunc</a>&lt;Params, Results&gt;, <a class="struct" href="https://docs.rs/anyhow/1.0.40/anyhow/struct.Error.html" title="struct anyhow::Error">Error</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Params: <a class="trait" href="trait.WasmParams.html" title="trait wiggle::wasmtime_crate::WasmParams">WasmParams</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;Results: <a class="trait" href="trait.WasmResults.html" title="trait wiggle::wasmtime_crate::WasmResults">WasmResults</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="trait.AsContextMut.html" title="trait wiggle::wasmtime_crate::AsContextMut">AsContextMut</a>,&nbsp;</span></h4></div></summary><div class="docblock"><p>Looks up an exported <a href="struct.Func.html" title="Func"><code>Func</code></a> value by name and with its type.</p>
<p>This function is a convenience wrapper over <a href="struct.Instance.html#method.get_func" title="Instance::get_func"><code>Instance::get_func</code></a> and
<a href="struct.Func.html#method.typed" title="Func::typed"><code>Func::typed</code></a>. For more information see the linked documentation.</p>
<p>Returns an error if <code>name</code> isn’t a function export or if the export’s
type did not match <code>Params</code> or <code>Results</code></p>
<h5 id="panics-6" class="section-header"><a href="#panics-6">Panics</a></h5>
<p>Panics if <code>store</code> does not own this instance.</p>
</div><div class="docblock scraped-example-list"><span></span><h5 id="scraped-examples-1" class="section-header"><a href="#scraped-examples-1">Examples found in repository</a></h5><div class="scraped-example " data-locs="[[[9,9],&quot;../../src/gcd/gcd.rs.html#18&quot;,&quot;line 18&quot;]]"><div class="scraped-example-title">examples/gcd.rs (<a href="../../src/gcd/gcd.rs.html#18">line 18</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span> 9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Load our WebAssembly (parsed WAT in our case), and then load it into a</span>
  <span class="comment">// `Module` which is attached to a `Store` cache. After we&#39;ve got that we</span>
  <span class="comment">// can instantiate it.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store</span>::<span class="op">&lt;</span>()<span class="op">&gt;</span><span class="ident">::default</span>();
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="ident">store</span>.<span class="ident">engine</span>(), <span class="string">&quot;examples/gcd.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="comment">// Invoke `gcd` export</span>
  <span class="kw">let</span> <span class="ident">gcd</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="highlight focus"><span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;gcd&quot;</span>)</span><span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;gcd(6, 27) = {}&quot;</span>, <span class="ident">gcd</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">6</span>, <span class="number">27</span>))<span class="question-mark">?</span>);
  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><details class="rustdoc-toggle more-examples-toggle"><summary class="hideme"><span>More examples</span></summary><div class="more-scraped-examples"><div class="toggle-line"><div class="toggle-line-inner"></div></div><div class="more-scraped-examples-inner"><div class="scraped-example " data-locs="[[[10,10],&quot;../../src/fib_debug/main.rs.html#24&quot;,&quot;line 24&quot;]]"><div class="scraped-example-title">examples/fib-debug/main.rs (<a href="../../src/fib_debug/main.rs.html#24">line 24</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Load our previously compiled wasm file (built previously with Cargo) and</span>
  <span class="comment">// also ensure that we generate debuginfo so this executable can be</span>
  <span class="comment">// debugged in GDB.</span>
  <span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>(<span class="ident">Config::new</span>().<span class="ident">debug_info</span>(<span class="bool-val">true</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ());
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, <span class="string">&quot;target/wasm32-unknown-unknown/debug/fib.wasm&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="comment">// Invoke `fib` export</span>
  <span class="kw">let</span> <span class="ident">fib</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="highlight focus"><span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;fib&quot;</span>)</span><span class="question-mark">?</span>;
  <span class="macro">println!</span>(<span class="string">&quot;fib(6) = {}&quot;</span>, <span class="ident">fib</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">6</span>)<span class="question-mark">?</span>);
  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><div class="scraped-example " data-locs="[[[6,6],&quot;../../src/threads/threads.rs.html#55&quot;,&quot;line 55&quot;]]"><div class="scraped-example-title">examples/threads.rs (<a href="../../src/threads/threads.rs.html#55">line 55</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
<span>57</span>
<span>58</span>
<span>59</span>
<span>60</span>
<span>61</span>
<span>62</span>
<span>63</span>
<span>64</span>
<span>65</span>
<span>66</span>
<span>67</span>
<span>68</span>
<span>69</span>
<span>70</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">run</span>(<span class="ident">engine</span>: <span class="kw-2">&amp;</span><span class="ident">Engine</span>, <span class="ident">module</span>: <span class="kw-2">&amp;</span><span class="ident">Module</span>, <span class="ident">linker</span>: <span class="kw-2">&amp;</span><span class="ident">Linker</span><span class="op">&lt;</span>()<span class="op">&gt;</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Each sub-thread we have starting out by instantiating the `module`</span>
  <span class="comment">// provided into a fresh `Store`.</span>
  <span class="macro">println!</span>(<span class="string">&quot;Instantiating module...&quot;</span>);
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ());
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">linker</span>.<span class="ident">instantiate</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="ident">module</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">run</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="highlight focus"><span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;run&quot;</span>)</span><span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Executing...&quot;</span>);
  <span class="kw">for</span> <span class="kw">_</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">N_REPS</span> {
    <span class="ident">run</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>;
    <span class="ident">thread::sleep</span>(<span class="ident">time::Duration::from_millis</span>(<span class="number">100</span>));
  }

  <span class="comment">// Also note that that a `Store` can also move between threads:</span>
  <span class="macro">println!</span>(<span class="string">&quot;&gt; Moving {:?} to a new thread&quot;</span>, <span class="ident">thread::current</span>().<span class="ident">id</span>());
  <span class="kw">let</span> <span class="ident">child</span> <span class="op">=</span> <span class="ident">thread::spawn</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span> <span class="ident">run</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ()));

  <span class="ident">child</span>.<span class="ident">join</span>().<span class="ident">unwrap</span>()<span class="question-mark">?</span>;

  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><div class="scraped-example " data-locs="[[[21,21],&quot;../../src/tokio/main.rs.html#109&quot;,&quot;line 109&quot;]]"><div class="scraped-example-title">examples/tokio/main.rs (<a href="../../src/tokio/main.rs.html#109">line 109</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span>88</span>
<span>89</span>
<span>90</span>
<span>91</span>
<span>92</span>
<span>93</span>
<span>94</span>
<span>95</span>
<span>96</span>
<span>97</span>
<span>98</span>
<span>99</span>
<span>100</span>
<span>101</span>
<span>102</span>
<span>103</span>
<span>104</span>
<span>105</span>
<span>106</span>
<span>107</span>
<span>108</span>
<span>109</span>
<span>110</span>
<span>111</span>
<span>112</span>
<span>113</span>
<span>114</span>
</pre><pre class="rust"><code><span class="kw">async</span> <span class="kw">fn</span> <span class="ident">run_wasm</span>(<span class="ident">inputs</span>: <span class="ident">Inputs</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Error</span><span class="op">&gt;</span> {
  <span class="kw">let</span> <span class="ident">wasi</span> <span class="op">=</span> <span class="ident">WasiCtxBuilder::new</span>()
    <span class="comment">// Let wasi print to this process&#39;s stdout.</span>
    .<span class="ident">inherit_stdout</span>()
    <span class="comment">// Set an environment variable so the wasm knows its name.</span>
    .<span class="ident">env</span>(<span class="string">&quot;NAME&quot;</span>, <span class="kw-2">&amp;</span><span class="ident">inputs</span>.<span class="ident">name</span>)<span class="question-mark">?</span>
    .<span class="ident">build</span>();
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">inputs</span>.<span class="ident">env</span>.<span class="ident">engine</span>, <span class="ident">wasi</span>);

  <span class="comment">// WebAssembly execution will be paused for an async yield every time it</span>
  <span class="comment">// consumes 10000 fuel. Fuel will be refilled u64::MAX times.</span>
  <span class="ident">store</span>.<span class="ident">out_of_fuel_async_yield</span>(<span class="ident">u64::MAX</span>, <span class="number">10000</span>);

  <span class="comment">// Instantiate into our own unique store using the shared linker, afterwards</span>
  <span class="comment">// acquiring the `_start` function for the module and executing it.</span>
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">inputs</span>
    .<span class="ident">env</span>
    .<span class="ident">linker</span>
    .<span class="ident">instantiate_async</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">inputs</span>.<span class="ident">env</span>.<span class="ident">module</span>)
    .<span class="kw">await</span><span class="question-mark">?</span>;
  <span class="ident">instance</span>
    .<span class="highlight focus"><span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;_start&quot;</span>)</span><span class="question-mark">?</span>
    .<span class="ident">call_async</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())
    .<span class="kw">await</span><span class="question-mark">?</span>;

  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><div class="scraped-example " data-locs="[[[10,10],&quot;../../src/fuel/fuel.rs.html#18&quot;,&quot;line 18&quot;]]"><div class="scraped-example-title">examples/fuel.rs (<a href="../../src/fuel/fuel.rs.html#18">line 18</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span> 8</span>
<span> 9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">config</span> <span class="op">=</span> <span class="ident">Config::new</span>();
  <span class="ident">config</span>.<span class="ident">consume_fuel</span>(<span class="bool-val">true</span>);
  <span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>(<span class="kw-2">&amp;</span><span class="ident">config</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ());
  <span class="ident">store</span>.<span class="ident">add_fuel</span>(<span class="number">10_000</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="ident">store</span>.<span class="ident">engine</span>(), <span class="string">&quot;examples/fuel.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="comment">// Invoke `fibonacci` export with higher and higher numbers until we exhaust our fuel.</span>
  <span class="kw">let</span> <span class="ident">fibonacci</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="highlight focus"><span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;fibonacci&quot;</span>)</span><span class="question-mark">?</span>;
  <span class="kw">for</span> <span class="ident">n</span> <span class="kw">in</span> <span class="number">1</span>.. {
    <span class="kw">let</span> <span class="ident">fuel_before</span> <span class="op">=</span> <span class="ident">store</span>.<span class="ident">fuel_consumed</span>().<span class="ident">unwrap</span>();
    <span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">fibonacci</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="ident">n</span>) {
      <span class="prelude-val">Ok</span>(<span class="ident">v</span>) =&gt; <span class="ident">v</span>,
      <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; {
        <span class="macro">println!</span>(<span class="string">&quot;Exhausted fuel computing fib({})&quot;</span>, <span class="ident">n</span>);
        <span class="kw">break</span>;
      }
    };
    <span class="kw">let</span> <span class="ident">fuel_consumed</span> <span class="op">=</span> <span class="ident">store</span>.<span class="ident">fuel_consumed</span>().<span class="ident">unwrap</span>() <span class="op">-</span> <span class="ident">fuel_before</span>;
    <span class="macro">println!</span>(<span class="string">&quot;fib({}) = {} [consumed {} fuel]&quot;</span>, <span class="ident">n</span>, <span class="ident">output</span>, <span class="ident">fuel_consumed</span>);
    <span class="ident">store</span>.<span class="ident">add_fuel</span>(<span class="ident">fuel_consumed</span>)<span class="question-mark">?</span>;
  }
  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><div class="scraped-example " data-locs="[[[10,10],&quot;../../src/interrupt/interrupt.rs.html#19&quot;,&quot;line 19&quot;]]"><div class="scraped-example-title">examples/interrupt.rs (<a href="../../src/interrupt/interrupt.rs.html#19">line 19</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span> 9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Enable interruptable code via `Config` and then create an interrupt</span>
  <span class="comment">// handle which we&#39;ll use later to interrupt running code.</span>
  <span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>(<span class="ident">Config::new</span>().<span class="ident">interruptable</span>(<span class="bool-val">true</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ());
  <span class="kw">let</span> <span class="ident">interrupt_handle</span> <span class="op">=</span> <span class="ident">store</span>.<span class="ident">interrupt_handle</span>()<span class="question-mark">?</span>;

  <span class="comment">// Compile and instantiate a small example with an infinite loop.</span>
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, <span class="string">&quot;examples/interrupt.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">run</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="highlight focus"><span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;run&quot;</span>)</span><span class="question-mark">?</span>;

  <span class="comment">// Spin up a thread to send us an interrupt in a second</span>
  <span class="ident">std::thread::spawn</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span> {
    <span class="ident">std::thread::sleep</span>(<span class="ident">std::time::Duration::from_secs</span>(<span class="number">1</span>));
    <span class="macro">println!</span>(<span class="string">&quot;Interrupting!&quot;</span>);
    <span class="ident">interrupt_handle</span>.<span class="ident">interrupt</span>();
  });

  <span class="macro">println!</span>(<span class="string">&quot;Entering infinite loop ...&quot;</span>);
  <span class="kw">let</span> <span class="ident">trap</span> <span class="op">=</span> <span class="ident">run</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ()).<span class="ident">unwrap_err</span>();

  <span class="macro">println!</span>(<span class="string">&quot;trap received...&quot;</span>);
  <span class="macro">assert!</span>(<span class="ident">trap</span>.<span class="ident">to_string</span>().<span class="ident">contains</span>(<span class="string">&quot;wasm trap: interrupt&quot;</span>));

  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><div class="example-links">Additional examples can be found in:<br><ul><li><a href="../../src/linking/linking.rs.html#35">examples/linking.rs</a></li><li><a href="../../src/multi/multi.rs.html#36">examples/multi.rs</a></li><li><a href="../../src/serialize/serialize.rs.html#56">examples/serialize.rs</a></li><li><a href="../../src/externref/externref.rs.html#47">examples/externref.rs</a></li><li><a href="../../src/hello/hello.rs.html#56">examples/hello.rs</a></li><li><a href="../../src/memory/memory.rs.html#23">examples/memory.rs</a></li><li><a href="../../src/multimemory/multimemory.rs.html#28">examples/multimemory.rs</a></li></ul></div></div></div></details></div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_table" class="method has-srclink"><div class="rightside"></div><a href="#method.get_table" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_table" class="fnname">get_table</a>(&amp;self, store: impl <a class="trait" href="trait.AsContextMut.html" title="trait wiggle::wasmtime_crate::AsContextMut">AsContextMut</a>, name: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Table.html" title="struct wiggle::wasmtime_crate::Table">Table</a>&gt;</h4></div></summary><div class="docblock"><p>Looks up an exported <a href="struct.Table.html" title="Table"><code>Table</code></a> value by name.</p>
<p>Returns <code>None</code> if there was no export named <code>name</code>, or if there was but
it wasn’t a table.</p>
<h5 id="panics-7" class="section-header"><a href="#panics-7">Panics</a></h5>
<p>Panics if <code>store</code> does not own this instance.</p>
</div><div class="docblock scraped-example-list"><span></span><h5 id="scraped-examples-2" class="section-header"><a href="#scraped-examples-2">Examples found in repository</a></h5><div class="scraped-example " data-locs="[[[22,22],&quot;../../src/externref/externref.rs.html#30&quot;,&quot;line 30&quot;]]"><div class="scraped-example-title">examples/externref.rs (<a href="../../src/externref/externref.rs.html#30">line 30</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span> 8</span>
<span> 9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
<span>57</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="macro">println!</span>(<span class="string">&quot;Initializing...&quot;</span>);
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">config</span> <span class="op">=</span> <span class="ident">Config::new</span>();
  <span class="ident">config</span>.<span class="ident">wasm_reference_types</span>(<span class="bool-val">true</span>);
  <span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>(<span class="kw-2">&amp;</span><span class="ident">config</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ());

  <span class="macro">println!</span>(<span class="string">&quot;Compiling module...&quot;</span>);
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, <span class="string">&quot;examples/externref.wat&quot;</span>)<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Instantiating module...&quot;</span>);
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Creating new `externref`...&quot;</span>);
  <span class="kw">let</span> <span class="ident">externref</span> <span class="op">=</span> <span class="ident">ExternRef::new</span>(<span class="string">&quot;Hello, World!&quot;</span>);
  <span class="macro">assert!</span>(<span class="ident">externref</span>.<span class="ident">data</span>().<span class="ident">is</span>::<span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span><span class="op">&gt;</span>());
  <span class="macro">assert_eq!</span>(
    <span class="kw-2">*</span><span class="ident">externref</span>.<span class="ident">data</span>().<span class="ident">downcast_ref</span>::<span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span><span class="op">&gt;</span>().<span class="ident">unwrap</span>(),
    <span class="string">&quot;Hello, World!&quot;</span>
  );

  <span class="macro">println!</span>(<span class="string">&quot;Touching `externref` table...&quot;</span>);
  <span class="kw">let</span> <span class="ident">table</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="highlight focus"><span class="ident">get_table</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;table&quot;</span>)</span>.<span class="ident">unwrap</span>();
  <span class="ident">table</span>.<span class="ident">set</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">3</span>, <span class="prelude-val">Some</span>(<span class="ident">externref</span>.<span class="ident">clone</span>()).<span class="ident">into</span>())<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">elem</span> <span class="op">=</span> <span class="ident">table</span>
    .<span class="ident">get</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">3</span>)
    .<span class="ident">unwrap</span>() <span class="comment">// assert in bounds</span>
    .<span class="ident">unwrap_externref</span>() <span class="comment">// assert it&#39;s an externref table</span>
    .<span class="ident">unwrap</span>(); <span class="comment">// assert the externref isn&#39;t null</span>
  <span class="macro">assert!</span>(<span class="ident">elem</span>.<span class="ident">ptr_eq</span>(<span class="kw-2">&amp;</span><span class="ident">externref</span>));

  <span class="macro">println!</span>(<span class="string">&quot;Touching `externref` global...&quot;</span>);
  <span class="kw">let</span> <span class="ident">global</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_global</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;global&quot;</span>).<span class="ident">unwrap</span>();
  <span class="ident">global</span>.<span class="ident">set</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="prelude-val">Some</span>(<span class="ident">externref</span>.<span class="ident">clone</span>()).<span class="ident">into</span>())<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">global_val</span> <span class="op">=</span> <span class="ident">global</span>.<span class="ident">get</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>).<span class="ident">unwrap_externref</span>().<span class="ident">unwrap</span>();
  <span class="macro">assert!</span>(<span class="ident">global_val</span>.<span class="ident">ptr_eq</span>(<span class="kw-2">&amp;</span><span class="ident">externref</span>));

  <span class="macro">println!</span>(<span class="string">&quot;Calling `externref` func...&quot;</span>);
  <span class="kw">let</span> <span class="ident">func</span> <span class="op">=</span>
    <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">ExternRef</span><span class="op">&gt;</span>, <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">ExternRef</span><span class="op">&gt;</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;func&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">ret</span> <span class="op">=</span> <span class="ident">func</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="prelude-val">Some</span>(<span class="ident">externref</span>.<span class="ident">clone</span>()))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">ret</span>.<span class="ident">is_some</span>());
  <span class="macro">assert!</span>(<span class="ident">ret</span>.<span class="ident">unwrap</span>().<span class="ident">ptr_eq</span>(<span class="kw-2">&amp;</span><span class="ident">externref</span>));

  <span class="macro">println!</span>(<span class="string">&quot;GCing within the store...&quot;</span>);
  <span class="ident">store</span>.<span class="ident">gc</span>();

  <span class="macro">println!</span>(<span class="string">&quot;Done.&quot;</span>);
  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div></div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_memory" class="method has-srclink"><div class="rightside"></div><a href="#method.get_memory" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_memory" class="fnname">get_memory</a>(&amp;self, store: impl <a class="trait" href="trait.AsContextMut.html" title="trait wiggle::wasmtime_crate::AsContextMut">AsContextMut</a>, name: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Memory.html" title="struct wiggle::wasmtime_crate::Memory">Memory</a>&gt;</h4></div></summary><div class="docblock"><p>Looks up an exported <a href="struct.Memory.html" title="Memory"><code>Memory</code></a> value by name.</p>
<p>Returns <code>None</code> if there was no export named <code>name</code>, or if there was but
it wasn’t a memory.</p>
<h5 id="panics-8" class="section-header"><a href="#panics-8">Panics</a></h5>
<p>Panics if <code>store</code> does not own this instance.</p>
</div><div class="docblock scraped-example-list"><span></span><h5 id="scraped-examples-3" class="section-header"><a href="#scraped-examples-3">Examples found in repository</a></h5><div class="scraped-example " data-locs="[[[9,9],&quot;../../src/memory/memory.rs.html#21&quot;,&quot;line 21&quot;]]"><div class="scraped-example-title">examples/memory.rs (<a href="../../src/memory/memory.rs.html#21">line 21</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
<span>57</span>
<span>58</span>
<span>59</span>
<span>60</span>
<span>61</span>
<span>62</span>
<span>63</span>
<span>64</span>
<span>65</span>
<span>66</span>
<span>67</span>
<span>68</span>
<span>69</span>
<span>70</span>
<span>71</span>
<span>72</span>
<span>73</span>
<span>74</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Create our `store_fn` context and then compile a module and create an</span>
  <span class="comment">// instance from the compiled module all in one go.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span>: <span class="ident">Store</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Store::default</span>();
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="ident">store</span>.<span class="ident">engine</span>(), <span class="string">&quot;examples/memory.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="comment">// load_fn up our exports from the instance</span>
  <span class="kw">let</span> <span class="ident">memory</span> <span class="op">=</span> <span class="ident">instance</span>
    .<span class="highlight focus"><span class="ident">get_memory</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;memory&quot;</span>)</span>
    .<span class="ident">ok_or</span>(<span class="macro">anyhow::format_err!</span>(<span class="string">&quot;failed to find `memory` export&quot;</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">size</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;size&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">load_fn</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;load&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">store_fn</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;store&quot;</span>)<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Checking memory...&quot;</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x20000</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0</span>], <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1000</span>], <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">4</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">size</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1000</span>)<span class="question-mark">?</span>, <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1ffff</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">println!</span>(<span class="string">&quot;Mutating memory...&quot;</span>);
  <span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>] <span class="op">=</span> <span class="number">5</span>;

  <span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x1002</span>, <span class="number">6</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">5</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">5</span>);

  <span class="comment">// Grow memory.</span>
  <span class="macro">println!</span>(<span class="string">&quot;Growing memory...&quot;</span>);
  <span class="ident">memory</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>)<span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x30000</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x30000</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x30000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>());

  <span class="macro">assert!</span>(<span class="ident">memory</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>).<span class="ident">is_ok</span>());

  <span class="macro">println!</span>(<span class="string">&quot;Creating stand-alone memory...&quot;</span>);
  <span class="kw">let</span> <span class="ident">memorytype</span> <span class="op">=</span> <span class="ident">MemoryType::new</span>(<span class="number">5</span>, <span class="prelude-val">Some</span>(<span class="number">5</span>));
  <span class="kw">let</span> <span class="ident">memory2</span> <span class="op">=</span> <span class="ident">Memory::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="ident">memorytype</span>)<span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory2</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">5</span>);
  <span class="macro">assert!</span>(<span class="ident">memory2</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory2</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>).<span class="ident">is_ok</span>());

  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><details class="rustdoc-toggle more-examples-toggle"><summary class="hideme"><span>More examples</span></summary><div class="more-scraped-examples"><div class="toggle-line"><div class="toggle-line-inner"></div></div><div class="more-scraped-examples-inner"><div class="scraped-example " data-locs="[[[14,14],&quot;../../src/multimemory/multimemory.rs.html#26&quot;,&quot;line 26&quot;],[[21,21],&quot;../../src/multimemory/multimemory.rs.html#33&quot;,&quot;line 33&quot;]]"><div class="scraped-example-title">examples/multimemory.rs (<a href="../../src/multimemory/multimemory.rs.html#26">line 26</a>)</div><div class="code-wrapper"><span class="prev">&pr;</span> <span class="next">&sc;</span><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span> 12</span>
<span> 13</span>
<span> 14</span>
<span> 15</span>
<span> 16</span>
<span> 17</span>
<span> 18</span>
<span> 19</span>
<span> 20</span>
<span> 21</span>
<span> 22</span>
<span> 23</span>
<span> 24</span>
<span> 25</span>
<span> 26</span>
<span> 27</span>
<span> 28</span>
<span> 29</span>
<span> 30</span>
<span> 31</span>
<span> 32</span>
<span> 33</span>
<span> 34</span>
<span> 35</span>
<span> 36</span>
<span> 37</span>
<span> 38</span>
<span> 39</span>
<span> 40</span>
<span> 41</span>
<span> 42</span>
<span> 43</span>
<span> 44</span>
<span> 45</span>
<span> 46</span>
<span> 47</span>
<span> 48</span>
<span> 49</span>
<span> 50</span>
<span> 51</span>
<span> 52</span>
<span> 53</span>
<span> 54</span>
<span> 55</span>
<span> 56</span>
<span> 57</span>
<span> 58</span>
<span> 59</span>
<span> 60</span>
<span> 61</span>
<span> 62</span>
<span> 63</span>
<span> 64</span>
<span> 65</span>
<span> 66</span>
<span> 67</span>
<span> 68</span>
<span> 69</span>
<span> 70</span>
<span> 71</span>
<span> 72</span>
<span> 73</span>
<span> 74</span>
<span> 75</span>
<span> 76</span>
<span> 77</span>
<span> 78</span>
<span> 79</span>
<span> 80</span>
<span> 81</span>
<span> 82</span>
<span> 83</span>
<span> 84</span>
<span> 85</span>
<span> 86</span>
<span> 87</span>
<span> 88</span>
<span> 89</span>
<span> 90</span>
<span> 91</span>
<span> 92</span>
<span> 93</span>
<span> 94</span>
<span> 95</span>
<span> 96</span>
<span> 97</span>
<span> 98</span>
<span> 99</span>
<span>100</span>
<span>101</span>
<span>102</span>
<span>103</span>
<span>104</span>
<span>105</span>
<span>106</span>
<span>107</span>
<span>108</span>
<span>109</span>
<span>110</span>
<span>111</span>
<span>112</span>
<span>113</span>
<span>114</span>
<span>115</span>
<span>116</span>
<span>117</span>
<span>118</span>
<span>119</span>
<span>120</span>
<span>121</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Enable the multi-memory feature.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">config</span> <span class="op">=</span> <span class="ident">Config::new</span>();
  <span class="ident">config</span>.<span class="ident">wasm_multi_memory</span>(<span class="bool-val">true</span>);

  <span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>(<span class="kw-2">&amp;</span><span class="ident">config</span>)<span class="question-mark">?</span>;

  <span class="comment">// Create our `store_fn` context and then compile a module and create an</span>
  <span class="comment">// instance from the compiled module all in one go.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ());
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="ident">store</span>.<span class="ident">engine</span>(), <span class="string">&quot;examples/multimemory.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="kw">let</span> <span class="ident">memory0</span> <span class="op">=</span> <span class="ident">instance</span>
    .<span class="highlight focus"><span class="ident">get_memory</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;memory0&quot;</span>)</span>
    .<span class="ident">ok_or</span>(<span class="macro">anyhow::format_err!</span>(<span class="string">&quot;failed to find `memory0` export&quot;</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">size0</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;size0&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">load0</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;load0&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">store0</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;store0&quot;</span>)<span class="question-mark">?</span>;

  <span class="kw">let</span> <span class="ident">memory1</span> <span class="op">=</span> <span class="ident">instance</span>
    .<span class="highlight"><span class="ident">get_memory</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;memory1&quot;</span>)</span>
    .<span class="ident">ok_or</span>(<span class="macro">anyhow::format_err!</span>(<span class="string">&quot;failed to find `memory1` export&quot;</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">size1</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;size1&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">load1</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;load1&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">store1</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;store1&quot;</span>)<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Checking memory...&quot;</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x20000</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0</span>], <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1000</span>], <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1001</span>], <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">4</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">size0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1000</span>)<span class="question-mark">?</span>, <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1001</span>)<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1ffff</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x20000</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0</span>], <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1000</span>], <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1001</span>], <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">1</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">size1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1000</span>)<span class="question-mark">?</span>, <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1001</span>)<span class="question-mark">?</span>, <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1ffff</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">println!</span>(<span class="string">&quot;Mutating memory...&quot;</span>);
  <span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>] <span class="op">=</span> <span class="number">5</span>;

  <span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x1002</span>, <span class="number">6</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">5</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">5</span>);

  <span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>] <span class="op">=</span> <span class="number">7</span>;

  <span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x1002</span>, <span class="number">8</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">8</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">7</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">8</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">7</span>);

  <span class="macro">println!</span>(<span class="string">&quot;Growing memory...&quot;</span>);
  <span class="ident">memory0</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>)<span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x30000</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x30000</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x30000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>());

  <span class="macro">assert!</span>(<span class="ident">memory0</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory0</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>).<span class="ident">is_ok</span>());

  <span class="ident">memory1</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">2</span>)<span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x40000</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x30000</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x30000</span>, <span class="number">0</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x40000</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x40000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>());

  <span class="macro">assert!</span>(<span class="ident">memory1</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory1</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>).<span class="ident">is_ok</span>());

  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div></div></div></details></div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_global" class="method has-srclink"><div class="rightside"></div><a href="#method.get_global" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_global" class="fnname">get_global</a>(&amp;self, store: impl <a class="trait" href="trait.AsContextMut.html" title="trait wiggle::wasmtime_crate::AsContextMut">AsContextMut</a>, name: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Global.html" title="struct wiggle::wasmtime_crate::Global">Global</a>&gt;</h4></div></summary><div class="docblock"><p>Looks up an exported <a href="struct.Global.html" title="Global"><code>Global</code></a> value by name.</p>
<p>Returns <code>None</code> if there was no export named <code>name</code>, or if there was but
it wasn’t a global.</p>
<h5 id="panics-9" class="section-header"><a href="#panics-9">Panics</a></h5>
<p>Panics if <code>store</code> does not own this instance.</p>
</div><div class="docblock scraped-example-list"><span></span><h5 id="scraped-examples-4" class="section-header"><a href="#scraped-examples-4">Examples found in repository</a></h5><div class="scraped-example " data-locs="[[[32,32],&quot;../../src/externref/externref.rs.html#40&quot;,&quot;line 40&quot;]]"><div class="scraped-example-title">examples/externref.rs (<a href="../../src/externref/externref.rs.html#40">line 40</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span> 8</span>
<span> 9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
<span>57</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="macro">println!</span>(<span class="string">&quot;Initializing...&quot;</span>);
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">config</span> <span class="op">=</span> <span class="ident">Config::new</span>();
  <span class="ident">config</span>.<span class="ident">wasm_reference_types</span>(<span class="bool-val">true</span>);
  <span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>(<span class="kw-2">&amp;</span><span class="ident">config</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ());

  <span class="macro">println!</span>(<span class="string">&quot;Compiling module...&quot;</span>);
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, <span class="string">&quot;examples/externref.wat&quot;</span>)<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Instantiating module...&quot;</span>);
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Creating new `externref`...&quot;</span>);
  <span class="kw">let</span> <span class="ident">externref</span> <span class="op">=</span> <span class="ident">ExternRef::new</span>(<span class="string">&quot;Hello, World!&quot;</span>);
  <span class="macro">assert!</span>(<span class="ident">externref</span>.<span class="ident">data</span>().<span class="ident">is</span>::<span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span><span class="op">&gt;</span>());
  <span class="macro">assert_eq!</span>(
    <span class="kw-2">*</span><span class="ident">externref</span>.<span class="ident">data</span>().<span class="ident">downcast_ref</span>::<span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span><span class="op">&gt;</span>().<span class="ident">unwrap</span>(),
    <span class="string">&quot;Hello, World!&quot;</span>
  );

  <span class="macro">println!</span>(<span class="string">&quot;Touching `externref` table...&quot;</span>);
  <span class="kw">let</span> <span class="ident">table</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_table</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;table&quot;</span>).<span class="ident">unwrap</span>();
  <span class="ident">table</span>.<span class="ident">set</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">3</span>, <span class="prelude-val">Some</span>(<span class="ident">externref</span>.<span class="ident">clone</span>()).<span class="ident">into</span>())<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">elem</span> <span class="op">=</span> <span class="ident">table</span>
    .<span class="ident">get</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">3</span>)
    .<span class="ident">unwrap</span>() <span class="comment">// assert in bounds</span>
    .<span class="ident">unwrap_externref</span>() <span class="comment">// assert it&#39;s an externref table</span>
    .<span class="ident">unwrap</span>(); <span class="comment">// assert the externref isn&#39;t null</span>
  <span class="macro">assert!</span>(<span class="ident">elem</span>.<span class="ident">ptr_eq</span>(<span class="kw-2">&amp;</span><span class="ident">externref</span>));

  <span class="macro">println!</span>(<span class="string">&quot;Touching `externref` global...&quot;</span>);
  <span class="kw">let</span> <span class="ident">global</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="highlight focus"><span class="ident">get_global</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;global&quot;</span>)</span>.<span class="ident">unwrap</span>();
  <span class="ident">global</span>.<span class="ident">set</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="prelude-val">Some</span>(<span class="ident">externref</span>.<span class="ident">clone</span>()).<span class="ident">into</span>())<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">global_val</span> <span class="op">=</span> <span class="ident">global</span>.<span class="ident">get</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>).<span class="ident">unwrap_externref</span>().<span class="ident">unwrap</span>();
  <span class="macro">assert!</span>(<span class="ident">global_val</span>.<span class="ident">ptr_eq</span>(<span class="kw-2">&amp;</span><span class="ident">externref</span>));

  <span class="macro">println!</span>(<span class="string">&quot;Calling `externref` func...&quot;</span>);
  <span class="kw">let</span> <span class="ident">func</span> <span class="op">=</span>
    <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">ExternRef</span><span class="op">&gt;</span>, <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">ExternRef</span><span class="op">&gt;</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;func&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">ret</span> <span class="op">=</span> <span class="ident">func</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="prelude-val">Some</span>(<span class="ident">externref</span>.<span class="ident">clone</span>()))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">ret</span>.<span class="ident">is_some</span>());
  <span class="macro">assert!</span>(<span class="ident">ret</span>.<span class="ident">unwrap</span>().<span class="ident">ptr_eq</span>(<span class="kw-2">&amp;</span><span class="ident">externref</span>));

  <span class="macro">println!</span>(<span class="string">&quot;GCing within the store...&quot;</span>);
  <span class="ident">store</span>.<span class="ident">gc</span>();

  <span class="macro">println!</span>(<span class="string">&quot;Done.&quot;</span>);
  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div></div></details></div></details><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Clone" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Clone" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Instance.html" title="struct wiggle::wasmtime_crate::Instance">Instance</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.clone" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Instance.html" title="struct wiggle::wasmtime_crate::Instance">Instance</a></h4></div></summary><div class='docblock'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone_from" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#131" title="goto source code">[src]</a></div><a href="#method.clone_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self)</h4></div></summary><div class='docblock'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Debug" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Debug" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Instance.html" title="struct wiggle::wasmtime_crate::Instance">Instance</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.fmt" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.fmt" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-From%3CInstance%3E" class="impl has-srclink"><div class="rightside"></div><a href="#impl-From%3CInstance%3E" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Instance.html" title="struct wiggle::wasmtime_crate::Instance">Instance</a>&gt; for <a class="enum" href="enum.Extern.html" title="enum wiggle::wasmtime_crate::Extern">Extern</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.from" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(r: <a class="struct" href="struct.Instance.html" title="struct wiggle::wasmtime_crate::Instance">Instance</a>) -&gt; <a class="enum" href="enum.Extern.html" title="enum wiggle::wasmtime_crate::Extern">Extern</a></h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><div id="impl-Copy" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Copy" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="struct" href="struct.Instance.html" title="struct wiggle::wasmtime_crate::Instance">Instance</a></h3></div></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><div id="impl-RefUnwindSafe" class="impl has-srclink"><div class="rightside"></div><a href="#impl-RefUnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Instance.html" title="struct wiggle::wasmtime_crate::Instance">Instance</a></h3></div><div id="impl-Send" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Send" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Instance.html" title="struct wiggle::wasmtime_crate::Instance">Instance</a></h3></div><div id="impl-Sync" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Sync" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Instance.html" title="struct wiggle::wasmtime_crate::Instance">Instance</a></h3></div><div id="impl-Unpin" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Unpin" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Instance.html" title="struct wiggle::wasmtime_crate::Instance">Instance</a></h3></div><div id="impl-UnwindSafe" class="impl has-srclink"><div class="rightside"></div><a href="#impl-UnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Instance.html" title="struct wiggle::wasmtime_crate::Instance">Instance</a></h3></div></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Any" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#132-136" title="goto source code">[src]</a></div><a href="#impl-Any" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.type_id" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#133" title="goto source code">[src]</a></div><a href="#method.type_id" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></div></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Borrow%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#208-213" title="goto source code">[src]</a></div><a href="#impl-Borrow%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#210" title="goto source code">[src]</a></div><a href="#method.borrow" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</h4></div></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#216-220" title="goto source code">[src]</a></div><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow_mut" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217" title="goto source code">[src]</a></div><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</h4></div></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-From%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#549-553" title="goto source code">[src]</a></div><a href="#impl-From%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#550" title="goto source code">[src]</a></div><a href="#method.from-1" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Instrument" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://docs.rs/tracing/0.1.26/src/tracing/instrument.rs.html#155" title="goto source code">[src]</a></div><a href="#impl-Instrument" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://docs.rs/tracing/0.1.26/tracing/instrument/trait.Instrument.html" title="trait tracing::instrument::Instrument">Instrument</a> for T</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.instrument" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://docs.rs/tracing/0.1.26/src/tracing/instrument.rs.html#38" title="goto source code">[src]</a></div><a href="#method.instrument" class="anchor"></a><h4 class="code-header">fn <a href="https://docs.rs/tracing/0.1.26/tracing/instrument/trait.Instrument.html#method.instrument" class="fnname">instrument</a>(self, span: <a class="struct" href="https://docs.rs/tracing/0.1.26/tracing/span/struct.Span.html" title="struct tracing::span::Span">Span</a>) -&gt; <a class="struct" href="https://docs.rs/tracing/0.1.26/tracing/instrument/struct.Instrumented.html" title="struct tracing::instrument::Instrumented">Instrumented</a>&lt;Self&gt;</h4></div></summary><div class='docblock'><p>Instruments this type with the provided <code>Span</code>, returning an
<code>Instrumented</code> wrapper. <a href="https://docs.rs/tracing/0.1.26/tracing/instrument/trait.Instrument.html#method.instrument">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.in_current_span" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://docs.rs/tracing/0.1.26/src/tracing/instrument.rs.html#74" title="goto source code">[src]</a></div><a href="#method.in_current_span" class="anchor"></a><h4 class="code-header">fn <a href="https://docs.rs/tracing/0.1.26/tracing/instrument/trait.Instrument.html#method.in_current_span" class="fnname">in_current_span</a>(self) -&gt; <a class="struct" href="https://docs.rs/tracing/0.1.26/tracing/instrument/struct.Instrumented.html" title="struct tracing::instrument::Instrumented">Instrumented</a>&lt;Self&gt;</h4></div></summary><div class='docblock'><p>Instruments this type with the <a href="../struct.Span.html#method.current">current</a> <code>Span</code>, returning an
<code>Instrumented</code> wrapper. <a href="https://docs.rs/tracing/0.1.26/tracing/instrument/trait.Instrument.html#method.in_current_span">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Into%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#537-544" title="goto source code">[src]</a></div><a href="#impl-Into%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.into" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#541" title="goto source code">[src]</a></div><a href="#method.into" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Pointable" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Pointable" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; Pointable for T</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedconstant.ALIGN" class="associatedconstant trait-impl has-srclink"><div class="rightside"></div><a href="#associatedconstant.ALIGN" class="anchor"></a><h4 class="code-header">pub const <a href="#associatedconstant.ALIGN" class="constant">ALIGN</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></div></summary><div class='docblock'><p>The alignment of pointer.</p>
</div></details><details class="rustdoc-toggle" open><summary><div id="associatedtype.Init" class="type trait-impl has-srclink"><a href="#associatedtype.Init" class="anchor"></a><h4 class="code-header">type <a href="#associatedtype.Init" class="type">Init</a> = T</h4></div></summary><div class='docblock'><p>The type for initializers.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.init" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.init" class="anchor"></a><h4 class="code-header">pub unsafe fn <a  class="fnname">init</a>(init: &lt;T as Pointable&gt;::Init) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></div></summary><div class='docblock'><p>Initializes a with the given initializer. <a href="#tymethod.init">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.deref" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.deref" class="anchor"></a><h4 class="code-header">pub unsafe fn <a  class="fnname">deref</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T</h4></div></summary><div class='docblock'><p>Dereferences the given pointer. <a href="#tymethod.deref">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.deref_mut" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.deref_mut" class="anchor"></a><h4 class="code-header">pub unsafe fn <a  class="fnname">deref_mut</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a mut </a>T</h4></div></summary><div class='docblock'><p>Mutably dereferences the given pointer. <a href="#tymethod.deref_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.drop" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.drop" class="anchor"></a><h4 class="code-header">pub unsafe fn <a  class="fnname">drop</a>(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></div></summary><div class='docblock'><p>Drops the object pointed to by the given pointer. <a href="#tymethod.drop">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Pointee" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/wiggle/lib.rs.html#898-903" title="goto source code">[src]</a></div><a href="#impl-Pointee" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../trait.Pointee.html" title="trait wiggle::Pointee">Pointee</a> for T</h3></div></summary><div class="impl-items"><div id="associatedtype.Pointer" class="type trait-impl has-srclink"><a href="#associatedtype.Pointer" class="anchor"></a><h4 class="code-header">type <a href="../trait.Pointee.html#associatedtype.Pointer" class="type">Pointer</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></h4></div><div id="method.debug" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/wiggle/lib.rs.html#900-902" title="goto source code">[src]</a></div><a href="#method.debug" class="anchor"></a><h4 class="code-header">pub fn <a href="../trait.Pointee.html#tymethod.debug" class="fnname">debug</a>(&lt;T as <a class="trait" href="../trait.Pointee.html" title="trait wiggle::Pointee">Pointee</a>&gt;::<a class="type" href="../trait.Pointee.html#associatedtype.Pointer" title="type wiggle::Pointee::Pointer">Pointer</a>, &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></div></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Same%3CT%3E" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Same%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; Same&lt;T&gt; for T</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Output" class="type trait-impl has-srclink"><a href="#associatedtype.Output" class="anchor"></a><h4 class="code-header">type <a href="#associatedtype.Output" class="type">Output</a> = T</h4></div></summary><div class='docblock'><p>Should always be <code>Self</code></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-ToOwned" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#84-96" title="goto source code">[src]</a></div><a href="#impl-ToOwned" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Owned" class="type trait-impl has-srclink"><a href="#associatedtype.Owned" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="type">Owned</a> = T</h4></div></summary><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.to_owned" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#89" title="goto source code">[src]</a></div><a href="#method.to_owned" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4></div></summary><div class='docblock'><p>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone_into" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#93" title="goto source code">[src]</a></div><a href="#method.clone_into" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T)</h4></div></summary><div class="item-info"><div class="stab unstable"><details><summary><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>)</summary><p>recently added</p>
</details></div></div><div class='docblock'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-TryFrom%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#587-596" title="goto source code">[src]</a></div><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Error" class="type trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.try_from" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#593" title="goto source code">[src]</a></div><a href="#method.try_from" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-TryInto%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#573-582" title="goto source code">[src]</a></div><a href="#impl-TryInto%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Error-1" class="type trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.try_into" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#579" title="goto source code">[src]</a></div><a href="#method.try_into" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-VZip%3CV%3E" class="impl has-srclink"><div class="rightside"></div><a href="#impl-VZip%3CV%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;V, T&gt; VZip&lt;V&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;V: MultiLane&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><div id="method.vzip" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.vzip" class="anchor"></a><h4 class="code-header">pub fn <a  class="fnname">vzip</a>(self) -&gt; V</h4></div></div></details></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="wiggle" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div>
    <script src="../../main.js"></script><script src="../../scrape-examples.js"></script>
</body></html>