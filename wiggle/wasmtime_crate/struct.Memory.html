<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A WebAssembly linear memory."><meta name="keywords" content="rust, rustlang, rust-lang, Memory"><title>Memory in wiggle::wasmtime_crate - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../wiggle/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><h2 class="location">Struct Memory</h2><div class="sidebar-elems"><div class="block items"><h3 class="sidebar-title"><a href="#implementations">Associated Constants</a></h3><div class="sidebar-links"><a href="#associatedconstant.ALIGN">ALIGN</a></div><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><div class="sidebar-links"><a href="#method.data">data</a><a href="#method.data_and_store_mut">data_and_store_mut</a><a href="#method.data_mut">data_mut</a><a href="#method.data_ptr">data_ptr</a><a href="#method.data_size">data_size</a><a href="#method.grow">grow</a><a href="#method.grow_async">grow_async</a><a href="#method.new">new</a><a href="#method.new_async">new_async</a><a href="#method.read">read</a><a href="#method.size">size</a><a href="#method.ty">ty</a><a href="#method.write">write</a></div><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><div class="sidebar-links"><a href="#impl-Clone">Clone</a><a href="#impl-Copy">Copy</a><a href="#impl-Debug">Debug</a><a href="#impl-From%3CMemory%3E">From&lt;Memory&gt;</a></div><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><div class="sidebar-links"><a href="#impl-RefUnwindSafe">RefUnwindSafe</a><a href="#impl-Send">Send</a><a href="#impl-Sync">Sync</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">UnwindSafe</a></div><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Instrument">Instrument</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-Pointable">Pointable</a><a href="#impl-Pointee">Pointee</a><a href="#impl-Same%3CT%3E">Same&lt;T&gt;</a><a href="#impl-ToOwned">ToOwned</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a><a href="#impl-VZip%3CV%3E">VZip&lt;V&gt;</a></div></div><h2 class="location">Other items in<br><a href="../index.html">wiggle</a>::<wbr><a href="index.html">wasmtime_crate</a></h2><div id="sidebar-vars" data-name="Memory" data-ty="struct" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Struct <a href="../index.html">wiggle</a>::<wbr><a href="index.html">wasmtime_crate</a>::<wbr><a class="struct" href="#">Memory</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></span></h1><div class="docblock item-decl"><pre class="rust struct"><code><div class="code-attribute">#[repr(transparent)]</div>pub struct Memory(_);</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A WebAssembly linear memory.</p>
<p>WebAssembly memories represent a contiguous array of bytes that have a size
that is always a multiple of the WebAssembly page size, currently 64
kilobytes.</p>
<p>WebAssembly memory is used for global data (not to be confused with wasm
<code>global</code> items), statics in C/C++/Rust, shadow stack memory, etc. Accessing
wasm memory is generally quite fast.</p>
<p>Memories, like other wasm items, are owned by a <a href="struct.Store.html"><code>Store</code></a>.</p>
<h2 id="memory-and-safety" class="section-header"><a href="#memory-and-safety"><code>Memory</code> and Safety</a></h2>
<p>Linear memory is a lynchpin of safety for WebAssembly. In Wasmtime there are
safe methods of interacting with a <a href="struct.Memory.html" title="Memory"><code>Memory</code></a>:</p>
<ul>
<li><a href="struct.Memory.html#method.read" title="Memory::read"><code>Memory::read</code></a></li>
<li><a href="struct.Memory.html#method.write" title="Memory::write"><code>Memory::write</code></a></li>
<li><a href="struct.Memory.html#method.data" title="Memory::data"><code>Memory::data</code></a></li>
<li><a href="struct.Memory.html#method.data_mut" title="Memory::data_mut"><code>Memory::data_mut</code></a></li>
</ul>
<p>Note that all of these consider the entire store context as borrowed for the
duration of the call or the duration of the returned slice. This largely
means that while the function is running you’ll be unable to borrow anything
else from the store. This includes getting access to the <code>T</code> on
<a href="struct.Store.html"><code>Store&lt;T&gt;</code></a>, but it also means that you can’t recursively
call into WebAssembly for instance.</p>
<p>If you’d like to dip your toes into handling <a href="struct.Memory.html" title="Memory"><code>Memory</code></a> in a more raw
fashion (e.g. by using raw pointers or raw slices), then there’s a few
important points to consider when doing so:</p>
<ul>
<li>
<p>Any recursive calls into WebAssembly can possibly modify any byte of the
entire memory. This means that whenever wasm is called Rust can’t have any
long-lived borrows live across the wasm function call. Slices like <code>&amp;mut [u8]</code> will be violated because they’re not actually exclusive at that
point, and slices like <code>&amp;[u8]</code> are also violated because their contents
may be mutated.</p>
</li>
<li>
<p>WebAssembly memories can grow, and growth may change the base pointer.
This means that even holding a raw pointer to memory over a wasm function
call is also incorrect. Anywhere in the function call the base address of
memory may change. Note that growth can also be requested from the
embedding API as well.</p>
</li>
</ul>
<p>As a general rule of thumb it’s recommended to stick to the safe methods of
<a href="struct.Memory.html" title="Memory"><code>Memory</code></a> if you can. It’s not advised to use raw pointers or <code>unsafe</code>
operations because of how easy it is to accidentally get things wrong.</p>
<p>Some examples of safely interacting with memory are:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">wasmtime</span>::{<span class="ident">Memory</span>, <span class="ident">Store</span>, <span class="ident">MemoryAccessError</span>};

<span class="comment">// Memory can be read and written safely with the `Memory::read` and</span>
<span class="comment">// `Memory::write` methods.</span>
<span class="comment">// An error is returned if the copy did not succeed.</span>
<span class="kw">fn</span> <span class="ident">safe_examples</span>(<span class="ident">mem</span>: <span class="ident">Memory</span>, <span class="ident">store</span>: <span class="kw-2">&amp;mut</span> <span class="ident">Store</span><span class="op">&lt;</span>()<span class="op">&gt;</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">MemoryAccessError</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">offset</span> <span class="op">=</span> <span class="number">5</span>;
    <span class="ident">mem</span>.<span class="ident">write</span>(<span class="kw-2">&amp;mut</span> <span class="kw-2">*</span><span class="ident">store</span>, <span class="ident">offset</span>, <span class="string">b&quot;hello&quot;</span>)<span class="question-mark">?</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buffer</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">5</span>];
    <span class="ident">mem</span>.<span class="ident">read</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>, <span class="ident">offset</span>, <span class="kw-2">&amp;mut</span> <span class="ident">buffer</span>)<span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(<span class="string">b&quot;hello&quot;</span>, <span class="kw-2">&amp;</span><span class="ident">buffer</span>);

    <span class="comment">// Note that while this is safe care must be taken because the indexing</span>
    <span class="comment">// here may panic if the memory isn&#39;t large enough.</span>
    <span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="ident">mem</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="ident">offset</span>..<span class="ident">offset</span> <span class="op">+</span> <span class="number">5</span>], <span class="string">b&quot;hello&quot;</span>);
    <span class="ident">mem</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="kw-2">*</span><span class="ident">store</span>)[<span class="ident">offset</span>..<span class="ident">offset</span> <span class="op">+</span> <span class="number">5</span>].<span class="ident">copy_from_slice</span>(<span class="string">b&quot;bye!!&quot;</span>);

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>It’s worth also, however, covering some examples of <strong>incorrect</strong>,
<strong>unsafe</strong> usages of <code>Memory</code>. Do not do these things!</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">wasmtime</span>::{<span class="ident">Memory</span>, <span class="ident">Store</span>};

<span class="comment">// NOTE: All code in this function is not safe to execute and may cause</span>
<span class="comment">// segfaults/undefined behavior at runtime. Do not copy/paste these examples</span>
<span class="comment">// into production code!</span>
<span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">unsafe_examples</span>(<span class="ident">mem</span>: <span class="ident">Memory</span>, <span class="ident">store</span>: <span class="kw-2">&amp;mut</span> <span class="ident">Store</span><span class="op">&lt;</span>()<span class="op">&gt;</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="comment">// First and foremost, any borrow can be invalidated at any time via the</span>
    <span class="comment">// `Memory::grow` function. This can relocate memory which causes any</span>
    <span class="comment">// previous pointer to be possibly invalid now.</span>
    <span class="kw">let</span> <span class="ident">pointer</span>: <span class="kw-2">&amp;</span><span class="ident">u8</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">mem</span>.<span class="ident">data_ptr</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>);
    <span class="ident">mem</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="kw-2">*</span><span class="ident">store</span>, <span class="number">1</span>)<span class="question-mark">?</span>; <span class="comment">// invalidates `pointer`!</span>
    <span class="comment">// println!(&quot;{}&quot;, *pointer); // FATAL: use-after-free</span>

    <span class="comment">// Note that the use-after-free also applies to slices, whether they&#39;re</span>
    <span class="comment">// slices of bytes or strings.</span>
    <span class="kw">let</span> <span class="ident">mem_slice</span> <span class="op">=</span> <span class="ident">std::slice::from_raw_parts</span>(
        <span class="ident">mem</span>.<span class="ident">data_ptr</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>),
        <span class="ident">mem</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>),
    );
    <span class="kw">let</span> <span class="ident">slice</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">mem_slice</span>[<span class="number">0x100</span>..<span class="number">0x102</span>];
    <span class="ident">mem</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="kw-2">*</span><span class="ident">store</span>, <span class="number">1</span>)<span class="question-mark">?</span>; <span class="comment">// invalidates `slice`!</span>
    <span class="comment">// println!(&quot;{:?}&quot;, slice); // FATAL: use-after-free</span>

    <span class="comment">// The `Memory` type may be stored in other locations, so if you hand</span>
    <span class="comment">// off access to the `Store` then those locations may also call</span>
    <span class="comment">// `Memory::grow` or similar, so it&#39;s not enough to just audit code for</span>
    <span class="comment">// calls to `Memory::grow`.</span>
    <span class="kw">let</span> <span class="ident">pointer</span>: <span class="kw-2">&amp;</span><span class="ident">u8</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">mem</span>.<span class="ident">data_ptr</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>);
    <span class="ident">some_other_function</span>(<span class="ident">store</span>); <span class="comment">// may invalidate `pointer` through use of `store`</span>
    <span class="comment">// println!(&quot;{:?}&quot;, pointer); // FATAL: maybe a use-after-free</span>

    <span class="comment">// An especially subtle aspect of accessing a wasm instance&#39;s memory is</span>
    <span class="comment">// that you need to be extremely careful about aliasing. Anyone at any</span>
    <span class="comment">// time can call `data_unchecked()` or `data_unchecked_mut()`, which</span>
    <span class="comment">// means you can easily have aliasing mutable references:</span>
    <span class="kw">let</span> <span class="ident">ref1</span>: <span class="kw-2">&amp;</span><span class="ident">u8</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">mem</span>.<span class="ident">data_ptr</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>).<span class="ident">add</span>(<span class="number">0x100</span>);
    <span class="kw">let</span> <span class="ident">ref2</span>: <span class="kw-2">&amp;mut</span> <span class="ident">u8</span> <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="kw-2">*</span><span class="ident">mem</span>.<span class="ident">data_ptr</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>).<span class="ident">add</span>(<span class="number">0x100</span>);
    <span class="comment">// *ref2 = *ref1; // FATAL: violates Rust&#39;s aliasing rules</span>

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>Overall there’s some general rules of thumb when unsafely working with
<code>Memory</code> and getting raw pointers inside of it:</p>
<ul>
<li>If you never have a “long lived” pointer into memory, you’re likely in the
clear. Care still needs to be taken in threaded scenarios or when/where
data is read, but you’ll be shielded from many classes of issues.</li>
<li>Long-lived pointers must always respect Rust’a aliasing rules. It’s ok for
shared borrows to overlap with each other, but mutable borrows must
overlap with nothing.</li>
<li>Long-lived pointers are only valid if they’re not invalidated for their
lifetime. This means that <a href="struct.Store.html"><code>Store</code></a> isn’t used to reenter
wasm or the memory itself is never grown or otherwise modified/aliased.</li>
</ul>
<p>At this point it’s worth reiterating again that unsafely working with
<code>Memory</code> is pretty tricky and not recommended! It’s highly recommended to
use the safe methods to interact with <a href="struct.Memory.html" title="Memory"><code>Memory</code></a> whenever possible.</p>
<h3 id="memory-safety-and-threads" class="section-header"><a href="#memory-safety-and-threads"><code>Memory</code> Safety and Threads</a></h3>
<p>Currently the <code>wasmtime</code> crate does not implement the wasm threads proposal,
but it is planned to do so. It may be interesting to readers to see how this
affects memory safety and what was previously just discussed as well.</p>
<p>Once threads are added into the mix, all of the above rules still apply.
There’s an additional consideration that all reads and writes can happen
concurrently, though. This effectively means that any borrow into wasm
memory are virtually never safe to have.</p>
<p>Mutable pointers are fundamentally unsafe to have in a concurrent scenario
in the face of arbitrary wasm code. Only if you dynamically know for sure
that wasm won’t access a region would it be safe to construct a mutable
pointer. Additionally even shared pointers are largely unsafe because their
underlying contents may change, so unless <code>UnsafeCell</code> in one form or
another is used everywhere there’s no safety.</p>
<p>One important point about concurrency is that while <a href="struct.Memory.html#method.grow" title="Memory::grow"><code>Memory::grow</code></a> can
happen concurrently it will never relocate the base pointer. Shared
memories must always have a maximum size and they will be preallocated such
that growth will never relocate the base pointer. The current size of the
memory may still change over time though.</p>
<p>Overall the general rule of thumb for shared memories is that you must
atomically read and write everything. Nothing can be borrowed and everything
must be eagerly copied out. This means that <a href="struct.Memory.html#method.data" title="Memory::data"><code>Memory::data</code></a> and
<a href="struct.Memory.html#method.data_mut" title="Memory::data_mut"><code>Memory::data_mut</code></a> won’t work in the future (they’ll probably return an
error) for shared memories when they’re implemented. When possible it’s
recommended to use <a href="struct.Memory.html#method.read" title="Memory::read"><code>Memory::read</code></a> and <a href="struct.Memory.html#method.write" title="Memory::write"><code>Memory::write</code></a> which will still
be provided.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl" class="impl has-srclink"><div class="rightside"></div><a href="#impl" class="anchor"></a><h3 class="code-header in-band">impl <a class="struct" href="struct.Memory.html" title="struct wiggle::wasmtime_crate::Memory">Memory</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.new" class="method has-srclink"><div class="rightside"></div><a href="#method.new" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.new" class="fnname">new</a>(store: impl <a class="trait" href="trait.AsContextMut.html" title="trait wiggle::wasmtime_crate::AsContextMut">AsContextMut</a>, ty: <a class="struct" href="struct.MemoryType.html" title="struct wiggle::wasmtime_crate::MemoryType">MemoryType</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Memory.html" title="struct wiggle::wasmtime_crate::Memory">Memory</a>, <a class="struct" href="https://docs.rs/anyhow/1.0.40/anyhow/struct.Error.html" title="struct anyhow::Error">Error</a>&gt;</h4></div></summary><div class="docblock"><p>Creates a new WebAssembly memory given the configuration of <code>ty</code>.</p>
<p>The <code>store</code> argument will be the owner of the returned <a href="struct.Memory.html" title="Memory"><code>Memory</code></a>. All
WebAssembly memory is initialized to zero.</p>
<h5 id="panics" class="section-header"><a href="#panics">Panics</a></h5>
<p>This function will panic if the <a href="struct.Store.html"><code>Store</code></a> has a
<a href="trait.ResourceLimiterAsync.html"><code>ResourceLimiterAsync</code></a> (see also:
<a href="struct.Store.html#method.limiter_async"><code>Store::limiter_async</code></a>). When
using an async resource limiter, use <a href="struct.Memory.html#method.new_async" title="Memory::new_async"><code>Memory::new_async</code></a> instead.</p>
<h5 id="examples" class="section-header"><a href="#examples">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::default</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ());

<span class="kw">let</span> <span class="ident">memory_ty</span> <span class="op">=</span> <span class="ident">MemoryType::new</span>(<span class="number">1</span>, <span class="prelude-val">None</span>);
<span class="kw">let</span> <span class="ident">memory</span> <span class="op">=</span> <span class="ident">Memory::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="ident">memory_ty</span>)<span class="question-mark">?</span>;

<span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, <span class="string">&quot;(module (memory (import \&quot;\&quot; \&quot;\&quot;) 1))&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[<span class="ident">memory</span>.<span class="ident">into</span>()])<span class="question-mark">?</span>;
<span class="comment">// ...</span></code></pre></div>
</div><div class="docblock scraped-example-list"><span></span><h5 id="scraped-examples" class="section-header"><a href="#scraped-examples">Examples found in repository</a></h5><div class="scraped-example " data-locs="[[[56,56],&quot;../../src/memory/memory.rs.html#68&quot;,&quot;line 68&quot;]]"><div class="scraped-example-title">examples/memory.rs (<a href="../../src/memory/memory.rs.html#68">line 68</a>)</div><div class="code-wrapper"><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
<span>57</span>
<span>58</span>
<span>59</span>
<span>60</span>
<span>61</span>
<span>62</span>
<span>63</span>
<span>64</span>
<span>65</span>
<span>66</span>
<span>67</span>
<span>68</span>
<span>69</span>
<span>70</span>
<span>71</span>
<span>72</span>
<span>73</span>
<span>74</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Create our `store_fn` context and then compile a module and create an</span>
  <span class="comment">// instance from the compiled module all in one go.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span>: <span class="ident">Store</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Store::default</span>();
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="ident">store</span>.<span class="ident">engine</span>(), <span class="string">&quot;examples/memory.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="comment">// load_fn up our exports from the instance</span>
  <span class="kw">let</span> <span class="ident">memory</span> <span class="op">=</span> <span class="ident">instance</span>
    .<span class="ident">get_memory</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;memory&quot;</span>)
    .<span class="ident">ok_or</span>(<span class="macro">anyhow::format_err!</span>(<span class="string">&quot;failed to find `memory` export&quot;</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">size</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;size&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">load_fn</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;load&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">store_fn</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;store&quot;</span>)<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Checking memory...&quot;</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x20000</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0</span>], <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1000</span>], <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">4</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">size</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1000</span>)<span class="question-mark">?</span>, <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1ffff</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">println!</span>(<span class="string">&quot;Mutating memory...&quot;</span>);
  <span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>] <span class="op">=</span> <span class="number">5</span>;

  <span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x1002</span>, <span class="number">6</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">5</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">5</span>);

  <span class="comment">// Grow memory.</span>
  <span class="macro">println!</span>(<span class="string">&quot;Growing memory...&quot;</span>);
  <span class="ident">memory</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>)<span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x30000</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x30000</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x30000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>());

  <span class="macro">assert!</span>(<span class="ident">memory</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>).<span class="ident">is_ok</span>());

  <span class="macro">println!</span>(<span class="string">&quot;Creating stand-alone memory...&quot;</span>);
  <span class="kw">let</span> <span class="ident">memorytype</span> <span class="op">=</span> <span class="ident">MemoryType::new</span>(<span class="number">5</span>, <span class="prelude-val">Some</span>(<span class="number">5</span>));
  <span class="kw">let</span> <span class="ident">memory2</span> <span class="op">=</span> <span class="highlight focus"><span class="ident">Memory::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="ident">memorytype</span>)</span><span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory2</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">5</span>);
  <span class="macro">assert!</span>(<span class="ident">memory2</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory2</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>).<span class="ident">is_ok</span>());

  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div></div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.new_async" class="method has-srclink"><div class="rightside"></div><a href="#method.new_async" class="anchor"></a><h4 class="code-header">pub async fn <a href="#method.new_async" class="fnname">new_async</a>&lt;T&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;store: impl <a class="trait" href="trait.AsContextMut.html" title="trait wiggle::wasmtime_crate::AsContextMut">AsContextMut</a>&lt;Data = T&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;ty: <a class="struct" href="struct.MemoryType.html" title="struct wiggle::wasmtime_crate::MemoryType">MemoryType</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Memory.html" title="struct wiggle::wasmtime_crate::Memory">Memory</a>, <a class="struct" href="https://docs.rs/anyhow/1.0.40/anyhow/struct.Error.html" title="struct anyhow::Error">Error</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,&nbsp;</span></h4></div></summary><div class="docblock"><p>Async variant of <a href="struct.Memory.html#method.new" title="Memory::new"><code>Memory::new</code></a>. You must use this variant with
<a href="struct.Store.html"><code>Store</code></a>s which have a
<a href="trait.ResourceLimiterAsync.html"><code>ResourceLimiterAsync</code></a>.</p>
<h5 id="panics-1" class="section-header"><a href="#panics-1">Panics</a></h5>
<p>This function will panic when used with a non-async
<a href="struct.Store.html"><code>Store</code></a>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.ty" class="method has-srclink"><div class="rightside"></div><a href="#method.ty" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.ty" class="fnname">ty</a>(&amp;self, store: impl <a class="trait" href="trait.AsContext.html" title="trait wiggle::wasmtime_crate::AsContext">AsContext</a>) -&gt; <a class="struct" href="struct.MemoryType.html" title="struct wiggle::wasmtime_crate::MemoryType">MemoryType</a></h4></div></summary><div class="docblock"><p>Returns the underlying type of this memory.</p>
<h5 id="panics-2" class="section-header"><a href="#panics-2">Panics</a></h5>
<p>Panics if this memory doesn’t belong to <code>store</code>.</p>
<h5 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::default</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ());
<span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, <span class="string">&quot;(module (memory (export \&quot;mem\&quot;) 1))&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">memory</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_memory</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;mem&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">ty</span> <span class="op">=</span> <span class="ident">memory</span>.<span class="ident">ty</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>);
<span class="macro">assert_eq!</span>(<span class="ident">ty</span>.<span class="ident">minimum</span>(), <span class="number">1</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.read" class="method has-srclink"><div class="rightside"></div><a href="#method.read" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.read" class="fnname">read</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;store: impl <a class="trait" href="trait.AsContext.html" title="trait wiggle::wasmtime_crate::AsContext">AsContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;offset: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;buffer: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.MemoryAccessError.html" title="struct wiggle::wasmtime_crate::MemoryAccessError">MemoryAccessError</a>&gt;</h4></div></summary><div class="docblock"><p>Safely reads memory contents at the given offset into a buffer.</p>
<p>The entire buffer will be filled.</p>
<p>If <code>offset + buffer.len()</code> exceed the current memory capacity, then the
buffer is left untouched and a <a href="struct.MemoryAccessError.html" title="MemoryAccessError"><code>MemoryAccessError</code></a> is returned.</p>
<h5 id="panics-3" class="section-header"><a href="#panics-3">Panics</a></h5>
<p>Panics if this memory doesn’t belong to <code>store</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.write" class="method has-srclink"><div class="rightside"></div><a href="#method.write" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.write" class="fnname">write</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;store: impl <a class="trait" href="trait.AsContextMut.html" title="trait wiggle::wasmtime_crate::AsContextMut">AsContextMut</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;offset: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;buffer: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.MemoryAccessError.html" title="struct wiggle::wasmtime_crate::MemoryAccessError">MemoryAccessError</a>&gt;</h4></div></summary><div class="docblock"><p>Safely writes contents of a buffer to this memory at the given offset.</p>
<p>If the <code>offset + buffer.len()</code> exceeds the current memory capacity, then
none of the buffer is written to memory and a <a href="struct.MemoryAccessError.html" title="MemoryAccessError"><code>MemoryAccessError</code></a> is
returned.</p>
<h5 id="panics-4" class="section-header"><a href="#panics-4">Panics</a></h5>
<p>Panics if this memory doesn’t belong to <code>store</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.data" class="method has-srclink"><div class="rightside"></div><a href="#method.data" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.data" class="fnname">data</a>&lt;'a, T&gt;(&amp;self, store: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.StoreContext.html" title="struct wiggle::wasmtime_crate::StoreContext">StoreContext</a>&lt;'a, T&gt;&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></div><code class="content"><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></span><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'_ mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a,&nbsp;</span></h4></div></summary><div class="docblock"><p>Returns this memory as a native Rust slice.</p>
<p>Note that this method will consider the entire store context provided as
borrowed for the duration of the lifetime of the returned slice.</p>
<h5 id="panics-5" class="section-header"><a href="#panics-5">Panics</a></h5>
<p>Panics if this memory doesn’t belong to <code>store</code>.</p>
</div><div class="docblock scraped-example-list"><span></span><h5 id="scraped-examples-1" class="section-header"><a href="#scraped-examples-1">Examples found in repository</a></h5><div class="scraped-example " data-locs="[[[35,35],&quot;../../src/memory/memory.rs.html#47&quot;,&quot;line 47&quot;],[[36,36],&quot;../../src/memory/memory.rs.html#48&quot;,&quot;line 48&quot;]]"><div class="scraped-example-title">examples/memory.rs (<a href="../../src/memory/memory.rs.html#47">line 47</a>)</div><div class="code-wrapper"><span class="prev">&pr;</span> <span class="next">&sc;</span><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
<span>57</span>
<span>58</span>
<span>59</span>
<span>60</span>
<span>61</span>
<span>62</span>
<span>63</span>
<span>64</span>
<span>65</span>
<span>66</span>
<span>67</span>
<span>68</span>
<span>69</span>
<span>70</span>
<span>71</span>
<span>72</span>
<span>73</span>
<span>74</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Create our `store_fn` context and then compile a module and create an</span>
  <span class="comment">// instance from the compiled module all in one go.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span>: <span class="ident">Store</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Store::default</span>();
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="ident">store</span>.<span class="ident">engine</span>(), <span class="string">&quot;examples/memory.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="comment">// load_fn up our exports from the instance</span>
  <span class="kw">let</span> <span class="ident">memory</span> <span class="op">=</span> <span class="ident">instance</span>
    .<span class="ident">get_memory</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;memory&quot;</span>)
    .<span class="ident">ok_or</span>(<span class="macro">anyhow::format_err!</span>(<span class="string">&quot;failed to find `memory` export&quot;</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">size</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;size&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">load_fn</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;load&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">store_fn</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;store&quot;</span>)<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Checking memory...&quot;</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x20000</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0</span>], <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1000</span>], <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">4</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">size</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1000</span>)<span class="question-mark">?</span>, <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1ffff</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">println!</span>(<span class="string">&quot;Mutating memory...&quot;</span>);
  <span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>] <span class="op">=</span> <span class="number">5</span>;

  <span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x1002</span>, <span class="number">6</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="highlight focus"><span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)</span>[<span class="number">0x1002</span>], <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="highlight"><span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)</span>[<span class="number">0x1003</span>], <span class="number">5</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">5</span>);

  <span class="comment">// Grow memory.</span>
  <span class="macro">println!</span>(<span class="string">&quot;Growing memory...&quot;</span>);
  <span class="ident">memory</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>)<span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x30000</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x30000</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x30000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>());

  <span class="macro">assert!</span>(<span class="ident">memory</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>).<span class="ident">is_ok</span>());

  <span class="macro">println!</span>(<span class="string">&quot;Creating stand-alone memory...&quot;</span>);
  <span class="kw">let</span> <span class="ident">memorytype</span> <span class="op">=</span> <span class="ident">MemoryType::new</span>(<span class="number">5</span>, <span class="prelude-val">Some</span>(<span class="number">5</span>));
  <span class="kw">let</span> <span class="ident">memory2</span> <span class="op">=</span> <span class="ident">Memory::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="ident">memorytype</span>)<span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory2</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">5</span>);
  <span class="macro">assert!</span>(<span class="ident">memory2</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory2</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>).<span class="ident">is_ok</span>());

  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><details class="rustdoc-toggle more-examples-toggle"><summary class="hideme"><span>More examples</span></summary><div class="more-scraped-examples"><div class="toggle-line"><div class="toggle-line-inner"></div></div><div class="more-scraped-examples-inner"><div class="scraped-example " data-locs="[[[68,68],&quot;../../src/multimemory/multimemory.rs.html#80&quot;,&quot;line 80&quot;],[[69,69],&quot;../../src/multimemory/multimemory.rs.html#81&quot;,&quot;line 81&quot;],[[78,78],&quot;../../src/multimemory/multimemory.rs.html#90&quot;,&quot;line 90&quot;],[[79,79],&quot;../../src/multimemory/multimemory.rs.html#91&quot;,&quot;line 91&quot;]]"><div class="scraped-example-title">examples/multimemory.rs (<a href="../../src/multimemory/multimemory.rs.html#80">line 80</a>)</div><div class="code-wrapper"><span class="prev">&pr;</span> <span class="next">&sc;</span><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span> 12</span>
<span> 13</span>
<span> 14</span>
<span> 15</span>
<span> 16</span>
<span> 17</span>
<span> 18</span>
<span> 19</span>
<span> 20</span>
<span> 21</span>
<span> 22</span>
<span> 23</span>
<span> 24</span>
<span> 25</span>
<span> 26</span>
<span> 27</span>
<span> 28</span>
<span> 29</span>
<span> 30</span>
<span> 31</span>
<span> 32</span>
<span> 33</span>
<span> 34</span>
<span> 35</span>
<span> 36</span>
<span> 37</span>
<span> 38</span>
<span> 39</span>
<span> 40</span>
<span> 41</span>
<span> 42</span>
<span> 43</span>
<span> 44</span>
<span> 45</span>
<span> 46</span>
<span> 47</span>
<span> 48</span>
<span> 49</span>
<span> 50</span>
<span> 51</span>
<span> 52</span>
<span> 53</span>
<span> 54</span>
<span> 55</span>
<span> 56</span>
<span> 57</span>
<span> 58</span>
<span> 59</span>
<span> 60</span>
<span> 61</span>
<span> 62</span>
<span> 63</span>
<span> 64</span>
<span> 65</span>
<span> 66</span>
<span> 67</span>
<span> 68</span>
<span> 69</span>
<span> 70</span>
<span> 71</span>
<span> 72</span>
<span> 73</span>
<span> 74</span>
<span> 75</span>
<span> 76</span>
<span> 77</span>
<span> 78</span>
<span> 79</span>
<span> 80</span>
<span> 81</span>
<span> 82</span>
<span> 83</span>
<span> 84</span>
<span> 85</span>
<span> 86</span>
<span> 87</span>
<span> 88</span>
<span> 89</span>
<span> 90</span>
<span> 91</span>
<span> 92</span>
<span> 93</span>
<span> 94</span>
<span> 95</span>
<span> 96</span>
<span> 97</span>
<span> 98</span>
<span> 99</span>
<span>100</span>
<span>101</span>
<span>102</span>
<span>103</span>
<span>104</span>
<span>105</span>
<span>106</span>
<span>107</span>
<span>108</span>
<span>109</span>
<span>110</span>
<span>111</span>
<span>112</span>
<span>113</span>
<span>114</span>
<span>115</span>
<span>116</span>
<span>117</span>
<span>118</span>
<span>119</span>
<span>120</span>
<span>121</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Enable the multi-memory feature.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">config</span> <span class="op">=</span> <span class="ident">Config::new</span>();
  <span class="ident">config</span>.<span class="ident">wasm_multi_memory</span>(<span class="bool-val">true</span>);

  <span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>(<span class="kw-2">&amp;</span><span class="ident">config</span>)<span class="question-mark">?</span>;

  <span class="comment">// Create our `store_fn` context and then compile a module and create an</span>
  <span class="comment">// instance from the compiled module all in one go.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ());
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="ident">store</span>.<span class="ident">engine</span>(), <span class="string">&quot;examples/multimemory.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="kw">let</span> <span class="ident">memory0</span> <span class="op">=</span> <span class="ident">instance</span>
    .<span class="ident">get_memory</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;memory0&quot;</span>)
    .<span class="ident">ok_or</span>(<span class="macro">anyhow::format_err!</span>(<span class="string">&quot;failed to find `memory0` export&quot;</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">size0</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;size0&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">load0</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;load0&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">store0</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;store0&quot;</span>)<span class="question-mark">?</span>;

  <span class="kw">let</span> <span class="ident">memory1</span> <span class="op">=</span> <span class="ident">instance</span>
    .<span class="ident">get_memory</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;memory1&quot;</span>)
    .<span class="ident">ok_or</span>(<span class="macro">anyhow::format_err!</span>(<span class="string">&quot;failed to find `memory1` export&quot;</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">size1</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;size1&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">load1</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;load1&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">store1</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;store1&quot;</span>)<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Checking memory...&quot;</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x20000</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0</span>], <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1000</span>], <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1001</span>], <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">4</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">size0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1000</span>)<span class="question-mark">?</span>, <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1001</span>)<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1ffff</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x20000</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0</span>], <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1000</span>], <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1001</span>], <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">1</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">size1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1000</span>)<span class="question-mark">?</span>, <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1001</span>)<span class="question-mark">?</span>, <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1ffff</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">println!</span>(<span class="string">&quot;Mutating memory...&quot;</span>);
  <span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>] <span class="op">=</span> <span class="number">5</span>;

  <span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x1002</span>, <span class="number">6</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="highlight focus"><span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)</span>[<span class="number">0x1002</span>], <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="highlight"><span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)</span>[<span class="number">0x1003</span>], <span class="number">5</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">5</span>);

  <span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>] <span class="op">=</span> <span class="number">7</span>;

  <span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x1002</span>, <span class="number">8</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="highlight"><span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)</span>[<span class="number">0x1002</span>], <span class="number">8</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="highlight"><span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)</span>[<span class="number">0x1003</span>], <span class="number">7</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">8</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">7</span>);

  <span class="macro">println!</span>(<span class="string">&quot;Growing memory...&quot;</span>);
  <span class="ident">memory0</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>)<span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x30000</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x30000</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x30000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>());

  <span class="macro">assert!</span>(<span class="ident">memory0</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory0</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>).<span class="ident">is_ok</span>());

  <span class="ident">memory1</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">2</span>)<span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x40000</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x30000</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x30000</span>, <span class="number">0</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x40000</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x40000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>());

  <span class="macro">assert!</span>(<span class="ident">memory1</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory1</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>).<span class="ident">is_ok</span>());

  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div></div></div></details></div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.data_mut" class="method has-srclink"><div class="rightside"></div><a href="#method.data_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.data_mut" class="fnname">data_mut</a>&lt;'a, T&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;store: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.StoreContextMut.html" title="struct wiggle::wasmtime_crate::StoreContextMut">StoreContextMut</a>&lt;'a, T&gt;&gt;<br>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></div><code class="content"><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></span><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'_ mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a,&nbsp;</span></h4></div></summary><div class="docblock"><p>Returns this memory as a native Rust mutable slice.</p>
<p>Note that this method will consider the entire store context provided as
borrowed for the duration of the lifetime of the returned slice.</p>
<h5 id="panics-6" class="section-header"><a href="#panics-6">Panics</a></h5>
<p>Panics if this memory doesn’t belong to <code>store</code>.</p>
</div><div class="docblock scraped-example-list"><span></span><h5 id="scraped-examples-2" class="section-header"><a href="#scraped-examples-2">Examples found in repository</a></h5><div class="scraped-example " data-locs="[[[18,18],&quot;../../src/memory/memory.rs.html#30&quot;,&quot;line 30&quot;],[[19,19],&quot;../../src/memory/memory.rs.html#31&quot;,&quot;line 31&quot;],[[20,20],&quot;../../src/memory/memory.rs.html#32&quot;,&quot;line 32&quot;],[[30,30],&quot;../../src/memory/memory.rs.html#42&quot;,&quot;line 42&quot;]]"><div class="scraped-example-title">examples/memory.rs (<a href="../../src/memory/memory.rs.html#30">line 30</a>)</div><div class="code-wrapper"><span class="prev">&pr;</span> <span class="next">&sc;</span><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
<span>57</span>
<span>58</span>
<span>59</span>
<span>60</span>
<span>61</span>
<span>62</span>
<span>63</span>
<span>64</span>
<span>65</span>
<span>66</span>
<span>67</span>
<span>68</span>
<span>69</span>
<span>70</span>
<span>71</span>
<span>72</span>
<span>73</span>
<span>74</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Create our `store_fn` context and then compile a module and create an</span>
  <span class="comment">// instance from the compiled module all in one go.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span>: <span class="ident">Store</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Store::default</span>();
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="ident">store</span>.<span class="ident">engine</span>(), <span class="string">&quot;examples/memory.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="comment">// load_fn up our exports from the instance</span>
  <span class="kw">let</span> <span class="ident">memory</span> <span class="op">=</span> <span class="ident">instance</span>
    .<span class="ident">get_memory</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;memory&quot;</span>)
    .<span class="ident">ok_or</span>(<span class="macro">anyhow::format_err!</span>(<span class="string">&quot;failed to find `memory` export&quot;</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">size</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;size&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">load_fn</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;load&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">store_fn</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;store&quot;</span>)<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Checking memory...&quot;</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x20000</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="highlight focus"><span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)</span>[<span class="number">0</span>], <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="highlight"><span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)</span>[<span class="number">0x1000</span>], <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="highlight"><span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)</span>[<span class="number">0x1003</span>], <span class="number">4</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">size</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1000</span>)<span class="question-mark">?</span>, <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1ffff</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">println!</span>(<span class="string">&quot;Mutating memory...&quot;</span>);
  <span class="ident">memory</span>.<span class="highlight"><span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)</span>[<span class="number">0x1003</span>] <span class="op">=</span> <span class="number">5</span>;

  <span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x1002</span>, <span class="number">6</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">5</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">5</span>);

  <span class="comment">// Grow memory.</span>
  <span class="macro">println!</span>(<span class="string">&quot;Growing memory...&quot;</span>);
  <span class="ident">memory</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>)<span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x30000</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x30000</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x30000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>());

  <span class="macro">assert!</span>(<span class="ident">memory</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>).<span class="ident">is_ok</span>());

  <span class="macro">println!</span>(<span class="string">&quot;Creating stand-alone memory...&quot;</span>);
  <span class="kw">let</span> <span class="ident">memorytype</span> <span class="op">=</span> <span class="ident">MemoryType::new</span>(<span class="number">5</span>, <span class="prelude-val">Some</span>(<span class="number">5</span>));
  <span class="kw">let</span> <span class="ident">memory2</span> <span class="op">=</span> <span class="ident">Memory::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="ident">memorytype</span>)<span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory2</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">5</span>);
  <span class="macro">assert!</span>(<span class="ident">memory2</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory2</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>).<span class="ident">is_ok</span>());

  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><details class="rustdoc-toggle more-examples-toggle"><summary class="hideme"><span>More examples</span></summary><div class="more-scraped-examples"><div class="toggle-line"><div class="toggle-line-inner"></div></div><div class="more-scraped-examples-inner"><div class="scraped-example " data-locs="[[[30,30],&quot;../../src/multimemory/multimemory.rs.html#42&quot;,&quot;line 42&quot;],[[31,31],&quot;../../src/multimemory/multimemory.rs.html#43&quot;,&quot;line 43&quot;],[[32,32],&quot;../../src/multimemory/multimemory.rs.html#44&quot;,&quot;line 44&quot;],[[33,33],&quot;../../src/multimemory/multimemory.rs.html#45&quot;,&quot;line 45&quot;],[[34,34],&quot;../../src/multimemory/multimemory.rs.html#46&quot;,&quot;line 46&quot;],[[47,47],&quot;../../src/multimemory/multimemory.rs.html#59&quot;,&quot;line 59&quot;],[[48,48],&quot;../../src/multimemory/multimemory.rs.html#60&quot;,&quot;line 60&quot;],[[49,49],&quot;../../src/multimemory/multimemory.rs.html#61&quot;,&quot;line 61&quot;],[[50,50],&quot;../../src/multimemory/multimemory.rs.html#62&quot;,&quot;line 62&quot;],[[51,51],&quot;../../src/multimemory/multimemory.rs.html#63&quot;,&quot;line 63&quot;],[[63,63],&quot;../../src/multimemory/multimemory.rs.html#75&quot;,&quot;line 75&quot;],[[73,73],&quot;../../src/multimemory/multimemory.rs.html#85&quot;,&quot;line 85&quot;]]"><div class="scraped-example-title">examples/multimemory.rs (<a href="../../src/multimemory/multimemory.rs.html#42">line 42</a>)</div><div class="code-wrapper"><span class="prev">&pr;</span> <span class="next">&sc;</span><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span> 12</span>
<span> 13</span>
<span> 14</span>
<span> 15</span>
<span> 16</span>
<span> 17</span>
<span> 18</span>
<span> 19</span>
<span> 20</span>
<span> 21</span>
<span> 22</span>
<span> 23</span>
<span> 24</span>
<span> 25</span>
<span> 26</span>
<span> 27</span>
<span> 28</span>
<span> 29</span>
<span> 30</span>
<span> 31</span>
<span> 32</span>
<span> 33</span>
<span> 34</span>
<span> 35</span>
<span> 36</span>
<span> 37</span>
<span> 38</span>
<span> 39</span>
<span> 40</span>
<span> 41</span>
<span> 42</span>
<span> 43</span>
<span> 44</span>
<span> 45</span>
<span> 46</span>
<span> 47</span>
<span> 48</span>
<span> 49</span>
<span> 50</span>
<span> 51</span>
<span> 52</span>
<span> 53</span>
<span> 54</span>
<span> 55</span>
<span> 56</span>
<span> 57</span>
<span> 58</span>
<span> 59</span>
<span> 60</span>
<span> 61</span>
<span> 62</span>
<span> 63</span>
<span> 64</span>
<span> 65</span>
<span> 66</span>
<span> 67</span>
<span> 68</span>
<span> 69</span>
<span> 70</span>
<span> 71</span>
<span> 72</span>
<span> 73</span>
<span> 74</span>
<span> 75</span>
<span> 76</span>
<span> 77</span>
<span> 78</span>
<span> 79</span>
<span> 80</span>
<span> 81</span>
<span> 82</span>
<span> 83</span>
<span> 84</span>
<span> 85</span>
<span> 86</span>
<span> 87</span>
<span> 88</span>
<span> 89</span>
<span> 90</span>
<span> 91</span>
<span> 92</span>
<span> 93</span>
<span> 94</span>
<span> 95</span>
<span> 96</span>
<span> 97</span>
<span> 98</span>
<span> 99</span>
<span>100</span>
<span>101</span>
<span>102</span>
<span>103</span>
<span>104</span>
<span>105</span>
<span>106</span>
<span>107</span>
<span>108</span>
<span>109</span>
<span>110</span>
<span>111</span>
<span>112</span>
<span>113</span>
<span>114</span>
<span>115</span>
<span>116</span>
<span>117</span>
<span>118</span>
<span>119</span>
<span>120</span>
<span>121</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Enable the multi-memory feature.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">config</span> <span class="op">=</span> <span class="ident">Config::new</span>();
  <span class="ident">config</span>.<span class="ident">wasm_multi_memory</span>(<span class="bool-val">true</span>);

  <span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>(<span class="kw-2">&amp;</span><span class="ident">config</span>)<span class="question-mark">?</span>;

  <span class="comment">// Create our `store_fn` context and then compile a module and create an</span>
  <span class="comment">// instance from the compiled module all in one go.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ());
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="ident">store</span>.<span class="ident">engine</span>(), <span class="string">&quot;examples/multimemory.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="kw">let</span> <span class="ident">memory0</span> <span class="op">=</span> <span class="ident">instance</span>
    .<span class="ident">get_memory</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;memory0&quot;</span>)
    .<span class="ident">ok_or</span>(<span class="macro">anyhow::format_err!</span>(<span class="string">&quot;failed to find `memory0` export&quot;</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">size0</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;size0&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">load0</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;load0&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">store0</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;store0&quot;</span>)<span class="question-mark">?</span>;

  <span class="kw">let</span> <span class="ident">memory1</span> <span class="op">=</span> <span class="ident">instance</span>
    .<span class="ident">get_memory</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;memory1&quot;</span>)
    .<span class="ident">ok_or</span>(<span class="macro">anyhow::format_err!</span>(<span class="string">&quot;failed to find `memory1` export&quot;</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">size1</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;size1&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">load1</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;load1&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">store1</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;store1&quot;</span>)<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Checking memory...&quot;</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x20000</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="highlight focus"><span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)</span>[<span class="number">0</span>], <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="highlight"><span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)</span>[<span class="number">0x1000</span>], <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="highlight"><span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)</span>[<span class="number">0x1001</span>], <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="highlight"><span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)</span>[<span class="number">0x1002</span>], <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="highlight"><span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)</span>[<span class="number">0x1003</span>], <span class="number">4</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">size0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1000</span>)<span class="question-mark">?</span>, <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1001</span>)<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1ffff</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x20000</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="highlight"><span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)</span>[<span class="number">0</span>], <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="highlight"><span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)</span>[<span class="number">0x1000</span>], <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="highlight"><span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)</span>[<span class="number">0x1001</span>], <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="highlight"><span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)</span>[<span class="number">0x1002</span>], <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="highlight"><span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)</span>[<span class="number">0x1003</span>], <span class="number">1</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">size1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1000</span>)<span class="question-mark">?</span>, <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1001</span>)<span class="question-mark">?</span>, <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1ffff</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">println!</span>(<span class="string">&quot;Mutating memory...&quot;</span>);
  <span class="ident">memory0</span>.<span class="highlight"><span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)</span>[<span class="number">0x1003</span>] <span class="op">=</span> <span class="number">5</span>;

  <span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x1002</span>, <span class="number">6</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">5</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">5</span>);

  <span class="ident">memory1</span>.<span class="highlight"><span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)</span>[<span class="number">0x1003</span>] <span class="op">=</span> <span class="number">7</span>;

  <span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x1002</span>, <span class="number">8</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">8</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">7</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">8</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">7</span>);

  <span class="macro">println!</span>(<span class="string">&quot;Growing memory...&quot;</span>);
  <span class="ident">memory0</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>)<span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x30000</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x30000</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x30000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>());

  <span class="macro">assert!</span>(<span class="ident">memory0</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory0</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>).<span class="ident">is_ok</span>());

  <span class="ident">memory1</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">2</span>)<span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x40000</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x30000</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x30000</span>, <span class="number">0</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x40000</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x40000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>());

  <span class="macro">assert!</span>(<span class="ident">memory1</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory1</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>).<span class="ident">is_ok</span>());

  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div></div></div></details></div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.data_and_store_mut" class="method has-srclink"><div class="rightside"></div><a href="#method.data_and_store_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.data_and_store_mut" class="fnname">data_and_store_mut</a>&lt;'a, T&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;store: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.StoreContextMut.html" title="struct wiggle::wasmtime_crate::StoreContextMut">StoreContextMut</a>&lt;'a, T&gt;&gt;<br>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a mut </a>T<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a,&nbsp;</span></h4></div></summary><div class="docblock"><p>Same as <a href="struct.Memory.html#method.data_mut" title="Memory::data_mut"><code>Memory::data_mut</code></a>, but also returns the <code>T</code> from the
<a href="struct.StoreContextMut.html" title="StoreContextMut"><code>StoreContextMut</code></a>.</p>
<p>This method can be used when you want to simultaneously work with the
<code>T</code> in the store as well as the memory behind this <a href="struct.Memory.html" title="Memory"><code>Memory</code></a>. Using
<a href="struct.Memory.html#method.data_mut" title="Memory::data_mut"><code>Memory::data_mut</code></a> would consider the entire store borrowed, whereas
this method allows the Rust compiler to see that the borrow of this
memory and the borrow of <code>T</code> are disjoint.</p>
<h5 id="panics-7" class="section-header"><a href="#panics-7">Panics</a></h5>
<p>Panics if this memory doesn’t belong to <code>store</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.data_ptr" class="method has-srclink"><div class="rightside"></div><a href="#method.data_ptr" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.data_ptr" class="fnname">data_ptr</a>(&amp;self, store: impl <a class="trait" href="trait.AsContext.html" title="trait wiggle::wasmtime_crate::AsContext">AsContext</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a></h4></div></summary><div class="docblock"><p>Returns the base pointer, in the host’s address space, that the memory
is located at.</p>
<p>For more information and examples see the documentation on the
<a href="struct.Memory.html" title="Memory"><code>Memory</code></a> type.</p>
<h5 id="panics-8" class="section-header"><a href="#panics-8">Panics</a></h5>
<p>Panics if this memory doesn’t belong to <code>store</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.data_size" class="method has-srclink"><div class="rightside"></div><a href="#method.data_size" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.data_size" class="fnname">data_size</a>(&amp;self, store: impl <a class="trait" href="trait.AsContext.html" title="trait wiggle::wasmtime_crate::AsContext">AsContext</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></div></summary><div class="docblock"><p>Returns the byte length of this memory.</p>
<p>The returned value will be a multiple of the wasm page size, 64k.</p>
<p>For more information and examples see the documentation on the
<a href="struct.Memory.html" title="Memory"><code>Memory</code></a> type.</p>
<h5 id="panics-9" class="section-header"><a href="#panics-9">Panics</a></h5>
<p>Panics if this memory doesn’t belong to <code>store</code>.</p>
</div><div class="docblock scraped-example-list"><span></span><h5 id="scraped-examples-3" class="section-header"><a href="#scraped-examples-3">Examples found in repository</a></h5><div class="scraped-example " data-locs="[[[17,17],&quot;../../src/memory/memory.rs.html#29&quot;,&quot;line 29&quot;],[[44,44],&quot;../../src/memory/memory.rs.html#56&quot;,&quot;line 56&quot;]]"><div class="scraped-example-title">examples/memory.rs (<a href="../../src/memory/memory.rs.html#29">line 29</a>)</div><div class="code-wrapper"><span class="prev">&pr;</span> <span class="next">&sc;</span><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
<span>57</span>
<span>58</span>
<span>59</span>
<span>60</span>
<span>61</span>
<span>62</span>
<span>63</span>
<span>64</span>
<span>65</span>
<span>66</span>
<span>67</span>
<span>68</span>
<span>69</span>
<span>70</span>
<span>71</span>
<span>72</span>
<span>73</span>
<span>74</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Create our `store_fn` context and then compile a module and create an</span>
  <span class="comment">// instance from the compiled module all in one go.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span>: <span class="ident">Store</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Store::default</span>();
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="ident">store</span>.<span class="ident">engine</span>(), <span class="string">&quot;examples/memory.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="comment">// load_fn up our exports from the instance</span>
  <span class="kw">let</span> <span class="ident">memory</span> <span class="op">=</span> <span class="ident">instance</span>
    .<span class="ident">get_memory</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;memory&quot;</span>)
    .<span class="ident">ok_or</span>(<span class="macro">anyhow::format_err!</span>(<span class="string">&quot;failed to find `memory` export&quot;</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">size</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;size&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">load_fn</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;load&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">store_fn</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;store&quot;</span>)<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Checking memory...&quot;</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="highlight focus"><span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)</span>, <span class="number">0x20000</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0</span>], <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1000</span>], <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">4</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">size</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1000</span>)<span class="question-mark">?</span>, <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1ffff</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">println!</span>(<span class="string">&quot;Mutating memory...&quot;</span>);
  <span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>] <span class="op">=</span> <span class="number">5</span>;

  <span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x1002</span>, <span class="number">6</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">5</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">5</span>);

  <span class="comment">// Grow memory.</span>
  <span class="macro">println!</span>(<span class="string">&quot;Growing memory...&quot;</span>);
  <span class="ident">memory</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>)<span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="highlight"><span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)</span>, <span class="number">0x30000</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x30000</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x30000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>());

  <span class="macro">assert!</span>(<span class="ident">memory</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>).<span class="ident">is_ok</span>());

  <span class="macro">println!</span>(<span class="string">&quot;Creating stand-alone memory...&quot;</span>);
  <span class="kw">let</span> <span class="ident">memorytype</span> <span class="op">=</span> <span class="ident">MemoryType::new</span>(<span class="number">5</span>, <span class="prelude-val">Some</span>(<span class="number">5</span>));
  <span class="kw">let</span> <span class="ident">memory2</span> <span class="op">=</span> <span class="ident">Memory::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="ident">memorytype</span>)<span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory2</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">5</span>);
  <span class="macro">assert!</span>(<span class="ident">memory2</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory2</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>).<span class="ident">is_ok</span>());

  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><details class="rustdoc-toggle more-examples-toggle"><summary class="hideme"><span>More examples</span></summary><div class="more-scraped-examples"><div class="toggle-line"><div class="toggle-line-inner"></div></div><div class="more-scraped-examples-inner"><div class="scraped-example " data-locs="[[[29,29],&quot;../../src/multimemory/multimemory.rs.html#41&quot;,&quot;line 41&quot;],[[46,46],&quot;../../src/multimemory/multimemory.rs.html#58&quot;,&quot;line 58&quot;],[[86,86],&quot;../../src/multimemory/multimemory.rs.html#98&quot;,&quot;line 98&quot;],[[98,98],&quot;../../src/multimemory/multimemory.rs.html#110&quot;,&quot;line 110&quot;]]"><div class="scraped-example-title">examples/multimemory.rs (<a href="../../src/multimemory/multimemory.rs.html#41">line 41</a>)</div><div class="code-wrapper"><span class="prev">&pr;</span> <span class="next">&sc;</span><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span> 12</span>
<span> 13</span>
<span> 14</span>
<span> 15</span>
<span> 16</span>
<span> 17</span>
<span> 18</span>
<span> 19</span>
<span> 20</span>
<span> 21</span>
<span> 22</span>
<span> 23</span>
<span> 24</span>
<span> 25</span>
<span> 26</span>
<span> 27</span>
<span> 28</span>
<span> 29</span>
<span> 30</span>
<span> 31</span>
<span> 32</span>
<span> 33</span>
<span> 34</span>
<span> 35</span>
<span> 36</span>
<span> 37</span>
<span> 38</span>
<span> 39</span>
<span> 40</span>
<span> 41</span>
<span> 42</span>
<span> 43</span>
<span> 44</span>
<span> 45</span>
<span> 46</span>
<span> 47</span>
<span> 48</span>
<span> 49</span>
<span> 50</span>
<span> 51</span>
<span> 52</span>
<span> 53</span>
<span> 54</span>
<span> 55</span>
<span> 56</span>
<span> 57</span>
<span> 58</span>
<span> 59</span>
<span> 60</span>
<span> 61</span>
<span> 62</span>
<span> 63</span>
<span> 64</span>
<span> 65</span>
<span> 66</span>
<span> 67</span>
<span> 68</span>
<span> 69</span>
<span> 70</span>
<span> 71</span>
<span> 72</span>
<span> 73</span>
<span> 74</span>
<span> 75</span>
<span> 76</span>
<span> 77</span>
<span> 78</span>
<span> 79</span>
<span> 80</span>
<span> 81</span>
<span> 82</span>
<span> 83</span>
<span> 84</span>
<span> 85</span>
<span> 86</span>
<span> 87</span>
<span> 88</span>
<span> 89</span>
<span> 90</span>
<span> 91</span>
<span> 92</span>
<span> 93</span>
<span> 94</span>
<span> 95</span>
<span> 96</span>
<span> 97</span>
<span> 98</span>
<span> 99</span>
<span>100</span>
<span>101</span>
<span>102</span>
<span>103</span>
<span>104</span>
<span>105</span>
<span>106</span>
<span>107</span>
<span>108</span>
<span>109</span>
<span>110</span>
<span>111</span>
<span>112</span>
<span>113</span>
<span>114</span>
<span>115</span>
<span>116</span>
<span>117</span>
<span>118</span>
<span>119</span>
<span>120</span>
<span>121</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Enable the multi-memory feature.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">config</span> <span class="op">=</span> <span class="ident">Config::new</span>();
  <span class="ident">config</span>.<span class="ident">wasm_multi_memory</span>(<span class="bool-val">true</span>);

  <span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>(<span class="kw-2">&amp;</span><span class="ident">config</span>)<span class="question-mark">?</span>;

  <span class="comment">// Create our `store_fn` context and then compile a module and create an</span>
  <span class="comment">// instance from the compiled module all in one go.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ());
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="ident">store</span>.<span class="ident">engine</span>(), <span class="string">&quot;examples/multimemory.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="kw">let</span> <span class="ident">memory0</span> <span class="op">=</span> <span class="ident">instance</span>
    .<span class="ident">get_memory</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;memory0&quot;</span>)
    .<span class="ident">ok_or</span>(<span class="macro">anyhow::format_err!</span>(<span class="string">&quot;failed to find `memory0` export&quot;</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">size0</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;size0&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">load0</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;load0&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">store0</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;store0&quot;</span>)<span class="question-mark">?</span>;

  <span class="kw">let</span> <span class="ident">memory1</span> <span class="op">=</span> <span class="ident">instance</span>
    .<span class="ident">get_memory</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;memory1&quot;</span>)
    .<span class="ident">ok_or</span>(<span class="macro">anyhow::format_err!</span>(<span class="string">&quot;failed to find `memory1` export&quot;</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">size1</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;size1&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">load1</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;load1&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">store1</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;store1&quot;</span>)<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Checking memory...&quot;</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="highlight focus"><span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)</span>, <span class="number">0x20000</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0</span>], <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1000</span>], <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1001</span>], <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">4</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">size0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1000</span>)<span class="question-mark">?</span>, <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1001</span>)<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1ffff</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="highlight"><span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)</span>, <span class="number">0x20000</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0</span>], <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1000</span>], <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1001</span>], <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">1</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">size1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1000</span>)<span class="question-mark">?</span>, <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1001</span>)<span class="question-mark">?</span>, <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1ffff</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">println!</span>(<span class="string">&quot;Mutating memory...&quot;</span>);
  <span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>] <span class="op">=</span> <span class="number">5</span>;

  <span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x1002</span>, <span class="number">6</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">5</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">5</span>);

  <span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>] <span class="op">=</span> <span class="number">7</span>;

  <span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x1002</span>, <span class="number">8</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">8</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">7</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">8</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">7</span>);

  <span class="macro">println!</span>(<span class="string">&quot;Growing memory...&quot;</span>);
  <span class="ident">memory0</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>)<span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="highlight"><span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)</span>, <span class="number">0x30000</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x30000</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x30000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>());

  <span class="macro">assert!</span>(<span class="ident">memory0</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory0</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>).<span class="ident">is_ok</span>());

  <span class="ident">memory1</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">2</span>)<span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="highlight"><span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)</span>, <span class="number">0x40000</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x30000</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x30000</span>, <span class="number">0</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x40000</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x40000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>());

  <span class="macro">assert!</span>(<span class="ident">memory1</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory1</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>).<span class="ident">is_ok</span>());

  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div></div></div></details></div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.size" class="method has-srclink"><div class="rightside"></div><a href="#method.size" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.size" class="fnname">size</a>(&amp;self, store: impl <a class="trait" href="trait.AsContext.html" title="trait wiggle::wasmtime_crate::AsContext">AsContext</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a></h4></div></summary><div class="docblock"><p>Returns the size, in WebAssembly pages, of this wasm memory.</p>
<h5 id="panics-10" class="section-header"><a href="#panics-10">Panics</a></h5>
<p>Panics if this memory doesn’t belong to <code>store</code>.</p>
</div><div class="docblock scraped-example-list"><span></span><h5 id="scraped-examples-4" class="section-header"><a href="#scraped-examples-4">Examples found in repository</a></h5><div class="scraped-example " data-locs="[[[16,16],&quot;../../src/memory/memory.rs.html#28&quot;,&quot;line 28&quot;],[[43,43],&quot;../../src/memory/memory.rs.html#55&quot;,&quot;line 55&quot;],[[57,57],&quot;../../src/memory/memory.rs.html#69&quot;,&quot;line 69&quot;]]"><div class="scraped-example-title">examples/memory.rs (<a href="../../src/memory/memory.rs.html#28">line 28</a>)</div><div class="code-wrapper"><span class="prev">&pr;</span> <span class="next">&sc;</span><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
<span>57</span>
<span>58</span>
<span>59</span>
<span>60</span>
<span>61</span>
<span>62</span>
<span>63</span>
<span>64</span>
<span>65</span>
<span>66</span>
<span>67</span>
<span>68</span>
<span>69</span>
<span>70</span>
<span>71</span>
<span>72</span>
<span>73</span>
<span>74</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Create our `store_fn` context and then compile a module and create an</span>
  <span class="comment">// instance from the compiled module all in one go.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span>: <span class="ident">Store</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Store::default</span>();
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="ident">store</span>.<span class="ident">engine</span>(), <span class="string">&quot;examples/memory.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="comment">// load_fn up our exports from the instance</span>
  <span class="kw">let</span> <span class="ident">memory</span> <span class="op">=</span> <span class="ident">instance</span>
    .<span class="ident">get_memory</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;memory&quot;</span>)
    .<span class="ident">ok_or</span>(<span class="macro">anyhow::format_err!</span>(<span class="string">&quot;failed to find `memory` export&quot;</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">size</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;size&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">load_fn</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;load&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">store_fn</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;store&quot;</span>)<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Checking memory...&quot;</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="highlight focus"><span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x20000</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0</span>], <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1000</span>], <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">4</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">size</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1000</span>)<span class="question-mark">?</span>, <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1ffff</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">println!</span>(<span class="string">&quot;Mutating memory...&quot;</span>);
  <span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>] <span class="op">=</span> <span class="number">5</span>;

  <span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x1002</span>, <span class="number">6</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">5</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">5</span>);

  <span class="comment">// Grow memory.</span>
  <span class="macro">println!</span>(<span class="string">&quot;Growing memory...&quot;</span>);
  <span class="ident">memory</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>)<span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="highlight"><span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)</span>, <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x30000</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x30000</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x30000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>());

  <span class="macro">assert!</span>(<span class="ident">memory</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>).<span class="ident">is_ok</span>());

  <span class="macro">println!</span>(<span class="string">&quot;Creating stand-alone memory...&quot;</span>);
  <span class="kw">let</span> <span class="ident">memorytype</span> <span class="op">=</span> <span class="ident">MemoryType::new</span>(<span class="number">5</span>, <span class="prelude-val">Some</span>(<span class="number">5</span>));
  <span class="kw">let</span> <span class="ident">memory2</span> <span class="op">=</span> <span class="ident">Memory::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="ident">memorytype</span>)<span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory2</span>.<span class="highlight"><span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)</span>, <span class="number">5</span>);
  <span class="macro">assert!</span>(<span class="ident">memory2</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory2</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>).<span class="ident">is_ok</span>());

  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><details class="rustdoc-toggle more-examples-toggle"><summary class="hideme"><span>More examples</span></summary><div class="more-scraped-examples"><div class="toggle-line"><div class="toggle-line-inner"></div></div><div class="more-scraped-examples-inner"><div class="scraped-example " data-locs="[[[28,28],&quot;../../src/multimemory/multimemory.rs.html#40&quot;,&quot;line 40&quot;],[[45,45],&quot;../../src/multimemory/multimemory.rs.html#57&quot;,&quot;line 57&quot;],[[85,85],&quot;../../src/multimemory/multimemory.rs.html#97&quot;,&quot;line 97&quot;],[[97,97],&quot;../../src/multimemory/multimemory.rs.html#109&quot;,&quot;line 109&quot;]]"><div class="scraped-example-title">examples/multimemory.rs (<a href="../../src/multimemory/multimemory.rs.html#40">line 40</a>)</div><div class="code-wrapper"><span class="prev">&pr;</span> <span class="next">&sc;</span><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span> 12</span>
<span> 13</span>
<span> 14</span>
<span> 15</span>
<span> 16</span>
<span> 17</span>
<span> 18</span>
<span> 19</span>
<span> 20</span>
<span> 21</span>
<span> 22</span>
<span> 23</span>
<span> 24</span>
<span> 25</span>
<span> 26</span>
<span> 27</span>
<span> 28</span>
<span> 29</span>
<span> 30</span>
<span> 31</span>
<span> 32</span>
<span> 33</span>
<span> 34</span>
<span> 35</span>
<span> 36</span>
<span> 37</span>
<span> 38</span>
<span> 39</span>
<span> 40</span>
<span> 41</span>
<span> 42</span>
<span> 43</span>
<span> 44</span>
<span> 45</span>
<span> 46</span>
<span> 47</span>
<span> 48</span>
<span> 49</span>
<span> 50</span>
<span> 51</span>
<span> 52</span>
<span> 53</span>
<span> 54</span>
<span> 55</span>
<span> 56</span>
<span> 57</span>
<span> 58</span>
<span> 59</span>
<span> 60</span>
<span> 61</span>
<span> 62</span>
<span> 63</span>
<span> 64</span>
<span> 65</span>
<span> 66</span>
<span> 67</span>
<span> 68</span>
<span> 69</span>
<span> 70</span>
<span> 71</span>
<span> 72</span>
<span> 73</span>
<span> 74</span>
<span> 75</span>
<span> 76</span>
<span> 77</span>
<span> 78</span>
<span> 79</span>
<span> 80</span>
<span> 81</span>
<span> 82</span>
<span> 83</span>
<span> 84</span>
<span> 85</span>
<span> 86</span>
<span> 87</span>
<span> 88</span>
<span> 89</span>
<span> 90</span>
<span> 91</span>
<span> 92</span>
<span> 93</span>
<span> 94</span>
<span> 95</span>
<span> 96</span>
<span> 97</span>
<span> 98</span>
<span> 99</span>
<span>100</span>
<span>101</span>
<span>102</span>
<span>103</span>
<span>104</span>
<span>105</span>
<span>106</span>
<span>107</span>
<span>108</span>
<span>109</span>
<span>110</span>
<span>111</span>
<span>112</span>
<span>113</span>
<span>114</span>
<span>115</span>
<span>116</span>
<span>117</span>
<span>118</span>
<span>119</span>
<span>120</span>
<span>121</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Enable the multi-memory feature.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">config</span> <span class="op">=</span> <span class="ident">Config::new</span>();
  <span class="ident">config</span>.<span class="ident">wasm_multi_memory</span>(<span class="bool-val">true</span>);

  <span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>(<span class="kw-2">&amp;</span><span class="ident">config</span>)<span class="question-mark">?</span>;

  <span class="comment">// Create our `store_fn` context and then compile a module and create an</span>
  <span class="comment">// instance from the compiled module all in one go.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ());
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="ident">store</span>.<span class="ident">engine</span>(), <span class="string">&quot;examples/multimemory.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="kw">let</span> <span class="ident">memory0</span> <span class="op">=</span> <span class="ident">instance</span>
    .<span class="ident">get_memory</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;memory0&quot;</span>)
    .<span class="ident">ok_or</span>(<span class="macro">anyhow::format_err!</span>(<span class="string">&quot;failed to find `memory0` export&quot;</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">size0</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;size0&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">load0</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;load0&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">store0</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;store0&quot;</span>)<span class="question-mark">?</span>;

  <span class="kw">let</span> <span class="ident">memory1</span> <span class="op">=</span> <span class="ident">instance</span>
    .<span class="ident">get_memory</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;memory1&quot;</span>)
    .<span class="ident">ok_or</span>(<span class="macro">anyhow::format_err!</span>(<span class="string">&quot;failed to find `memory1` export&quot;</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">size1</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;size1&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">load1</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;load1&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">store1</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;store1&quot;</span>)<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Checking memory...&quot;</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="highlight focus"><span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x20000</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0</span>], <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1000</span>], <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1001</span>], <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">4</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">size0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1000</span>)<span class="question-mark">?</span>, <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1001</span>)<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1ffff</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="highlight"><span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x20000</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0</span>], <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1000</span>], <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1001</span>], <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">1</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">size1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1000</span>)<span class="question-mark">?</span>, <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1001</span>)<span class="question-mark">?</span>, <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1ffff</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">println!</span>(<span class="string">&quot;Mutating memory...&quot;</span>);
  <span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>] <span class="op">=</span> <span class="number">5</span>;

  <span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x1002</span>, <span class="number">6</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">5</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">5</span>);

  <span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>] <span class="op">=</span> <span class="number">7</span>;

  <span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x1002</span>, <span class="number">8</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">8</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">7</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">8</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">7</span>);

  <span class="macro">println!</span>(<span class="string">&quot;Growing memory...&quot;</span>);
  <span class="ident">memory0</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>)<span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="highlight"><span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)</span>, <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x30000</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x30000</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x30000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>());

  <span class="macro">assert!</span>(<span class="ident">memory0</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory0</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>).<span class="ident">is_ok</span>());

  <span class="ident">memory1</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">2</span>)<span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="highlight"><span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)</span>, <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x40000</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x30000</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x30000</span>, <span class="number">0</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x40000</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x40000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>());

  <span class="macro">assert!</span>(<span class="ident">memory1</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory1</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>).<span class="ident">is_ok</span>());

  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div></div></div></details></div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.grow" class="method has-srclink"><div class="rightside"></div><a href="#method.grow" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.grow" class="fnname">grow</a>(&amp;self, store: impl <a class="trait" href="trait.AsContextMut.html" title="trait wiggle::wasmtime_crate::AsContextMut">AsContextMut</a>, delta: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>, <a class="struct" href="https://docs.rs/anyhow/1.0.40/anyhow/struct.Error.html" title="struct anyhow::Error">Error</a>&gt;</h4></div></summary><div class="docblock"><p>Grows this WebAssembly memory by <code>delta</code> pages.</p>
<p>This will attempt to add <code>delta</code> more pages of memory on to the end of
this <code>Memory</code> instance. If successful this may relocate the memory and
cause <a href="struct.Memory.html#method.data_ptr" title="Memory::data_ptr"><code>Memory::data_ptr</code></a> to return a new value. Additionally any
unsafetly constructed slices into this memory may no longer be valid.</p>
<p>On success returns the number of pages this memory previously had
before the growth succeeded.</p>
<h5 id="errors" class="section-header"><a href="#errors">Errors</a></h5>
<p>Returns an error if memory could not be grown, for example if it exceeds
the maximum limits of this memory. A
<a href="trait.ResourceLimiter.html"><code>ResourceLimiter</code></a> is another example of
preventing a memory to grow.</p>
<h5 id="panics-11" class="section-header"><a href="#panics-11">Panics</a></h5>
<p>Panics if this memory doesn’t belong to <code>store</code>.</p>
<p>This function will panic if the <a href="struct.Store.html"><code>Store</code></a> has a
<a href="trait.ResourceLimiterAsync.html"><code>ResourceLimiterAsync</code></a> (see also:
<a href="struct.Store.html#method.limiter_async"><code>Store::limiter_async</code></a>. When using an
async resource limiter, use <a href="struct.Memory.html#method.grow_async" title="Memory::grow_async"><code>Memory::grow_async</code></a> instead.</p>
<h5 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::default</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ());
<span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, <span class="string">&quot;(module (memory (export \&quot;mem\&quot;) 1 2))&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">memory</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_memory</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;mem&quot;</span>).<span class="ident">unwrap</span>();

<span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>)<span class="question-mark">?</span>, <span class="number">1</span>);
<span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">2</span>);
<span class="macro">assert!</span>(<span class="ident">memory</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>).<span class="ident">is_err</span>());
<span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)<span class="question-mark">?</span>, <span class="number">2</span>);</code></pre></div>
</div><div class="docblock scraped-example-list"><span></span><h5 id="scraped-examples-5" class="section-header"><a href="#scraped-examples-5">Examples found in repository</a></h5><div class="scraped-example " data-locs="[[[42,42],&quot;../../src/memory/memory.rs.html#54&quot;,&quot;line 54&quot;],[[51,51],&quot;../../src/memory/memory.rs.html#63&quot;,&quot;line 63&quot;],[[52,52],&quot;../../src/memory/memory.rs.html#64&quot;,&quot;line 64&quot;],[[58,58],&quot;../../src/memory/memory.rs.html#70&quot;,&quot;line 70&quot;],[[59,59],&quot;../../src/memory/memory.rs.html#71&quot;,&quot;line 71&quot;]]"><div class="scraped-example-title">examples/memory.rs (<a href="../../src/memory/memory.rs.html#54">line 54</a>)</div><div class="code-wrapper"><span class="prev">&pr;</span> <span class="next">&sc;</span><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
<span>57</span>
<span>58</span>
<span>59</span>
<span>60</span>
<span>61</span>
<span>62</span>
<span>63</span>
<span>64</span>
<span>65</span>
<span>66</span>
<span>67</span>
<span>68</span>
<span>69</span>
<span>70</span>
<span>71</span>
<span>72</span>
<span>73</span>
<span>74</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Create our `store_fn` context and then compile a module and create an</span>
  <span class="comment">// instance from the compiled module all in one go.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span>: <span class="ident">Store</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Store::default</span>();
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="ident">store</span>.<span class="ident">engine</span>(), <span class="string">&quot;examples/memory.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="comment">// load_fn up our exports from the instance</span>
  <span class="kw">let</span> <span class="ident">memory</span> <span class="op">=</span> <span class="ident">instance</span>
    .<span class="ident">get_memory</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;memory&quot;</span>)
    .<span class="ident">ok_or</span>(<span class="macro">anyhow::format_err!</span>(<span class="string">&quot;failed to find `memory` export&quot;</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">size</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;size&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">load_fn</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;load&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">store_fn</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;store&quot;</span>)<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Checking memory...&quot;</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x20000</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0</span>], <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1000</span>], <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">4</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">size</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1000</span>)<span class="question-mark">?</span>, <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1ffff</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">println!</span>(<span class="string">&quot;Mutating memory...&quot;</span>);
  <span class="ident">memory</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>] <span class="op">=</span> <span class="number">5</span>;

  <span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x1002</span>, <span class="number">6</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">5</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">5</span>);

  <span class="comment">// Grow memory.</span>
  <span class="macro">println!</span>(<span class="string">&quot;Growing memory...&quot;</span>);
  <span class="ident">memory</span>.<span class="highlight focus"><span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>)</span><span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x30000</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">load_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x30000</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">store_fn</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x30000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>());

  <span class="macro">assert!</span>(<span class="ident">memory</span>.<span class="highlight"><span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>)</span>.<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory</span>.<span class="highlight"><span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)</span>.<span class="ident">is_ok</span>());

  <span class="macro">println!</span>(<span class="string">&quot;Creating stand-alone memory...&quot;</span>);
  <span class="kw">let</span> <span class="ident">memorytype</span> <span class="op">=</span> <span class="ident">MemoryType::new</span>(<span class="number">5</span>, <span class="prelude-val">Some</span>(<span class="number">5</span>));
  <span class="kw">let</span> <span class="ident">memory2</span> <span class="op">=</span> <span class="ident">Memory::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="ident">memorytype</span>)<span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory2</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">5</span>);
  <span class="macro">assert!</span>(<span class="ident">memory2</span>.<span class="highlight"><span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>)</span>.<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory2</span>.<span class="highlight"><span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)</span>.<span class="ident">is_ok</span>());

  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div><details class="rustdoc-toggle more-examples-toggle"><summary class="hideme"><span>More examples</span></summary><div class="more-scraped-examples"><div class="toggle-line"><div class="toggle-line-inner"></div></div><div class="more-scraped-examples-inner"><div class="scraped-example " data-locs="[[[84,84],&quot;../../src/multimemory/multimemory.rs.html#96&quot;,&quot;line 96&quot;],[[93,93],&quot;../../src/multimemory/multimemory.rs.html#105&quot;,&quot;line 105&quot;],[[94,94],&quot;../../src/multimemory/multimemory.rs.html#106&quot;,&quot;line 106&quot;],[[96,96],&quot;../../src/multimemory/multimemory.rs.html#108&quot;,&quot;line 108&quot;],[[105,105],&quot;../../src/multimemory/multimemory.rs.html#117&quot;,&quot;line 117&quot;],[[106,106],&quot;../../src/multimemory/multimemory.rs.html#118&quot;,&quot;line 118&quot;]]"><div class="scraped-example-title">examples/multimemory.rs (<a href="../../src/multimemory/multimemory.rs.html#96">line 96</a>)</div><div class="code-wrapper"><span class="prev">&pr;</span> <span class="next">&sc;</span><span class="expand">&varr;</span><div class="example-wrap"><pre class="line-numbers"><span> 12</span>
<span> 13</span>
<span> 14</span>
<span> 15</span>
<span> 16</span>
<span> 17</span>
<span> 18</span>
<span> 19</span>
<span> 20</span>
<span> 21</span>
<span> 22</span>
<span> 23</span>
<span> 24</span>
<span> 25</span>
<span> 26</span>
<span> 27</span>
<span> 28</span>
<span> 29</span>
<span> 30</span>
<span> 31</span>
<span> 32</span>
<span> 33</span>
<span> 34</span>
<span> 35</span>
<span> 36</span>
<span> 37</span>
<span> 38</span>
<span> 39</span>
<span> 40</span>
<span> 41</span>
<span> 42</span>
<span> 43</span>
<span> 44</span>
<span> 45</span>
<span> 46</span>
<span> 47</span>
<span> 48</span>
<span> 49</span>
<span> 50</span>
<span> 51</span>
<span> 52</span>
<span> 53</span>
<span> 54</span>
<span> 55</span>
<span> 56</span>
<span> 57</span>
<span> 58</span>
<span> 59</span>
<span> 60</span>
<span> 61</span>
<span> 62</span>
<span> 63</span>
<span> 64</span>
<span> 65</span>
<span> 66</span>
<span> 67</span>
<span> 68</span>
<span> 69</span>
<span> 70</span>
<span> 71</span>
<span> 72</span>
<span> 73</span>
<span> 74</span>
<span> 75</span>
<span> 76</span>
<span> 77</span>
<span> 78</span>
<span> 79</span>
<span> 80</span>
<span> 81</span>
<span> 82</span>
<span> 83</span>
<span> 84</span>
<span> 85</span>
<span> 86</span>
<span> 87</span>
<span> 88</span>
<span> 89</span>
<span> 90</span>
<span> 91</span>
<span> 92</span>
<span> 93</span>
<span> 94</span>
<span> 95</span>
<span> 96</span>
<span> 97</span>
<span> 98</span>
<span> 99</span>
<span>100</span>
<span>101</span>
<span>102</span>
<span>103</span>
<span>104</span>
<span>105</span>
<span>106</span>
<span>107</span>
<span>108</span>
<span>109</span>
<span>110</span>
<span>111</span>
<span>112</span>
<span>113</span>
<span>114</span>
<span>115</span>
<span>116</span>
<span>117</span>
<span>118</span>
<span>119</span>
<span>120</span>
<span>121</span>
</pre><pre class="rust"><code><span class="kw">fn</span> <span class="ident">main</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">// Enable the multi-memory feature.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">config</span> <span class="op">=</span> <span class="ident">Config::new</span>();
  <span class="ident">config</span>.<span class="ident">wasm_multi_memory</span>(<span class="bool-val">true</span>);

  <span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>(<span class="kw-2">&amp;</span><span class="ident">config</span>)<span class="question-mark">?</span>;

  <span class="comment">// Create our `store_fn` context and then compile a module and create an</span>
  <span class="comment">// instance from the compiled module all in one go.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, ());
  <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::from_file</span>(<span class="ident">store</span>.<span class="ident">engine</span>(), <span class="string">&quot;examples/multimemory.wat&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;

  <span class="kw">let</span> <span class="ident">memory0</span> <span class="op">=</span> <span class="ident">instance</span>
    .<span class="ident">get_memory</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;memory0&quot;</span>)
    .<span class="ident">ok_or</span>(<span class="macro">anyhow::format_err!</span>(<span class="string">&quot;failed to find `memory0` export&quot;</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">size0</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;size0&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">load0</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;load0&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">store0</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;store0&quot;</span>)<span class="question-mark">?</span>;

  <span class="kw">let</span> <span class="ident">memory1</span> <span class="op">=</span> <span class="ident">instance</span>
    .<span class="ident">get_memory</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;memory1&quot;</span>)
    .<span class="ident">ok_or</span>(<span class="macro">anyhow::format_err!</span>(<span class="string">&quot;failed to find `memory1` export&quot;</span>))<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">size1</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(), <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;size1&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">load1</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span>, <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;load1&quot;</span>)<span class="question-mark">?</span>;
  <span class="kw">let</span> <span class="ident">store1</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_typed_func</span>::<span class="op">&lt;</span>(<span class="ident">i32</span>, <span class="ident">i32</span>), (), <span class="kw">_</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="string">&quot;store1&quot;</span>)<span class="question-mark">?</span>;

  <span class="macro">println!</span>(<span class="string">&quot;Checking memory...&quot;</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x20000</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0</span>], <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1000</span>], <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1001</span>], <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">4</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">size0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1000</span>)<span class="question-mark">?</span>, <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1001</span>)<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1ffff</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x20000</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0</span>], <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1000</span>], <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1001</span>], <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">1</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">size1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, ())<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1000</span>)<span class="question-mark">?</span>, <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1001</span>)<span class="question-mark">?</span>, <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">2</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">1</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1ffff</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="macro">assert!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">println!</span>(<span class="string">&quot;Mutating memory...&quot;</span>);
  <span class="ident">memory0</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>] <span class="op">=</span> <span class="number">5</span>;

  <span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x1002</span>, <span class="number">6</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">5</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">6</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">5</span>);

  <span class="ident">memory1</span>.<span class="ident">data_mut</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>)[<span class="number">0x1003</span>] <span class="op">=</span> <span class="number">7</span>;

  <span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x1002</span>, <span class="number">8</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>()); <span class="comment">// out of bounds trap</span>

  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1002</span>], <span class="number">8</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>)[<span class="number">0x1003</span>], <span class="number">7</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1002</span>)<span class="question-mark">?</span>, <span class="number">8</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x1003</span>)<span class="question-mark">?</span>, <span class="number">7</span>);

  <span class="macro">println!</span>(<span class="string">&quot;Growing memory...&quot;</span>);
  <span class="ident">memory0</span>.<span class="highlight focus"><span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>)</span><span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">3</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory0</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x30000</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x20000</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x20000</span>, <span class="number">0</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">load0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x30000</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">store0</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x30000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>());

  <span class="macro">assert!</span>(<span class="ident">memory0</span>.<span class="highlight"><span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>)</span>.<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory0</span>.<span class="highlight"><span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)</span>.<span class="ident">is_ok</span>());

  <span class="ident">memory1</span>.<span class="highlight"><span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">2</span>)</span><span class="question-mark">?</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">4</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">memory1</span>.<span class="ident">data_size</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>), <span class="number">0x40000</span>);

  <span class="macro">assert_eq!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x30000</span>)<span class="question-mark">?</span>, <span class="number">0</span>);
  <span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x30000</span>, <span class="number">0</span>))<span class="question-mark">?</span>;
  <span class="macro">assert!</span>(<span class="ident">load1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0x40000</span>).<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">store1</span>.<span class="ident">call</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, (<span class="number">0x40000</span>, <span class="number">0</span>)).<span class="ident">is_err</span>());

  <span class="macro">assert!</span>(<span class="ident">memory1</span>.<span class="highlight"><span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">1</span>)</span>.<span class="ident">is_err</span>());
  <span class="macro">assert!</span>(<span class="ident">memory1</span>.<span class="highlight"><span class="ident">grow</span>(<span class="kw-2">&amp;mut</span> <span class="ident">store</span>, <span class="number">0</span>)</span>.<span class="ident">is_ok</span>());

  <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></div></div></div></details></div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.grow_async" class="method has-srclink"><div class="rightside"></div><a href="#method.grow_async" class="anchor"></a><h4 class="code-header">pub async fn <a href="#method.grow_async" class="fnname">grow_async</a>&lt;T&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'_ self, <br>&nbsp;&nbsp;&nbsp;&nbsp;store: impl <a class="trait" href="trait.AsContextMut.html" title="trait wiggle::wasmtime_crate::AsContextMut">AsContextMut</a>&lt;Data = T&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;delta: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>, <a class="struct" href="https://docs.rs/anyhow/1.0.40/anyhow/struct.Error.html" title="struct anyhow::Error">Error</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,&nbsp;</span></h4></div></summary><div class="docblock"><p>Async variant of <a href="struct.Memory.html#method.grow" title="Memory::grow"><code>Memory::grow</code></a>. Required when using a
<a href="trait.ResourceLimiterAsync.html"><code>ResourceLimiterAsync</code></a>.</p>
<h5 id="panics-12" class="section-header"><a href="#panics-12">Panics</a></h5>
<p>This function will panic when used with a non-async
<a href="struct.Store.html"><code>Store</code></a>.</p>
</div></details></div></details><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Clone" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Clone" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Memory.html" title="struct wiggle::wasmtime_crate::Memory">Memory</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.clone" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Memory.html" title="struct wiggle::wasmtime_crate::Memory">Memory</a></h4></div></summary><div class='docblock'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone_from" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#131" title="goto source code">[src]</a></div><a href="#method.clone_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self)</h4></div></summary><div class='docblock'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Debug" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Debug" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Memory.html" title="struct wiggle::wasmtime_crate::Memory">Memory</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.fmt" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.fmt" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-From%3CMemory%3E" class="impl has-srclink"><div class="rightside"></div><a href="#impl-From%3CMemory%3E" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Memory.html" title="struct wiggle::wasmtime_crate::Memory">Memory</a>&gt; for <a class="enum" href="enum.Extern.html" title="enum wiggle::wasmtime_crate::Extern">Extern</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.from" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(r: <a class="struct" href="struct.Memory.html" title="struct wiggle::wasmtime_crate::Memory">Memory</a>) -&gt; <a class="enum" href="enum.Extern.html" title="enum wiggle::wasmtime_crate::Extern">Extern</a></h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><div id="impl-Copy" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Copy" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="struct" href="struct.Memory.html" title="struct wiggle::wasmtime_crate::Memory">Memory</a></h3></div></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><div id="impl-RefUnwindSafe" class="impl has-srclink"><div class="rightside"></div><a href="#impl-RefUnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Memory.html" title="struct wiggle::wasmtime_crate::Memory">Memory</a></h3></div><div id="impl-Send" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Send" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Memory.html" title="struct wiggle::wasmtime_crate::Memory">Memory</a></h3></div><div id="impl-Sync" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Sync" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Memory.html" title="struct wiggle::wasmtime_crate::Memory">Memory</a></h3></div><div id="impl-Unpin" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Unpin" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Memory.html" title="struct wiggle::wasmtime_crate::Memory">Memory</a></h3></div><div id="impl-UnwindSafe" class="impl has-srclink"><div class="rightside"></div><a href="#impl-UnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Memory.html" title="struct wiggle::wasmtime_crate::Memory">Memory</a></h3></div></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Any" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#132-136" title="goto source code">[src]</a></div><a href="#impl-Any" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.type_id" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#133" title="goto source code">[src]</a></div><a href="#method.type_id" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></div></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Borrow%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#208-213" title="goto source code">[src]</a></div><a href="#impl-Borrow%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#210" title="goto source code">[src]</a></div><a href="#method.borrow" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</h4></div></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#216-220" title="goto source code">[src]</a></div><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow_mut" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217" title="goto source code">[src]</a></div><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</h4></div></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-From%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#549-553" title="goto source code">[src]</a></div><a href="#impl-From%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#550" title="goto source code">[src]</a></div><a href="#method.from-1" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Instrument" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://docs.rs/tracing/0.1.26/src/tracing/instrument.rs.html#155" title="goto source code">[src]</a></div><a href="#impl-Instrument" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://docs.rs/tracing/0.1.26/tracing/instrument/trait.Instrument.html" title="trait tracing::instrument::Instrument">Instrument</a> for T</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.instrument" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://docs.rs/tracing/0.1.26/src/tracing/instrument.rs.html#38" title="goto source code">[src]</a></div><a href="#method.instrument" class="anchor"></a><h4 class="code-header">fn <a href="https://docs.rs/tracing/0.1.26/tracing/instrument/trait.Instrument.html#method.instrument" class="fnname">instrument</a>(self, span: <a class="struct" href="https://docs.rs/tracing/0.1.26/tracing/span/struct.Span.html" title="struct tracing::span::Span">Span</a>) -&gt; <a class="struct" href="https://docs.rs/tracing/0.1.26/tracing/instrument/struct.Instrumented.html" title="struct tracing::instrument::Instrumented">Instrumented</a>&lt;Self&gt;</h4></div></summary><div class='docblock'><p>Instruments this type with the provided <code>Span</code>, returning an
<code>Instrumented</code> wrapper. <a href="https://docs.rs/tracing/0.1.26/tracing/instrument/trait.Instrument.html#method.instrument">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.in_current_span" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://docs.rs/tracing/0.1.26/src/tracing/instrument.rs.html#74" title="goto source code">[src]</a></div><a href="#method.in_current_span" class="anchor"></a><h4 class="code-header">fn <a href="https://docs.rs/tracing/0.1.26/tracing/instrument/trait.Instrument.html#method.in_current_span" class="fnname">in_current_span</a>(self) -&gt; <a class="struct" href="https://docs.rs/tracing/0.1.26/tracing/instrument/struct.Instrumented.html" title="struct tracing::instrument::Instrumented">Instrumented</a>&lt;Self&gt;</h4></div></summary><div class='docblock'><p>Instruments this type with the <a href="../struct.Span.html#method.current">current</a> <code>Span</code>, returning an
<code>Instrumented</code> wrapper. <a href="https://docs.rs/tracing/0.1.26/tracing/instrument/trait.Instrument.html#method.in_current_span">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Into%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#537-544" title="goto source code">[src]</a></div><a href="#impl-Into%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.into" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#541" title="goto source code">[src]</a></div><a href="#method.into" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Pointable" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Pointable" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; Pointable for T</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedconstant.ALIGN" class="associatedconstant trait-impl has-srclink"><div class="rightside"></div><a href="#associatedconstant.ALIGN" class="anchor"></a><h4 class="code-header">pub const <a href="#associatedconstant.ALIGN" class="constant">ALIGN</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></div></summary><div class='docblock'><p>The alignment of pointer.</p>
</div></details><details class="rustdoc-toggle" open><summary><div id="associatedtype.Init" class="type trait-impl has-srclink"><a href="#associatedtype.Init" class="anchor"></a><h4 class="code-header">type <a href="#associatedtype.Init" class="type">Init</a> = T</h4></div></summary><div class='docblock'><p>The type for initializers.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.init" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.init" class="anchor"></a><h4 class="code-header">pub unsafe fn <a  class="fnname">init</a>(init: &lt;T as Pointable&gt;::Init) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></div></summary><div class='docblock'><p>Initializes a with the given initializer. <a href="#tymethod.init">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.deref" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.deref" class="anchor"></a><h4 class="code-header">pub unsafe fn <a  class="fnname">deref</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T</h4></div></summary><div class='docblock'><p>Dereferences the given pointer. <a href="#tymethod.deref">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.deref_mut" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.deref_mut" class="anchor"></a><h4 class="code-header">pub unsafe fn <a  class="fnname">deref_mut</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a mut </a>T</h4></div></summary><div class='docblock'><p>Mutably dereferences the given pointer. <a href="#tymethod.deref_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.drop" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.drop" class="anchor"></a><h4 class="code-header">pub unsafe fn <a  class="fnname">drop</a>(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></div></summary><div class='docblock'><p>Drops the object pointed to by the given pointer. <a href="#tymethod.drop">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Pointee" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/wiggle/lib.rs.html#898-903" title="goto source code">[src]</a></div><a href="#impl-Pointee" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../trait.Pointee.html" title="trait wiggle::Pointee">Pointee</a> for T</h3></div></summary><div class="impl-items"><div id="associatedtype.Pointer" class="type trait-impl has-srclink"><a href="#associatedtype.Pointer" class="anchor"></a><h4 class="code-header">type <a href="../trait.Pointee.html#associatedtype.Pointer" class="type">Pointer</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></h4></div><div id="method.debug" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../../src/wiggle/lib.rs.html#900-902" title="goto source code">[src]</a></div><a href="#method.debug" class="anchor"></a><h4 class="code-header">pub fn <a href="../trait.Pointee.html#tymethod.debug" class="fnname">debug</a>(&lt;T as <a class="trait" href="../trait.Pointee.html" title="trait wiggle::Pointee">Pointee</a>&gt;::<a class="type" href="../trait.Pointee.html#associatedtype.Pointer" title="type wiggle::Pointee::Pointer">Pointer</a>, &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></div></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Same%3CT%3E" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Same%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; Same&lt;T&gt; for T</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Output" class="type trait-impl has-srclink"><a href="#associatedtype.Output" class="anchor"></a><h4 class="code-header">type <a href="#associatedtype.Output" class="type">Output</a> = T</h4></div></summary><div class='docblock'><p>Should always be <code>Self</code></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-ToOwned" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#84-96" title="goto source code">[src]</a></div><a href="#impl-ToOwned" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Owned" class="type trait-impl has-srclink"><a href="#associatedtype.Owned" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="type">Owned</a> = T</h4></div></summary><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.to_owned" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#89" title="goto source code">[src]</a></div><a href="#method.to_owned" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4></div></summary><div class='docblock'><p>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone_into" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#93" title="goto source code">[src]</a></div><a href="#method.clone_into" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T)</h4></div></summary><div class="item-info"><div class="stab unstable"><details><summary><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>)</summary><p>recently added</p>
</details></div></div><div class='docblock'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-TryFrom%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#587-596" title="goto source code">[src]</a></div><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Error" class="type trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.try_from" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#593" title="goto source code">[src]</a></div><a href="#method.try_from" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-TryInto%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#573-582" title="goto source code">[src]</a></div><a href="#impl-TryInto%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Error-1" class="type trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.try_into" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#579" title="goto source code">[src]</a></div><a href="#method.try_into" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-VZip%3CV%3E" class="impl has-srclink"><div class="rightside"></div><a href="#impl-VZip%3CV%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;V, T&gt; VZip&lt;V&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;V: MultiLane&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><div id="method.vzip" class="method trait-impl has-srclink"><div class="rightside"></div><a href="#method.vzip" class="anchor"></a><h4 class="code-header">pub fn <a  class="fnname">vzip</a>(self) -&gt; V</h4></div></div></details></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="wiggle" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div>
    <script src="../../main.js"></script><script src="../../scrape-examples.js"></script>
</body></html>