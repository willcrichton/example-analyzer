<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `cranelift&#x2F;codegen&#x2F;meta&#x2F;src&#x2F;gen_inst.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>gen_inst.rs - source</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../cranelift_codegen_meta/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">   1</span>
<span id="2">   2</span>
<span id="3">   3</span>
<span id="4">   4</span>
<span id="5">   5</span>
<span id="6">   6</span>
<span id="7">   7</span>
<span id="8">   8</span>
<span id="9">   9</span>
<span id="10">  10</span>
<span id="11">  11</span>
<span id="12">  12</span>
<span id="13">  13</span>
<span id="14">  14</span>
<span id="15">  15</span>
<span id="16">  16</span>
<span id="17">  17</span>
<span id="18">  18</span>
<span id="19">  19</span>
<span id="20">  20</span>
<span id="21">  21</span>
<span id="22">  22</span>
<span id="23">  23</span>
<span id="24">  24</span>
<span id="25">  25</span>
<span id="26">  26</span>
<span id="27">  27</span>
<span id="28">  28</span>
<span id="29">  29</span>
<span id="30">  30</span>
<span id="31">  31</span>
<span id="32">  32</span>
<span id="33">  33</span>
<span id="34">  34</span>
<span id="35">  35</span>
<span id="36">  36</span>
<span id="37">  37</span>
<span id="38">  38</span>
<span id="39">  39</span>
<span id="40">  40</span>
<span id="41">  41</span>
<span id="42">  42</span>
<span id="43">  43</span>
<span id="44">  44</span>
<span id="45">  45</span>
<span id="46">  46</span>
<span id="47">  47</span>
<span id="48">  48</span>
<span id="49">  49</span>
<span id="50">  50</span>
<span id="51">  51</span>
<span id="52">  52</span>
<span id="53">  53</span>
<span id="54">  54</span>
<span id="55">  55</span>
<span id="56">  56</span>
<span id="57">  57</span>
<span id="58">  58</span>
<span id="59">  59</span>
<span id="60">  60</span>
<span id="61">  61</span>
<span id="62">  62</span>
<span id="63">  63</span>
<span id="64">  64</span>
<span id="65">  65</span>
<span id="66">  66</span>
<span id="67">  67</span>
<span id="68">  68</span>
<span id="69">  69</span>
<span id="70">  70</span>
<span id="71">  71</span>
<span id="72">  72</span>
<span id="73">  73</span>
<span id="74">  74</span>
<span id="75">  75</span>
<span id="76">  76</span>
<span id="77">  77</span>
<span id="78">  78</span>
<span id="79">  79</span>
<span id="80">  80</span>
<span id="81">  81</span>
<span id="82">  82</span>
<span id="83">  83</span>
<span id="84">  84</span>
<span id="85">  85</span>
<span id="86">  86</span>
<span id="87">  87</span>
<span id="88">  88</span>
<span id="89">  89</span>
<span id="90">  90</span>
<span id="91">  91</span>
<span id="92">  92</span>
<span id="93">  93</span>
<span id="94">  94</span>
<span id="95">  95</span>
<span id="96">  96</span>
<span id="97">  97</span>
<span id="98">  98</span>
<span id="99">  99</span>
<span id="100"> 100</span>
<span id="101"> 101</span>
<span id="102"> 102</span>
<span id="103"> 103</span>
<span id="104"> 104</span>
<span id="105"> 105</span>
<span id="106"> 106</span>
<span id="107"> 107</span>
<span id="108"> 108</span>
<span id="109"> 109</span>
<span id="110"> 110</span>
<span id="111"> 111</span>
<span id="112"> 112</span>
<span id="113"> 113</span>
<span id="114"> 114</span>
<span id="115"> 115</span>
<span id="116"> 116</span>
<span id="117"> 117</span>
<span id="118"> 118</span>
<span id="119"> 119</span>
<span id="120"> 120</span>
<span id="121"> 121</span>
<span id="122"> 122</span>
<span id="123"> 123</span>
<span id="124"> 124</span>
<span id="125"> 125</span>
<span id="126"> 126</span>
<span id="127"> 127</span>
<span id="128"> 128</span>
<span id="129"> 129</span>
<span id="130"> 130</span>
<span id="131"> 131</span>
<span id="132"> 132</span>
<span id="133"> 133</span>
<span id="134"> 134</span>
<span id="135"> 135</span>
<span id="136"> 136</span>
<span id="137"> 137</span>
<span id="138"> 138</span>
<span id="139"> 139</span>
<span id="140"> 140</span>
<span id="141"> 141</span>
<span id="142"> 142</span>
<span id="143"> 143</span>
<span id="144"> 144</span>
<span id="145"> 145</span>
<span id="146"> 146</span>
<span id="147"> 147</span>
<span id="148"> 148</span>
<span id="149"> 149</span>
<span id="150"> 150</span>
<span id="151"> 151</span>
<span id="152"> 152</span>
<span id="153"> 153</span>
<span id="154"> 154</span>
<span id="155"> 155</span>
<span id="156"> 156</span>
<span id="157"> 157</span>
<span id="158"> 158</span>
<span id="159"> 159</span>
<span id="160"> 160</span>
<span id="161"> 161</span>
<span id="162"> 162</span>
<span id="163"> 163</span>
<span id="164"> 164</span>
<span id="165"> 165</span>
<span id="166"> 166</span>
<span id="167"> 167</span>
<span id="168"> 168</span>
<span id="169"> 169</span>
<span id="170"> 170</span>
<span id="171"> 171</span>
<span id="172"> 172</span>
<span id="173"> 173</span>
<span id="174"> 174</span>
<span id="175"> 175</span>
<span id="176"> 176</span>
<span id="177"> 177</span>
<span id="178"> 178</span>
<span id="179"> 179</span>
<span id="180"> 180</span>
<span id="181"> 181</span>
<span id="182"> 182</span>
<span id="183"> 183</span>
<span id="184"> 184</span>
<span id="185"> 185</span>
<span id="186"> 186</span>
<span id="187"> 187</span>
<span id="188"> 188</span>
<span id="189"> 189</span>
<span id="190"> 190</span>
<span id="191"> 191</span>
<span id="192"> 192</span>
<span id="193"> 193</span>
<span id="194"> 194</span>
<span id="195"> 195</span>
<span id="196"> 196</span>
<span id="197"> 197</span>
<span id="198"> 198</span>
<span id="199"> 199</span>
<span id="200"> 200</span>
<span id="201"> 201</span>
<span id="202"> 202</span>
<span id="203"> 203</span>
<span id="204"> 204</span>
<span id="205"> 205</span>
<span id="206"> 206</span>
<span id="207"> 207</span>
<span id="208"> 208</span>
<span id="209"> 209</span>
<span id="210"> 210</span>
<span id="211"> 211</span>
<span id="212"> 212</span>
<span id="213"> 213</span>
<span id="214"> 214</span>
<span id="215"> 215</span>
<span id="216"> 216</span>
<span id="217"> 217</span>
<span id="218"> 218</span>
<span id="219"> 219</span>
<span id="220"> 220</span>
<span id="221"> 221</span>
<span id="222"> 222</span>
<span id="223"> 223</span>
<span id="224"> 224</span>
<span id="225"> 225</span>
<span id="226"> 226</span>
<span id="227"> 227</span>
<span id="228"> 228</span>
<span id="229"> 229</span>
<span id="230"> 230</span>
<span id="231"> 231</span>
<span id="232"> 232</span>
<span id="233"> 233</span>
<span id="234"> 234</span>
<span id="235"> 235</span>
<span id="236"> 236</span>
<span id="237"> 237</span>
<span id="238"> 238</span>
<span id="239"> 239</span>
<span id="240"> 240</span>
<span id="241"> 241</span>
<span id="242"> 242</span>
<span id="243"> 243</span>
<span id="244"> 244</span>
<span id="245"> 245</span>
<span id="246"> 246</span>
<span id="247"> 247</span>
<span id="248"> 248</span>
<span id="249"> 249</span>
<span id="250"> 250</span>
<span id="251"> 251</span>
<span id="252"> 252</span>
<span id="253"> 253</span>
<span id="254"> 254</span>
<span id="255"> 255</span>
<span id="256"> 256</span>
<span id="257"> 257</span>
<span id="258"> 258</span>
<span id="259"> 259</span>
<span id="260"> 260</span>
<span id="261"> 261</span>
<span id="262"> 262</span>
<span id="263"> 263</span>
<span id="264"> 264</span>
<span id="265"> 265</span>
<span id="266"> 266</span>
<span id="267"> 267</span>
<span id="268"> 268</span>
<span id="269"> 269</span>
<span id="270"> 270</span>
<span id="271"> 271</span>
<span id="272"> 272</span>
<span id="273"> 273</span>
<span id="274"> 274</span>
<span id="275"> 275</span>
<span id="276"> 276</span>
<span id="277"> 277</span>
<span id="278"> 278</span>
<span id="279"> 279</span>
<span id="280"> 280</span>
<span id="281"> 281</span>
<span id="282"> 282</span>
<span id="283"> 283</span>
<span id="284"> 284</span>
<span id="285"> 285</span>
<span id="286"> 286</span>
<span id="287"> 287</span>
<span id="288"> 288</span>
<span id="289"> 289</span>
<span id="290"> 290</span>
<span id="291"> 291</span>
<span id="292"> 292</span>
<span id="293"> 293</span>
<span id="294"> 294</span>
<span id="295"> 295</span>
<span id="296"> 296</span>
<span id="297"> 297</span>
<span id="298"> 298</span>
<span id="299"> 299</span>
<span id="300"> 300</span>
<span id="301"> 301</span>
<span id="302"> 302</span>
<span id="303"> 303</span>
<span id="304"> 304</span>
<span id="305"> 305</span>
<span id="306"> 306</span>
<span id="307"> 307</span>
<span id="308"> 308</span>
<span id="309"> 309</span>
<span id="310"> 310</span>
<span id="311"> 311</span>
<span id="312"> 312</span>
<span id="313"> 313</span>
<span id="314"> 314</span>
<span id="315"> 315</span>
<span id="316"> 316</span>
<span id="317"> 317</span>
<span id="318"> 318</span>
<span id="319"> 319</span>
<span id="320"> 320</span>
<span id="321"> 321</span>
<span id="322"> 322</span>
<span id="323"> 323</span>
<span id="324"> 324</span>
<span id="325"> 325</span>
<span id="326"> 326</span>
<span id="327"> 327</span>
<span id="328"> 328</span>
<span id="329"> 329</span>
<span id="330"> 330</span>
<span id="331"> 331</span>
<span id="332"> 332</span>
<span id="333"> 333</span>
<span id="334"> 334</span>
<span id="335"> 335</span>
<span id="336"> 336</span>
<span id="337"> 337</span>
<span id="338"> 338</span>
<span id="339"> 339</span>
<span id="340"> 340</span>
<span id="341"> 341</span>
<span id="342"> 342</span>
<span id="343"> 343</span>
<span id="344"> 344</span>
<span id="345"> 345</span>
<span id="346"> 346</span>
<span id="347"> 347</span>
<span id="348"> 348</span>
<span id="349"> 349</span>
<span id="350"> 350</span>
<span id="351"> 351</span>
<span id="352"> 352</span>
<span id="353"> 353</span>
<span id="354"> 354</span>
<span id="355"> 355</span>
<span id="356"> 356</span>
<span id="357"> 357</span>
<span id="358"> 358</span>
<span id="359"> 359</span>
<span id="360"> 360</span>
<span id="361"> 361</span>
<span id="362"> 362</span>
<span id="363"> 363</span>
<span id="364"> 364</span>
<span id="365"> 365</span>
<span id="366"> 366</span>
<span id="367"> 367</span>
<span id="368"> 368</span>
<span id="369"> 369</span>
<span id="370"> 370</span>
<span id="371"> 371</span>
<span id="372"> 372</span>
<span id="373"> 373</span>
<span id="374"> 374</span>
<span id="375"> 375</span>
<span id="376"> 376</span>
<span id="377"> 377</span>
<span id="378"> 378</span>
<span id="379"> 379</span>
<span id="380"> 380</span>
<span id="381"> 381</span>
<span id="382"> 382</span>
<span id="383"> 383</span>
<span id="384"> 384</span>
<span id="385"> 385</span>
<span id="386"> 386</span>
<span id="387"> 387</span>
<span id="388"> 388</span>
<span id="389"> 389</span>
<span id="390"> 390</span>
<span id="391"> 391</span>
<span id="392"> 392</span>
<span id="393"> 393</span>
<span id="394"> 394</span>
<span id="395"> 395</span>
<span id="396"> 396</span>
<span id="397"> 397</span>
<span id="398"> 398</span>
<span id="399"> 399</span>
<span id="400"> 400</span>
<span id="401"> 401</span>
<span id="402"> 402</span>
<span id="403"> 403</span>
<span id="404"> 404</span>
<span id="405"> 405</span>
<span id="406"> 406</span>
<span id="407"> 407</span>
<span id="408"> 408</span>
<span id="409"> 409</span>
<span id="410"> 410</span>
<span id="411"> 411</span>
<span id="412"> 412</span>
<span id="413"> 413</span>
<span id="414"> 414</span>
<span id="415"> 415</span>
<span id="416"> 416</span>
<span id="417"> 417</span>
<span id="418"> 418</span>
<span id="419"> 419</span>
<span id="420"> 420</span>
<span id="421"> 421</span>
<span id="422"> 422</span>
<span id="423"> 423</span>
<span id="424"> 424</span>
<span id="425"> 425</span>
<span id="426"> 426</span>
<span id="427"> 427</span>
<span id="428"> 428</span>
<span id="429"> 429</span>
<span id="430"> 430</span>
<span id="431"> 431</span>
<span id="432"> 432</span>
<span id="433"> 433</span>
<span id="434"> 434</span>
<span id="435"> 435</span>
<span id="436"> 436</span>
<span id="437"> 437</span>
<span id="438"> 438</span>
<span id="439"> 439</span>
<span id="440"> 440</span>
<span id="441"> 441</span>
<span id="442"> 442</span>
<span id="443"> 443</span>
<span id="444"> 444</span>
<span id="445"> 445</span>
<span id="446"> 446</span>
<span id="447"> 447</span>
<span id="448"> 448</span>
<span id="449"> 449</span>
<span id="450"> 450</span>
<span id="451"> 451</span>
<span id="452"> 452</span>
<span id="453"> 453</span>
<span id="454"> 454</span>
<span id="455"> 455</span>
<span id="456"> 456</span>
<span id="457"> 457</span>
<span id="458"> 458</span>
<span id="459"> 459</span>
<span id="460"> 460</span>
<span id="461"> 461</span>
<span id="462"> 462</span>
<span id="463"> 463</span>
<span id="464"> 464</span>
<span id="465"> 465</span>
<span id="466"> 466</span>
<span id="467"> 467</span>
<span id="468"> 468</span>
<span id="469"> 469</span>
<span id="470"> 470</span>
<span id="471"> 471</span>
<span id="472"> 472</span>
<span id="473"> 473</span>
<span id="474"> 474</span>
<span id="475"> 475</span>
<span id="476"> 476</span>
<span id="477"> 477</span>
<span id="478"> 478</span>
<span id="479"> 479</span>
<span id="480"> 480</span>
<span id="481"> 481</span>
<span id="482"> 482</span>
<span id="483"> 483</span>
<span id="484"> 484</span>
<span id="485"> 485</span>
<span id="486"> 486</span>
<span id="487"> 487</span>
<span id="488"> 488</span>
<span id="489"> 489</span>
<span id="490"> 490</span>
<span id="491"> 491</span>
<span id="492"> 492</span>
<span id="493"> 493</span>
<span id="494"> 494</span>
<span id="495"> 495</span>
<span id="496"> 496</span>
<span id="497"> 497</span>
<span id="498"> 498</span>
<span id="499"> 499</span>
<span id="500"> 500</span>
<span id="501"> 501</span>
<span id="502"> 502</span>
<span id="503"> 503</span>
<span id="504"> 504</span>
<span id="505"> 505</span>
<span id="506"> 506</span>
<span id="507"> 507</span>
<span id="508"> 508</span>
<span id="509"> 509</span>
<span id="510"> 510</span>
<span id="511"> 511</span>
<span id="512"> 512</span>
<span id="513"> 513</span>
<span id="514"> 514</span>
<span id="515"> 515</span>
<span id="516"> 516</span>
<span id="517"> 517</span>
<span id="518"> 518</span>
<span id="519"> 519</span>
<span id="520"> 520</span>
<span id="521"> 521</span>
<span id="522"> 522</span>
<span id="523"> 523</span>
<span id="524"> 524</span>
<span id="525"> 525</span>
<span id="526"> 526</span>
<span id="527"> 527</span>
<span id="528"> 528</span>
<span id="529"> 529</span>
<span id="530"> 530</span>
<span id="531"> 531</span>
<span id="532"> 532</span>
<span id="533"> 533</span>
<span id="534"> 534</span>
<span id="535"> 535</span>
<span id="536"> 536</span>
<span id="537"> 537</span>
<span id="538"> 538</span>
<span id="539"> 539</span>
<span id="540"> 540</span>
<span id="541"> 541</span>
<span id="542"> 542</span>
<span id="543"> 543</span>
<span id="544"> 544</span>
<span id="545"> 545</span>
<span id="546"> 546</span>
<span id="547"> 547</span>
<span id="548"> 548</span>
<span id="549"> 549</span>
<span id="550"> 550</span>
<span id="551"> 551</span>
<span id="552"> 552</span>
<span id="553"> 553</span>
<span id="554"> 554</span>
<span id="555"> 555</span>
<span id="556"> 556</span>
<span id="557"> 557</span>
<span id="558"> 558</span>
<span id="559"> 559</span>
<span id="560"> 560</span>
<span id="561"> 561</span>
<span id="562"> 562</span>
<span id="563"> 563</span>
<span id="564"> 564</span>
<span id="565"> 565</span>
<span id="566"> 566</span>
<span id="567"> 567</span>
<span id="568"> 568</span>
<span id="569"> 569</span>
<span id="570"> 570</span>
<span id="571"> 571</span>
<span id="572"> 572</span>
<span id="573"> 573</span>
<span id="574"> 574</span>
<span id="575"> 575</span>
<span id="576"> 576</span>
<span id="577"> 577</span>
<span id="578"> 578</span>
<span id="579"> 579</span>
<span id="580"> 580</span>
<span id="581"> 581</span>
<span id="582"> 582</span>
<span id="583"> 583</span>
<span id="584"> 584</span>
<span id="585"> 585</span>
<span id="586"> 586</span>
<span id="587"> 587</span>
<span id="588"> 588</span>
<span id="589"> 589</span>
<span id="590"> 590</span>
<span id="591"> 591</span>
<span id="592"> 592</span>
<span id="593"> 593</span>
<span id="594"> 594</span>
<span id="595"> 595</span>
<span id="596"> 596</span>
<span id="597"> 597</span>
<span id="598"> 598</span>
<span id="599"> 599</span>
<span id="600"> 600</span>
<span id="601"> 601</span>
<span id="602"> 602</span>
<span id="603"> 603</span>
<span id="604"> 604</span>
<span id="605"> 605</span>
<span id="606"> 606</span>
<span id="607"> 607</span>
<span id="608"> 608</span>
<span id="609"> 609</span>
<span id="610"> 610</span>
<span id="611"> 611</span>
<span id="612"> 612</span>
<span id="613"> 613</span>
<span id="614"> 614</span>
<span id="615"> 615</span>
<span id="616"> 616</span>
<span id="617"> 617</span>
<span id="618"> 618</span>
<span id="619"> 619</span>
<span id="620"> 620</span>
<span id="621"> 621</span>
<span id="622"> 622</span>
<span id="623"> 623</span>
<span id="624"> 624</span>
<span id="625"> 625</span>
<span id="626"> 626</span>
<span id="627"> 627</span>
<span id="628"> 628</span>
<span id="629"> 629</span>
<span id="630"> 630</span>
<span id="631"> 631</span>
<span id="632"> 632</span>
<span id="633"> 633</span>
<span id="634"> 634</span>
<span id="635"> 635</span>
<span id="636"> 636</span>
<span id="637"> 637</span>
<span id="638"> 638</span>
<span id="639"> 639</span>
<span id="640"> 640</span>
<span id="641"> 641</span>
<span id="642"> 642</span>
<span id="643"> 643</span>
<span id="644"> 644</span>
<span id="645"> 645</span>
<span id="646"> 646</span>
<span id="647"> 647</span>
<span id="648"> 648</span>
<span id="649"> 649</span>
<span id="650"> 650</span>
<span id="651"> 651</span>
<span id="652"> 652</span>
<span id="653"> 653</span>
<span id="654"> 654</span>
<span id="655"> 655</span>
<span id="656"> 656</span>
<span id="657"> 657</span>
<span id="658"> 658</span>
<span id="659"> 659</span>
<span id="660"> 660</span>
<span id="661"> 661</span>
<span id="662"> 662</span>
<span id="663"> 663</span>
<span id="664"> 664</span>
<span id="665"> 665</span>
<span id="666"> 666</span>
<span id="667"> 667</span>
<span id="668"> 668</span>
<span id="669"> 669</span>
<span id="670"> 670</span>
<span id="671"> 671</span>
<span id="672"> 672</span>
<span id="673"> 673</span>
<span id="674"> 674</span>
<span id="675"> 675</span>
<span id="676"> 676</span>
<span id="677"> 677</span>
<span id="678"> 678</span>
<span id="679"> 679</span>
<span id="680"> 680</span>
<span id="681"> 681</span>
<span id="682"> 682</span>
<span id="683"> 683</span>
<span id="684"> 684</span>
<span id="685"> 685</span>
<span id="686"> 686</span>
<span id="687"> 687</span>
<span id="688"> 688</span>
<span id="689"> 689</span>
<span id="690"> 690</span>
<span id="691"> 691</span>
<span id="692"> 692</span>
<span id="693"> 693</span>
<span id="694"> 694</span>
<span id="695"> 695</span>
<span id="696"> 696</span>
<span id="697"> 697</span>
<span id="698"> 698</span>
<span id="699"> 699</span>
<span id="700"> 700</span>
<span id="701"> 701</span>
<span id="702"> 702</span>
<span id="703"> 703</span>
<span id="704"> 704</span>
<span id="705"> 705</span>
<span id="706"> 706</span>
<span id="707"> 707</span>
<span id="708"> 708</span>
<span id="709"> 709</span>
<span id="710"> 710</span>
<span id="711"> 711</span>
<span id="712"> 712</span>
<span id="713"> 713</span>
<span id="714"> 714</span>
<span id="715"> 715</span>
<span id="716"> 716</span>
<span id="717"> 717</span>
<span id="718"> 718</span>
<span id="719"> 719</span>
<span id="720"> 720</span>
<span id="721"> 721</span>
<span id="722"> 722</span>
<span id="723"> 723</span>
<span id="724"> 724</span>
<span id="725"> 725</span>
<span id="726"> 726</span>
<span id="727"> 727</span>
<span id="728"> 728</span>
<span id="729"> 729</span>
<span id="730"> 730</span>
<span id="731"> 731</span>
<span id="732"> 732</span>
<span id="733"> 733</span>
<span id="734"> 734</span>
<span id="735"> 735</span>
<span id="736"> 736</span>
<span id="737"> 737</span>
<span id="738"> 738</span>
<span id="739"> 739</span>
<span id="740"> 740</span>
<span id="741"> 741</span>
<span id="742"> 742</span>
<span id="743"> 743</span>
<span id="744"> 744</span>
<span id="745"> 745</span>
<span id="746"> 746</span>
<span id="747"> 747</span>
<span id="748"> 748</span>
<span id="749"> 749</span>
<span id="750"> 750</span>
<span id="751"> 751</span>
<span id="752"> 752</span>
<span id="753"> 753</span>
<span id="754"> 754</span>
<span id="755"> 755</span>
<span id="756"> 756</span>
<span id="757"> 757</span>
<span id="758"> 758</span>
<span id="759"> 759</span>
<span id="760"> 760</span>
<span id="761"> 761</span>
<span id="762"> 762</span>
<span id="763"> 763</span>
<span id="764"> 764</span>
<span id="765"> 765</span>
<span id="766"> 766</span>
<span id="767"> 767</span>
<span id="768"> 768</span>
<span id="769"> 769</span>
<span id="770"> 770</span>
<span id="771"> 771</span>
<span id="772"> 772</span>
<span id="773"> 773</span>
<span id="774"> 774</span>
<span id="775"> 775</span>
<span id="776"> 776</span>
<span id="777"> 777</span>
<span id="778"> 778</span>
<span id="779"> 779</span>
<span id="780"> 780</span>
<span id="781"> 781</span>
<span id="782"> 782</span>
<span id="783"> 783</span>
<span id="784"> 784</span>
<span id="785"> 785</span>
<span id="786"> 786</span>
<span id="787"> 787</span>
<span id="788"> 788</span>
<span id="789"> 789</span>
<span id="790"> 790</span>
<span id="791"> 791</span>
<span id="792"> 792</span>
<span id="793"> 793</span>
<span id="794"> 794</span>
<span id="795"> 795</span>
<span id="796"> 796</span>
<span id="797"> 797</span>
<span id="798"> 798</span>
<span id="799"> 799</span>
<span id="800"> 800</span>
<span id="801"> 801</span>
<span id="802"> 802</span>
<span id="803"> 803</span>
<span id="804"> 804</span>
<span id="805"> 805</span>
<span id="806"> 806</span>
<span id="807"> 807</span>
<span id="808"> 808</span>
<span id="809"> 809</span>
<span id="810"> 810</span>
<span id="811"> 811</span>
<span id="812"> 812</span>
<span id="813"> 813</span>
<span id="814"> 814</span>
<span id="815"> 815</span>
<span id="816"> 816</span>
<span id="817"> 817</span>
<span id="818"> 818</span>
<span id="819"> 819</span>
<span id="820"> 820</span>
<span id="821"> 821</span>
<span id="822"> 822</span>
<span id="823"> 823</span>
<span id="824"> 824</span>
<span id="825"> 825</span>
<span id="826"> 826</span>
<span id="827"> 827</span>
<span id="828"> 828</span>
<span id="829"> 829</span>
<span id="830"> 830</span>
<span id="831"> 831</span>
<span id="832"> 832</span>
<span id="833"> 833</span>
<span id="834"> 834</span>
<span id="835"> 835</span>
<span id="836"> 836</span>
<span id="837"> 837</span>
<span id="838"> 838</span>
<span id="839"> 839</span>
<span id="840"> 840</span>
<span id="841"> 841</span>
<span id="842"> 842</span>
<span id="843"> 843</span>
<span id="844"> 844</span>
<span id="845"> 845</span>
<span id="846"> 846</span>
<span id="847"> 847</span>
<span id="848"> 848</span>
<span id="849"> 849</span>
<span id="850"> 850</span>
<span id="851"> 851</span>
<span id="852"> 852</span>
<span id="853"> 853</span>
<span id="854"> 854</span>
<span id="855"> 855</span>
<span id="856"> 856</span>
<span id="857"> 857</span>
<span id="858"> 858</span>
<span id="859"> 859</span>
<span id="860"> 860</span>
<span id="861"> 861</span>
<span id="862"> 862</span>
<span id="863"> 863</span>
<span id="864"> 864</span>
<span id="865"> 865</span>
<span id="866"> 866</span>
<span id="867"> 867</span>
<span id="868"> 868</span>
<span id="869"> 869</span>
<span id="870"> 870</span>
<span id="871"> 871</span>
<span id="872"> 872</span>
<span id="873"> 873</span>
<span id="874"> 874</span>
<span id="875"> 875</span>
<span id="876"> 876</span>
<span id="877"> 877</span>
<span id="878"> 878</span>
<span id="879"> 879</span>
<span id="880"> 880</span>
<span id="881"> 881</span>
<span id="882"> 882</span>
<span id="883"> 883</span>
<span id="884"> 884</span>
<span id="885"> 885</span>
<span id="886"> 886</span>
<span id="887"> 887</span>
<span id="888"> 888</span>
<span id="889"> 889</span>
<span id="890"> 890</span>
<span id="891"> 891</span>
<span id="892"> 892</span>
<span id="893"> 893</span>
<span id="894"> 894</span>
<span id="895"> 895</span>
<span id="896"> 896</span>
<span id="897"> 897</span>
<span id="898"> 898</span>
<span id="899"> 899</span>
<span id="900"> 900</span>
<span id="901"> 901</span>
<span id="902"> 902</span>
<span id="903"> 903</span>
<span id="904"> 904</span>
<span id="905"> 905</span>
<span id="906"> 906</span>
<span id="907"> 907</span>
<span id="908"> 908</span>
<span id="909"> 909</span>
<span id="910"> 910</span>
<span id="911"> 911</span>
<span id="912"> 912</span>
<span id="913"> 913</span>
<span id="914"> 914</span>
<span id="915"> 915</span>
<span id="916"> 916</span>
<span id="917"> 917</span>
<span id="918"> 918</span>
<span id="919"> 919</span>
<span id="920"> 920</span>
<span id="921"> 921</span>
<span id="922"> 922</span>
<span id="923"> 923</span>
<span id="924"> 924</span>
<span id="925"> 925</span>
<span id="926"> 926</span>
<span id="927"> 927</span>
<span id="928"> 928</span>
<span id="929"> 929</span>
<span id="930"> 930</span>
<span id="931"> 931</span>
<span id="932"> 932</span>
<span id="933"> 933</span>
<span id="934"> 934</span>
<span id="935"> 935</span>
<span id="936"> 936</span>
<span id="937"> 937</span>
<span id="938"> 938</span>
<span id="939"> 939</span>
<span id="940"> 940</span>
<span id="941"> 941</span>
<span id="942"> 942</span>
<span id="943"> 943</span>
<span id="944"> 944</span>
<span id="945"> 945</span>
<span id="946"> 946</span>
<span id="947"> 947</span>
<span id="948"> 948</span>
<span id="949"> 949</span>
<span id="950"> 950</span>
<span id="951"> 951</span>
<span id="952"> 952</span>
<span id="953"> 953</span>
<span id="954"> 954</span>
<span id="955"> 955</span>
<span id="956"> 956</span>
<span id="957"> 957</span>
<span id="958"> 958</span>
<span id="959"> 959</span>
<span id="960"> 960</span>
<span id="961"> 961</span>
<span id="962"> 962</span>
<span id="963"> 963</span>
<span id="964"> 964</span>
<span id="965"> 965</span>
<span id="966"> 966</span>
<span id="967"> 967</span>
<span id="968"> 968</span>
<span id="969"> 969</span>
<span id="970"> 970</span>
<span id="971"> 971</span>
<span id="972"> 972</span>
<span id="973"> 973</span>
<span id="974"> 974</span>
<span id="975"> 975</span>
<span id="976"> 976</span>
<span id="977"> 977</span>
<span id="978"> 978</span>
<span id="979"> 979</span>
<span id="980"> 980</span>
<span id="981"> 981</span>
<span id="982"> 982</span>
<span id="983"> 983</span>
<span id="984"> 984</span>
<span id="985"> 985</span>
<span id="986"> 986</span>
<span id="987"> 987</span>
<span id="988"> 988</span>
<span id="989"> 989</span>
<span id="990"> 990</span>
<span id="991"> 991</span>
<span id="992"> 992</span>
<span id="993"> 993</span>
<span id="994"> 994</span>
<span id="995"> 995</span>
<span id="996"> 996</span>
<span id="997"> 997</span>
<span id="998"> 998</span>
<span id="999"> 999</span>
<span id="1000">1000</span>
<span id="1001">1001</span>
<span id="1002">1002</span>
<span id="1003">1003</span>
<span id="1004">1004</span>
<span id="1005">1005</span>
<span id="1006">1006</span>
<span id="1007">1007</span>
<span id="1008">1008</span>
<span id="1009">1009</span>
<span id="1010">1010</span>
<span id="1011">1011</span>
<span id="1012">1012</span>
<span id="1013">1013</span>
<span id="1014">1014</span>
<span id="1015">1015</span>
<span id="1016">1016</span>
<span id="1017">1017</span>
<span id="1018">1018</span>
<span id="1019">1019</span>
<span id="1020">1020</span>
<span id="1021">1021</span>
<span id="1022">1022</span>
<span id="1023">1023</span>
<span id="1024">1024</span>
<span id="1025">1025</span>
<span id="1026">1026</span>
<span id="1027">1027</span>
<span id="1028">1028</span>
<span id="1029">1029</span>
<span id="1030">1030</span>
<span id="1031">1031</span>
<span id="1032">1032</span>
<span id="1033">1033</span>
<span id="1034">1034</span>
<span id="1035">1035</span>
<span id="1036">1036</span>
<span id="1037">1037</span>
<span id="1038">1038</span>
<span id="1039">1039</span>
<span id="1040">1040</span>
<span id="1041">1041</span>
<span id="1042">1042</span>
<span id="1043">1043</span>
<span id="1044">1044</span>
<span id="1045">1045</span>
<span id="1046">1046</span>
<span id="1047">1047</span>
<span id="1048">1048</span>
<span id="1049">1049</span>
<span id="1050">1050</span>
<span id="1051">1051</span>
<span id="1052">1052</span>
<span id="1053">1053</span>
<span id="1054">1054</span>
<span id="1055">1055</span>
<span id="1056">1056</span>
<span id="1057">1057</span>
<span id="1058">1058</span>
<span id="1059">1059</span>
<span id="1060">1060</span>
<span id="1061">1061</span>
<span id="1062">1062</span>
<span id="1063">1063</span>
<span id="1064">1064</span>
<span id="1065">1065</span>
<span id="1066">1066</span>
<span id="1067">1067</span>
<span id="1068">1068</span>
<span id="1069">1069</span>
<span id="1070">1070</span>
<span id="1071">1071</span>
<span id="1072">1072</span>
<span id="1073">1073</span>
<span id="1074">1074</span>
<span id="1075">1075</span>
<span id="1076">1076</span>
<span id="1077">1077</span>
<span id="1078">1078</span>
<span id="1079">1079</span>
<span id="1080">1080</span>
<span id="1081">1081</span>
<span id="1082">1082</span>
<span id="1083">1083</span>
<span id="1084">1084</span>
<span id="1085">1085</span>
<span id="1086">1086</span>
<span id="1087">1087</span>
<span id="1088">1088</span>
<span id="1089">1089</span>
<span id="1090">1090</span>
<span id="1091">1091</span>
<span id="1092">1092</span>
<span id="1093">1093</span>
<span id="1094">1094</span>
<span id="1095">1095</span>
<span id="1096">1096</span>
<span id="1097">1097</span>
<span id="1098">1098</span>
<span id="1099">1099</span>
<span id="1100">1100</span>
<span id="1101">1101</span>
<span id="1102">1102</span>
<span id="1103">1103</span>
<span id="1104">1104</span>
<span id="1105">1105</span>
<span id="1106">1106</span>
<span id="1107">1107</span>
<span id="1108">1108</span>
<span id="1109">1109</span>
<span id="1110">1110</span>
<span id="1111">1111</span>
<span id="1112">1112</span>
<span id="1113">1113</span>
<span id="1114">1114</span>
<span id="1115">1115</span>
<span id="1116">1116</span>
<span id="1117">1117</span>
<span id="1118">1118</span>
<span id="1119">1119</span>
<span id="1120">1120</span>
<span id="1121">1121</span>
<span id="1122">1122</span>
<span id="1123">1123</span>
<span id="1124">1124</span>
<span id="1125">1125</span>
<span id="1126">1126</span>
<span id="1127">1127</span>
<span id="1128">1128</span>
<span id="1129">1129</span>
<span id="1130">1130</span>
<span id="1131">1131</span>
<span id="1132">1132</span>
<span id="1133">1133</span>
<span id="1134">1134</span>
<span id="1135">1135</span>
<span id="1136">1136</span>
<span id="1137">1137</span>
<span id="1138">1138</span>
<span id="1139">1139</span>
<span id="1140">1140</span>
<span id="1141">1141</span>
<span id="1142">1142</span>
<span id="1143">1143</span>
<span id="1144">1144</span>
<span id="1145">1145</span>
<span id="1146">1146</span>
<span id="1147">1147</span>
<span id="1148">1148</span>
<span id="1149">1149</span>
<span id="1150">1150</span>
<span id="1151">1151</span>
<span id="1152">1152</span>
<span id="1153">1153</span>
<span id="1154">1154</span>
<span id="1155">1155</span>
<span id="1156">1156</span>
<span id="1157">1157</span>
<span id="1158">1158</span>
<span id="1159">1159</span>
<span id="1160">1160</span>
<span id="1161">1161</span>
<span id="1162">1162</span>
<span id="1163">1163</span>
<span id="1164">1164</span>
<span id="1165">1165</span>
<span id="1166">1166</span>
<span id="1167">1167</span>
<span id="1168">1168</span>
<span id="1169">1169</span>
<span id="1170">1170</span>
<span id="1171">1171</span>
<span id="1172">1172</span>
<span id="1173">1173</span>
<span id="1174">1174</span>
<span id="1175">1175</span>
<span id="1176">1176</span>
<span id="1177">1177</span>
<span id="1178">1178</span>
<span id="1179">1179</span>
<span id="1180">1180</span>
<span id="1181">1181</span>
<span id="1182">1182</span>
<span id="1183">1183</span>
<span id="1184">1184</span>
<span id="1185">1185</span>
<span id="1186">1186</span>
<span id="1187">1187</span>
<span id="1188">1188</span>
<span id="1189">1189</span>
<span id="1190">1190</span>
<span id="1191">1191</span>
<span id="1192">1192</span>
<span id="1193">1193</span>
<span id="1194">1194</span>
<span id="1195">1195</span>
<span id="1196">1196</span>
<span id="1197">1197</span>
<span id="1198">1198</span>
<span id="1199">1199</span>
<span id="1200">1200</span>
<span id="1201">1201</span>
<span id="1202">1202</span>
<span id="1203">1203</span>
<span id="1204">1204</span>
</pre><pre class="rust"><code><span class="doccomment">//! Generate instruction data (including opcodes, formats, builders, etc.).</span>
<span class="kw">use</span> <span class="ident">std::fmt</span>;

<span class="kw">use</span> <span class="ident">cranelift_codegen_shared::constant_hash</span>;

<span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::cdsl::camel_case</span>;
<span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::cdsl::formats::InstructionFormat</span>;
<span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::cdsl::instructions</span>::{<span class="ident">AllInstructions</span>, <span class="ident">Instruction</span>};
<span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::cdsl::operands::Operand</span>;
<span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::cdsl::typevar</span>::{<span class="ident">TypeSet</span>, <span class="ident">TypeVar</span>};

<span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::error</span>;
<span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::srcgen</span>::{<span class="ident">Formatter</span>, <span class="ident">Match</span>};
<span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::unique_table</span>::{<span class="ident">UniqueSeqTable</span>, <span class="ident">UniqueTable</span>};

<span class="comment">// TypeSet indexes are encoded in 8 bits, with `0xff` reserved.</span>
<span class="kw">const</span> <span class="ident">TYPESET_LIMIT</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">0xff</span>;

<span class="doccomment">/// Generate an instruction format enumeration.</span>
<span class="kw">fn</span> <span class="ident">gen_formats</span>(<span class="ident">formats</span>: <span class="kw-2">&amp;</span>[<span class="kw-2">&amp;</span><span class="ident">InstructionFormat</span>], <span class="ident">fmt</span>: <span class="kw-2">&amp;mut</span> <span class="ident">Formatter</span>) {
  <span class="ident">fmt</span>.<span class="ident">doc_comment</span>(
    <span class="string">r#&quot;
        An instruction format

        Every opcode has a corresponding instruction format
        which is represented by both the `InstructionFormat`
        and the `InstructionData` enums.
    &quot;#</span>,
  );
  <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;#[derive(Copy, Clone, PartialEq, Eq, Debug)]&quot;</span>);
  <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;pub enum InstructionFormat {&quot;</span>);
  <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
    <span class="kw">for</span> <span class="ident">format</span> <span class="kw">in</span> <span class="ident">formats</span> {
      <span class="ident">fmt</span>.<span class="ident">doc_comment</span>(<span class="ident">format</span>.<span class="ident">to_string</span>());
      <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;{},&quot;</span>, <span class="ident">format</span>.<span class="ident">name</span>);
    }
  });
  <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;}&quot;</span>);
  <span class="ident">fmt</span>.<span class="ident">empty_line</span>();

  <span class="comment">// Emit a From&lt;InstructionData&gt; which also serves to verify that</span>
  <span class="comment">// InstructionFormat and InstructionData are in sync.</span>
  <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;impl&lt;&#39;a&gt; From&lt;&amp;&#39;a InstructionData&gt; for InstructionFormat {&quot;</span>);
  <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
    <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;fn from(inst: &amp;&#39;a InstructionData) -&gt; Self {&quot;</span>);
    <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
      <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">m</span> <span class="op">=</span> <span class="ident">Match::new</span>(<span class="string">&quot;*inst&quot;</span>);
      <span class="kw">for</span> <span class="ident">format</span> <span class="kw">in</span> <span class="ident">formats</span> {
        <span class="ident">m</span>.<span class="ident">arm</span>(
          <span class="macro">format!</span>(<span class="string">&quot;InstructionData::{}&quot;</span>, <span class="ident">format</span>.<span class="ident">name</span>),
          <span class="macro">vec!</span>[<span class="string">&quot;..&quot;</span>],
          <span class="macro">format!</span>(<span class="string">&quot;Self::{}&quot;</span>, <span class="ident">format</span>.<span class="ident">name</span>),
        );
      }
      <span class="ident">fmt</span>.<span class="ident">add_match</span>(<span class="ident">m</span>);
    });
    <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;}&quot;</span>);
  });
  <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;}&quot;</span>);
  <span class="ident">fmt</span>.<span class="ident">empty_line</span>();
}

<span class="doccomment">/// Generate the InstructionData enum.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Every variant must contain an `opcode` field. The size of `InstructionData` should be kept at</span>
<span class="doccomment">/// 16 bytes on 64-bit architectures. If more space is needed to represent an instruction, use a</span>
<span class="doccomment">/// `ValueList` to store the additional information out of line.</span>
<span class="kw">fn</span> <span class="ident">gen_instruction_data</span>(<span class="ident">formats</span>: <span class="kw-2">&amp;</span>[<span class="kw-2">&amp;</span><span class="ident">InstructionFormat</span>], <span class="ident">fmt</span>: <span class="kw-2">&amp;mut</span> <span class="ident">Formatter</span>) {
  <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;#[derive(Clone, Debug)]&quot;</span>);
  <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">r#&quot;#[cfg_attr(feature = &quot;enable-serde&quot;, derive(Serialize, Deserialize))]&quot;#</span>);
  <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;#[allow(missing_docs)]&quot;</span>);
  <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;pub enum InstructionData {&quot;</span>);
  <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
    <span class="kw">for</span> <span class="ident">format</span> <span class="kw">in</span> <span class="ident">formats</span> {
      <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;{} {{&quot;</span>, <span class="ident">format</span>.<span class="ident">name</span>);
      <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
        <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;opcode: Opcode,&quot;</span>);
        <span class="kw">if</span> <span class="ident">format</span>.<span class="ident">typevar_operand</span>.<span class="ident">is_some</span>() {
          <span class="kw">if</span> <span class="ident">format</span>.<span class="ident">has_value_list</span> {
            <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;args: ValueList,&quot;</span>);
          } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">format</span>.<span class="ident">num_value_operands</span> <span class="op">==</span> <span class="number">1</span> {
            <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;arg: Value,&quot;</span>);
          } <span class="kw">else</span> {
            <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;args: [Value; {}],&quot;</span>, <span class="ident">format</span>.<span class="ident">num_value_operands</span>);
          }
        }
        <span class="kw">for</span> <span class="ident">field</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">format</span>.<span class="ident">imm_fields</span> {
          <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;{}: {},&quot;</span>, <span class="ident">field</span>.<span class="ident">member</span>, <span class="ident">field</span>.<span class="ident">kind</span>.<span class="ident">rust_type</span>);
        }
      });
      <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;},&quot;</span>);
    }
  });
  <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;}&quot;</span>);
}

<span class="kw">fn</span> <span class="ident">gen_arguments_method</span>(<span class="ident">formats</span>: <span class="kw-2">&amp;</span>[<span class="kw-2">&amp;</span><span class="ident">InstructionFormat</span>], <span class="ident">fmt</span>: <span class="kw-2">&amp;mut</span> <span class="ident">Formatter</span>, <span class="ident">is_mut</span>: <span class="ident">bool</span>) {
  <span class="kw">let</span> (<span class="ident">method</span>, <span class="ident">mut_</span>, <span class="ident">rslice</span>, <span class="ident">as_slice</span>) <span class="op">=</span> <span class="kw">if</span> <span class="ident">is_mut</span> {
    (
      <span class="string">&quot;arguments_mut&quot;</span>,
      <span class="string">&quot;mut &quot;</span>,
      <span class="string">&quot;core::slice::from_mut&quot;</span>,
      <span class="string">&quot;as_mut_slice&quot;</span>,
    )
  } <span class="kw">else</span> {
    (<span class="string">&quot;arguments&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;core::slice::from_ref&quot;</span>, <span class="string">&quot;as_slice&quot;</span>)
  };

  <span class="macro">fmtln!</span>(
    <span class="ident">fmt</span>,
    <span class="string">&quot;pub fn {}&lt;&#39;a&gt;(&amp;&#39;a {}self, pool: &amp;&#39;a {}ir::ValueListPool) -&gt; &amp;{}[Value] {{&quot;</span>,
    <span class="ident">method</span>,
    <span class="ident">mut_</span>,
    <span class="ident">mut_</span>,
    <span class="ident">mut_</span>
  );
  <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">m</span> <span class="op">=</span> <span class="ident">Match::new</span>(<span class="string">&quot;*self&quot;</span>);
    <span class="kw">for</span> <span class="ident">format</span> <span class="kw">in</span> <span class="ident">formats</span> {
      <span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="macro">format!</span>(<span class="string">&quot;Self::{}&quot;</span>, <span class="ident">format</span>.<span class="ident">name</span>);

      <span class="comment">// Formats with a value list put all of their arguments in the list. We don&#39;t split</span>
      <span class="comment">// them up, just return it all as variable arguments. (I expect the distinction to go</span>
      <span class="comment">// away).</span>
      <span class="kw">if</span> <span class="ident">format</span>.<span class="ident">has_value_list</span> {
        <span class="ident">m</span>.<span class="ident">arm</span>(
          <span class="ident">name</span>,
          <span class="macro">vec!</span>[<span class="macro">format!</span>(<span class="string">&quot;ref {}args&quot;</span>, <span class="ident">mut_</span>), <span class="string">&quot;..&quot;</span>.<span class="ident">to_string</span>()],
          <span class="macro">format!</span>(<span class="string">&quot;args.{}(pool)&quot;</span>, <span class="ident">as_slice</span>),
        );
        <span class="kw">continue</span>;
      }

      <span class="comment">// Fixed args.</span>
      <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">fields</span> <span class="op">=</span> <span class="ident">Vec::new</span>();
      <span class="kw">let</span> <span class="ident">arg</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">format</span>.<span class="ident">num_value_operands</span> <span class="op">==</span> <span class="number">0</span> {
        <span class="macro">format!</span>(<span class="string">&quot;&amp;{}[]&quot;</span>, <span class="ident">mut_</span>)
      } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">format</span>.<span class="ident">num_value_operands</span> <span class="op">==</span> <span class="number">1</span> {
        <span class="ident">fields</span>.<span class="ident">push</span>(<span class="macro">format!</span>(<span class="string">&quot;ref {}arg&quot;</span>, <span class="ident">mut_</span>));
        <span class="macro">format!</span>(<span class="string">&quot;{}(arg)&quot;</span>, <span class="ident">rslice</span>)
      } <span class="kw">else</span> {
        <span class="kw">let</span> <span class="ident">arg</span> <span class="op">=</span> <span class="macro">format!</span>(<span class="string">&quot;args_arity{}&quot;</span>, <span class="ident">format</span>.<span class="ident">num_value_operands</span>);
        <span class="ident">fields</span>.<span class="ident">push</span>(<span class="macro">format!</span>(<span class="string">&quot;args: ref {}{}&quot;</span>, <span class="ident">mut_</span>, <span class="ident">arg</span>));
        <span class="ident">arg</span>
      };
      <span class="ident">fields</span>.<span class="ident">push</span>(<span class="string">&quot;..&quot;</span>.<span class="ident">into</span>());

      <span class="ident">m</span>.<span class="ident">arm</span>(<span class="ident">name</span>, <span class="ident">fields</span>, <span class="ident">arg</span>);
    }
    <span class="ident">fmt</span>.<span class="ident">add_match</span>(<span class="ident">m</span>);
  });
  <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;}&quot;</span>);
}

<span class="doccomment">/// Generate the boring parts of the InstructionData implementation.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// These methods in `impl InstructionData` can be generated automatically from the instruction</span>
<span class="doccomment">/// formats:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// - `pub fn opcode(&amp;self) -&gt; Opcode`</span>
<span class="doccomment">/// - `pub fn arguments(&amp;self, &amp;pool) -&gt; &amp;[Value]`</span>
<span class="doccomment">/// - `pub fn arguments_mut(&amp;mut self, &amp;pool) -&gt; &amp;mut [Value]`</span>
<span class="doccomment">/// - `pub fn take_value_list(&amp;mut self) -&gt; Option&lt;ir::ValueList&gt;`</span>
<span class="doccomment">/// - `pub fn put_value_list(&amp;mut self, args: ir::ValueList&gt;`</span>
<span class="doccomment">/// - `pub fn eq(&amp;self, &amp;other: Self, &amp;pool) -&gt; bool`</span>
<span class="doccomment">/// - `pub fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H, &amp;pool)`</span>
<span class="kw">fn</span> <span class="ident">gen_instruction_data_impl</span>(<span class="ident">formats</span>: <span class="kw-2">&amp;</span>[<span class="kw-2">&amp;</span><span class="ident">InstructionFormat</span>], <span class="ident">fmt</span>: <span class="kw-2">&amp;mut</span> <span class="ident">Formatter</span>) {
  <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;impl InstructionData {&quot;</span>);
  <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
    <span class="ident">fmt</span>.<span class="ident">doc_comment</span>(<span class="string">&quot;Get the opcode of this instruction.&quot;</span>);
    <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;pub fn opcode(&amp;self) -&gt; Opcode {&quot;</span>);
    <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
      <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">m</span> <span class="op">=</span> <span class="ident">Match::new</span>(<span class="string">&quot;*self&quot;</span>);
      <span class="kw">for</span> <span class="ident">format</span> <span class="kw">in</span> <span class="ident">formats</span> {
        <span class="ident">m</span>.<span class="ident">arm</span>(
          <span class="macro">format!</span>(<span class="string">&quot;Self::{}&quot;</span>, <span class="ident">format</span>.<span class="ident">name</span>),
          <span class="macro">vec!</span>[<span class="string">&quot;opcode&quot;</span>, <span class="string">&quot;..&quot;</span>],
          <span class="string">&quot;opcode&quot;</span>.<span class="ident">to_string</span>(),
        );
      }
      <span class="ident">fmt</span>.<span class="ident">add_match</span>(<span class="ident">m</span>);
    });
    <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;}&quot;</span>);
    <span class="ident">fmt</span>.<span class="ident">empty_line</span>();

    <span class="ident">fmt</span>.<span class="ident">doc_comment</span>(<span class="string">&quot;Get the controlling type variable operand.&quot;</span>);
    <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;pub fn typevar_operand(&amp;self, pool: &amp;ir::ValueListPool) -&gt; Option&lt;Value&gt; {&quot;</span>);
    <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
      <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">m</span> <span class="op">=</span> <span class="ident">Match::new</span>(<span class="string">&quot;*self&quot;</span>);
      <span class="kw">for</span> <span class="ident">format</span> <span class="kw">in</span> <span class="ident">formats</span> {
        <span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="macro">format!</span>(<span class="string">&quot;Self::{}&quot;</span>, <span class="ident">format</span>.<span class="ident">name</span>);
        <span class="kw">if</span> <span class="ident">format</span>.<span class="ident">typevar_operand</span>.<span class="ident">is_none</span>() {
          <span class="ident">m</span>.<span class="ident">arm</span>(<span class="ident">name</span>, <span class="macro">vec!</span>[<span class="string">&quot;..&quot;</span>], <span class="string">&quot;None&quot;</span>.<span class="ident">to_string</span>());
        } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">format</span>.<span class="ident">has_value_list</span> {
          <span class="comment">// We keep all arguments in a value list.</span>
          <span class="ident">m</span>.<span class="ident">arm</span>(
            <span class="ident">name</span>,
            <span class="macro">vec!</span>[<span class="string">&quot;ref args&quot;</span>, <span class="string">&quot;..&quot;</span>],
            <span class="macro">format!</span>(<span class="string">&quot;args.get({}, pool)&quot;</span>, <span class="ident">format</span>.<span class="ident">typevar_operand</span>.<span class="ident">unwrap</span>()),
          );
        } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">format</span>.<span class="ident">num_value_operands</span> <span class="op">==</span> <span class="number">1</span> {
          <span class="ident">m</span>.<span class="ident">arm</span>(<span class="ident">name</span>, <span class="macro">vec!</span>[<span class="string">&quot;arg&quot;</span>, <span class="string">&quot;..&quot;</span>], <span class="string">&quot;Some(arg)&quot;</span>.<span class="ident">to_string</span>());
        } <span class="kw">else</span> {
          <span class="comment">// We have multiple value operands and an array `args`.</span>
          <span class="comment">// Which `args` index to use?</span>
          <span class="kw">let</span> <span class="ident">args</span> <span class="op">=</span> <span class="macro">format!</span>(<span class="string">&quot;args_arity{}&quot;</span>, <span class="ident">format</span>.<span class="ident">num_value_operands</span>);
          <span class="ident">m</span>.<span class="ident">arm</span>(
            <span class="ident">name</span>,
            <span class="macro">vec!</span>[<span class="macro">format!</span>(<span class="string">&quot;args: ref {}&quot;</span>, <span class="ident">args</span>), <span class="string">&quot;..&quot;</span>.<span class="ident">to_string</span>()],
            <span class="macro">format!</span>(<span class="string">&quot;Some({}[{}])&quot;</span>, <span class="ident">args</span>, <span class="ident">format</span>.<span class="ident">typevar_operand</span>.<span class="ident">unwrap</span>()),
          );
        }
      }
      <span class="ident">fmt</span>.<span class="ident">add_match</span>(<span class="ident">m</span>);
    });
    <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;}&quot;</span>);
    <span class="ident">fmt</span>.<span class="ident">empty_line</span>();

    <span class="ident">fmt</span>.<span class="ident">doc_comment</span>(<span class="string">&quot;Get the value arguments to this instruction.&quot;</span>);
    <span class="ident">gen_arguments_method</span>(<span class="ident">formats</span>, <span class="ident">fmt</span>, <span class="bool-val">false</span>);
    <span class="ident">fmt</span>.<span class="ident">empty_line</span>();

    <span class="ident">fmt</span>.<span class="ident">doc_comment</span>(
      <span class="string">r#&quot;Get mutable references to the value arguments to this
                        instruction.&quot;#</span>,
    );
    <span class="ident">gen_arguments_method</span>(<span class="ident">formats</span>, <span class="ident">fmt</span>, <span class="bool-val">true</span>);
    <span class="ident">fmt</span>.<span class="ident">empty_line</span>();

    <span class="ident">fmt</span>.<span class="ident">doc_comment</span>(
      <span class="string">r#&quot;
            Take out the value list with all the value arguments and return
            it.

            This leaves the value list in the instruction empty. Use
            `put_value_list` to put the value list back.
        &quot;#</span>,
    );
    <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;pub fn take_value_list(&amp;mut self) -&gt; Option&lt;ir::ValueList&gt; {&quot;</span>);
    <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
      <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">m</span> <span class="op">=</span> <span class="ident">Match::new</span>(<span class="string">&quot;*self&quot;</span>);

      <span class="kw">for</span> <span class="ident">format</span> <span class="kw">in</span> <span class="ident">formats</span> {
        <span class="kw">if</span> <span class="ident">format</span>.<span class="ident">has_value_list</span> {
          <span class="ident">m</span>.<span class="ident">arm</span>(
            <span class="macro">format!</span>(<span class="string">&quot;Self::{}&quot;</span>, <span class="ident">format</span>.<span class="ident">name</span>),
            <span class="macro">vec!</span>[<span class="string">&quot;ref mut args&quot;</span>, <span class="string">&quot;..&quot;</span>],
            <span class="string">&quot;Some(args.take())&quot;</span>.<span class="ident">to_string</span>(),
          );
        }
      }

      <span class="ident">m</span>.<span class="ident">arm_no_fields</span>(<span class="string">&quot;_&quot;</span>, <span class="string">&quot;None&quot;</span>);

      <span class="ident">fmt</span>.<span class="ident">add_match</span>(<span class="ident">m</span>);
    });
    <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;}&quot;</span>);
    <span class="ident">fmt</span>.<span class="ident">empty_line</span>();

    <span class="ident">fmt</span>.<span class="ident">doc_comment</span>(
      <span class="string">r#&quot;
            Put back a value list.

            After removing a value list with `take_value_list()`, use this
            method to put it back. It is required that this instruction has
            a format that accepts a value list, and that the existing value
            list is empty. This avoids leaking list pool memory.
        &quot;#</span>,
    );
    <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;pub fn put_value_list(&amp;mut self, vlist: ir::ValueList) {&quot;</span>);
    <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
      <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;let args = match *self {&quot;</span>);
      <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
        <span class="kw">for</span> <span class="ident">format</span> <span class="kw">in</span> <span class="ident">formats</span> {
          <span class="kw">if</span> <span class="ident">format</span>.<span class="ident">has_value_list</span> {
            <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;Self::{} {{ ref mut args, .. }} =&gt; args,&quot;</span>, <span class="ident">format</span>.<span class="ident">name</span>);
          }
        }
        <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;_ =&gt; panic!(\&quot;No value list: {:?}\&quot;, self),&quot;</span>);
      });
      <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;};&quot;</span>);
      <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;debug_assert!(args.is_empty(), \&quot;Value list already in use\&quot;);&quot;</span>);
      <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;*args = vlist;&quot;</span>);
    });
    <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;}&quot;</span>);
    <span class="ident">fmt</span>.<span class="ident">empty_line</span>();

    <span class="ident">fmt</span>.<span class="ident">doc_comment</span>(
      <span class="string">r#&quot;
            Compare two `InstructionData` for equality.

            This operation requires a reference to a `ValueListPool` to
            determine if the contents of any `ValueLists` are equal.
        &quot;#</span>,
    );
    <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;pub fn eq(&amp;self, other: &amp;Self, pool: &amp;ir::ValueListPool) -&gt; bool {&quot;</span>);
    <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
      <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;if ::core::mem::discriminant(self) != ::core::mem::discriminant(other) {&quot;</span>);
      <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
        <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;return false;&quot;</span>);
      });
      <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;}&quot;</span>);

      <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;match (self, other) {&quot;</span>);
      <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
        <span class="kw">for</span> <span class="ident">format</span> <span class="kw">in</span> <span class="ident">formats</span> {
          <span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="macro">format!</span>(<span class="string">&quot;&amp;Self::{}&quot;</span>, <span class="ident">format</span>.<span class="ident">name</span>);
          <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">members</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="string">&quot;opcode&quot;</span>];

          <span class="kw">let</span> <span class="ident">args_eq</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">format</span>.<span class="ident">typevar_operand</span>.<span class="ident">is_none</span>() {
            <span class="prelude-val">None</span>
          } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">format</span>.<span class="ident">has_value_list</span> {
            <span class="ident">members</span>.<span class="ident">push</span>(<span class="string">&quot;args&quot;</span>);
            <span class="prelude-val">Some</span>(<span class="string">&quot;args1.as_slice(pool) == args2.as_slice(pool)&quot;</span>)
          } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">format</span>.<span class="ident">num_value_operands</span> <span class="op">==</span> <span class="number">1</span> {
            <span class="ident">members</span>.<span class="ident">push</span>(<span class="string">&quot;arg&quot;</span>);
            <span class="prelude-val">Some</span>(<span class="string">&quot;arg1 == arg2&quot;</span>)
          } <span class="kw">else</span> {
            <span class="ident">members</span>.<span class="ident">push</span>(<span class="string">&quot;args&quot;</span>);
            <span class="prelude-val">Some</span>(<span class="string">&quot;args1 == args2&quot;</span>)
          };

          <span class="kw">for</span> <span class="ident">field</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">format</span>.<span class="ident">imm_fields</span> {
            <span class="ident">members</span>.<span class="ident">push</span>(<span class="ident">field</span>.<span class="ident">member</span>);
          }

          <span class="kw">let</span> <span class="ident">pat1</span> <span class="op">=</span> <span class="ident">members</span>
            .<span class="ident">iter</span>()
            .<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="macro">format!</span>(<span class="string">&quot;{}: ref {}1&quot;</span>, <span class="ident">x</span>, <span class="ident">x</span>))
            .<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>()
            .<span class="ident">join</span>(<span class="string">&quot;, &quot;</span>);
          <span class="kw">let</span> <span class="ident">pat2</span> <span class="op">=</span> <span class="ident">members</span>
            .<span class="ident">iter</span>()
            .<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="macro">format!</span>(<span class="string">&quot;{}: ref {}2&quot;</span>, <span class="ident">x</span>, <span class="ident">x</span>))
            .<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>()
            .<span class="ident">join</span>(<span class="string">&quot;, &quot;</span>);
          <span class="macro">fmtln!</span>(
            <span class="ident">fmt</span>,
            <span class="string">&quot;({} {{ {} }}, {} {{ {} }}) =&gt; {{&quot;</span>,
            <span class="ident">name</span>,
            <span class="ident">pat1</span>,
            <span class="ident">name</span>,
            <span class="ident">pat2</span>
          );
          <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
            <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;opcode1 == opcode2&quot;</span>);
            <span class="kw">for</span> <span class="ident">field</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">format</span>.<span class="ident">imm_fields</span> {
              <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;&amp;&amp; {}1 == {}2&quot;</span>, <span class="ident">field</span>.<span class="ident">member</span>, <span class="ident">field</span>.<span class="ident">member</span>);
            }
            <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">args_eq</span>) <span class="op">=</span> <span class="ident">args_eq</span> {
              <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;&amp;&amp; {}&quot;</span>, <span class="ident">args_eq</span>);
            }
          });
          <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;}&quot;</span>);
        }
        <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;_ =&gt; unreachable!()&quot;</span>);
      });
      <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;}&quot;</span>);
    });
    <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;}&quot;</span>);
    <span class="ident">fmt</span>.<span class="ident">empty_line</span>();

    <span class="ident">fmt</span>.<span class="ident">doc_comment</span>(
      <span class="string">r#&quot;
            Hash an `InstructionData`.

            This operation requires a reference to a `ValueListPool` to
            hash the contents of any `ValueLists`.
        &quot;#</span>,
    );
    <span class="ident">fmt</span>.<span class="ident">line</span>(
      <span class="string">&quot;pub fn hash&lt;H: ::core::hash::Hasher&gt;(&amp;self, state: &amp;mut H, pool: &amp;ir::ValueListPool) {&quot;</span>,
    );
    <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
      <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;match *self {&quot;</span>);
      <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
        <span class="kw">for</span> <span class="ident">format</span> <span class="kw">in</span> <span class="ident">formats</span> {
          <span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="macro">format!</span>(<span class="string">&quot;Self::{}&quot;</span>, <span class="ident">format</span>.<span class="ident">name</span>);
          <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">members</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="string">&quot;opcode&quot;</span>];

          <span class="kw">let</span> <span class="ident">args</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">format</span>.<span class="ident">typevar_operand</span>.<span class="ident">is_none</span>() {
            <span class="string">&quot;&amp;()&quot;</span>
          } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">format</span>.<span class="ident">has_value_list</span> {
            <span class="ident">members</span>.<span class="ident">push</span>(<span class="string">&quot;ref args&quot;</span>);
            <span class="string">&quot;args.as_slice(pool)&quot;</span>
          } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">format</span>.<span class="ident">num_value_operands</span> <span class="op">==</span> <span class="number">1</span> {
            <span class="ident">members</span>.<span class="ident">push</span>(<span class="string">&quot;ref arg&quot;</span>);
            <span class="string">&quot;arg&quot;</span>
          } <span class="kw">else</span> {
            <span class="ident">members</span>.<span class="ident">push</span>(<span class="string">&quot;ref args&quot;</span>);
            <span class="string">&quot;args&quot;</span>
          };

          <span class="kw">for</span> <span class="ident">field</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">format</span>.<span class="ident">imm_fields</span> {
            <span class="ident">members</span>.<span class="ident">push</span>(<span class="ident">field</span>.<span class="ident">member</span>);
          }
          <span class="kw">let</span> <span class="ident">members</span> <span class="op">=</span> <span class="ident">members</span>.<span class="ident">join</span>(<span class="string">&quot;, &quot;</span>);

          <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;{}{{{}}} =&gt; {{&quot;</span>, <span class="ident">name</span>, <span class="ident">members</span>); <span class="comment">// beware the moustaches</span>
          <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
            <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;::core::hash::Hash::hash( &amp;::core::mem::discriminant(self), state);&quot;</span>);
            <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;::core::hash::Hash::hash(&amp;opcode, state);&quot;</span>);
            <span class="kw">for</span> <span class="ident">field</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">format</span>.<span class="ident">imm_fields</span> {
              <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;::core::hash::Hash::hash(&amp;{}, state);&quot;</span>, <span class="ident">field</span>.<span class="ident">member</span>);
            }
            <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;::core::hash::Hash::hash({}, state);&quot;</span>, <span class="ident">args</span>);
          });
          <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;}&quot;</span>);
        }
      });
      <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;}&quot;</span>);
    });
    <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;}&quot;</span>);
  });
  <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;}&quot;</span>);
}

<span class="kw">fn</span> <span class="ident">gen_bool_accessor</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">Fn</span>(<span class="kw-2">&amp;</span><span class="ident">Instruction</span>) -&gt; <span class="ident">bool</span><span class="op">&gt;</span>(
  <span class="ident">all_inst</span>: <span class="kw-2">&amp;</span><span class="ident">AllInstructions</span>,
  <span class="ident">get_attr</span>: <span class="ident">T</span>,
  <span class="ident">name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span>,
  <span class="ident">doc</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span>,
  <span class="ident">fmt</span>: <span class="kw-2">&amp;mut</span> <span class="ident">Formatter</span>,
) {
  <span class="ident">fmt</span>.<span class="ident">doc_comment</span>(<span class="ident">doc</span>);
  <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;pub fn {}(self) -&gt; bool {{&quot;</span>, <span class="ident">name</span>);
  <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">m</span> <span class="op">=</span> <span class="ident">Match::new</span>(<span class="string">&quot;self&quot;</span>);
    <span class="kw">for</span> <span class="ident">inst</span> <span class="kw">in</span> <span class="ident">all_inst</span>.<span class="ident">iter</span>() {
      <span class="kw">if</span> <span class="ident">get_attr</span>(<span class="ident">inst</span>) {
        <span class="ident">m</span>.<span class="ident">arm_no_fields</span>(<span class="macro">format!</span>(<span class="string">&quot;Self::{}&quot;</span>, <span class="ident">inst</span>.<span class="ident">camel_name</span>), <span class="string">&quot;true&quot;</span>);
      }
    }
    <span class="ident">m</span>.<span class="ident">arm_no_fields</span>(<span class="string">&quot;_&quot;</span>, <span class="string">&quot;false&quot;</span>);
    <span class="ident">fmt</span>.<span class="ident">add_match</span>(<span class="ident">m</span>);
  });
  <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;}&quot;</span>);
  <span class="ident">fmt</span>.<span class="ident">empty_line</span>();
}

<span class="kw">fn</span> <span class="ident">gen_opcodes</span>(<span class="ident">all_inst</span>: <span class="kw-2">&amp;</span><span class="ident">AllInstructions</span>, <span class="ident">fmt</span>: <span class="kw-2">&amp;mut</span> <span class="ident">Formatter</span>) {
  <span class="ident">fmt</span>.<span class="ident">doc_comment</span>(
    <span class="string">r#&quot;
        An instruction opcode.

        All instructions from all supported ISAs are present.
    &quot;#</span>,
  );
  <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;#[repr(u16)]&quot;</span>);
  <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]&quot;</span>);
  <span class="ident">fmt</span>.<span class="ident">line</span>(
    <span class="string">r#&quot;#[cfg_attr(
            any(feature = &quot;enable-peepmatic&quot;, feature = &quot;enable-serde&quot;),
            derive(serde::Serialize, serde::Deserialize)
        )]&quot;#</span>,
  );

  <span class="comment">// We explicitly set the discriminant of the first variant to 1, which allows us to take</span>
  <span class="comment">// advantage of the NonZero optimization, meaning that wrapping enums can use the 0</span>
  <span class="comment">// discriminant instead of increasing the size of the whole type, and so the size of</span>
  <span class="comment">// Option&lt;Opcode&gt; is the same as Opcode&#39;s.</span>
  <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;pub enum Opcode {&quot;</span>);
  <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">is_first_opcode</span> <span class="op">=</span> <span class="bool-val">true</span>;
    <span class="kw">for</span> <span class="ident">inst</span> <span class="kw">in</span> <span class="ident">all_inst</span>.<span class="ident">iter</span>() {
      <span class="ident">fmt</span>.<span class="ident">doc_comment</span>(<span class="macro">format!</span>(<span class="string">&quot;`{}`. ({})&quot;</span>, <span class="ident">inst</span>, <span class="ident">inst</span>.<span class="ident">format</span>.<span class="ident">name</span>));

      <span class="comment">// Document polymorphism.</span>
      <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">poly</span>) <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">inst</span>.<span class="ident">polymorphic_info</span> {
        <span class="kw">if</span> <span class="ident">poly</span>.<span class="ident">use_typevar_operand</span> {
          <span class="kw">let</span> <span class="ident">op_num</span> <span class="op">=</span> <span class="ident">inst</span>.<span class="ident">value_opnums</span>[<span class="ident">inst</span>.<span class="ident">format</span>.<span class="ident">typevar_operand</span>.<span class="ident">unwrap</span>()];
          <span class="ident">fmt</span>.<span class="ident">doc_comment</span>(<span class="macro">format!</span>(
            <span class="string">&quot;Type inferred from `{}`.&quot;</span>,
            <span class="ident">inst</span>.<span class="ident">operands_in</span>[<span class="ident">op_num</span>].<span class="ident">name</span>
          ));
        }
      }

      <span class="comment">// Enum variant itself.</span>
      <span class="kw">if</span> <span class="ident">is_first_opcode</span> {
        <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;{} = 1,&quot;</span>, <span class="ident">inst</span>.<span class="ident">camel_name</span>);
        <span class="ident">is_first_opcode</span> <span class="op">=</span> <span class="bool-val">false</span>;
      } <span class="kw">else</span> {
        <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;{},&quot;</span>, <span class="ident">inst</span>.<span class="ident">camel_name</span>)
      }
    }
  });
  <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;}&quot;</span>);
  <span class="ident">fmt</span>.<span class="ident">empty_line</span>();

  <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;impl Opcode {&quot;</span>);
  <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
    <span class="ident">gen_bool_accessor</span>(
      <span class="ident">all_inst</span>,
      <span class="op">|</span><span class="ident">inst</span><span class="op">|</span> <span class="ident">inst</span>.<span class="ident">is_terminator</span>,
      <span class="string">&quot;is_terminator&quot;</span>,
      <span class="string">&quot;True for instructions that terminate the block&quot;</span>,
      <span class="ident">fmt</span>,
    );
    <span class="ident">gen_bool_accessor</span>(
      <span class="ident">all_inst</span>,
      <span class="op">|</span><span class="ident">inst</span><span class="op">|</span> <span class="ident">inst</span>.<span class="ident">is_branch</span>,
      <span class="string">&quot;is_branch&quot;</span>,
      <span class="string">&quot;True for all branch or jump instructions.&quot;</span>,
      <span class="ident">fmt</span>,
    );
    <span class="ident">gen_bool_accessor</span>(
      <span class="ident">all_inst</span>,
      <span class="op">|</span><span class="ident">inst</span><span class="op">|</span> <span class="ident">inst</span>.<span class="ident">is_call</span>,
      <span class="string">&quot;is_call&quot;</span>,
      <span class="string">&quot;Is this a call instruction?&quot;</span>,
      <span class="ident">fmt</span>,
    );
    <span class="ident">gen_bool_accessor</span>(
      <span class="ident">all_inst</span>,
      <span class="op">|</span><span class="ident">inst</span><span class="op">|</span> <span class="ident">inst</span>.<span class="ident">is_return</span>,
      <span class="string">&quot;is_return&quot;</span>,
      <span class="string">&quot;Is this a return instruction?&quot;</span>,
      <span class="ident">fmt</span>,
    );
    <span class="ident">gen_bool_accessor</span>(
      <span class="ident">all_inst</span>,
      <span class="op">|</span><span class="ident">inst</span><span class="op">|</span> <span class="ident">inst</span>.<span class="ident">can_load</span>,
      <span class="string">&quot;can_load&quot;</span>,
      <span class="string">&quot;Can this instruction read from memory?&quot;</span>,
      <span class="ident">fmt</span>,
    );
    <span class="ident">gen_bool_accessor</span>(
      <span class="ident">all_inst</span>,
      <span class="op">|</span><span class="ident">inst</span><span class="op">|</span> <span class="ident">inst</span>.<span class="ident">can_store</span>,
      <span class="string">&quot;can_store&quot;</span>,
      <span class="string">&quot;Can this instruction write to memory?&quot;</span>,
      <span class="ident">fmt</span>,
    );
    <span class="ident">gen_bool_accessor</span>(
      <span class="ident">all_inst</span>,
      <span class="op">|</span><span class="ident">inst</span><span class="op">|</span> <span class="ident">inst</span>.<span class="ident">can_trap</span>,
      <span class="string">&quot;can_trap&quot;</span>,
      <span class="string">&quot;Can this instruction cause a trap?&quot;</span>,
      <span class="ident">fmt</span>,
    );
    <span class="ident">gen_bool_accessor</span>(
      <span class="ident">all_inst</span>,
      <span class="op">|</span><span class="ident">inst</span><span class="op">|</span> <span class="ident">inst</span>.<span class="ident">other_side_effects</span>,
      <span class="string">&quot;other_side_effects&quot;</span>,
      <span class="string">&quot;Does this instruction have other side effects besides can_* flags?&quot;</span>,
      <span class="ident">fmt</span>,
    );
    <span class="ident">gen_bool_accessor</span>(
      <span class="ident">all_inst</span>,
      <span class="op">|</span><span class="ident">inst</span><span class="op">|</span> <span class="ident">inst</span>.<span class="ident">writes_cpu_flags</span>,
      <span class="string">&quot;writes_cpu_flags&quot;</span>,
      <span class="string">&quot;Does this instruction write to CPU flags?&quot;</span>,
      <span class="ident">fmt</span>,
    );
  });
  <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;}&quot;</span>);
  <span class="ident">fmt</span>.<span class="ident">empty_line</span>();

  <span class="comment">// Generate a private opcode_format table.</span>
  <span class="macro">fmtln!</span>(
    <span class="ident">fmt</span>,
    <span class="string">&quot;const OPCODE_FORMAT: [InstructionFormat; {}] = [&quot;</span>,
    <span class="ident">all_inst</span>.<span class="ident">len</span>()
  );
  <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
    <span class="kw">for</span> <span class="ident">inst</span> <span class="kw">in</span> <span class="ident">all_inst</span>.<span class="ident">iter</span>() {
      <span class="macro">fmtln!</span>(
        <span class="ident">fmt</span>,
        <span class="string">&quot;InstructionFormat::{}, // {}&quot;</span>,
        <span class="ident">inst</span>.<span class="ident">format</span>.<span class="ident">name</span>,
        <span class="ident">inst</span>.<span class="ident">name</span>
      );
    }
  });
  <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;];&quot;</span>);
  <span class="ident">fmt</span>.<span class="ident">empty_line</span>();

  <span class="comment">// Generate a private opcode_name function.</span>
  <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;fn opcode_name(opc: Opcode) -&gt; &amp;\&#39;static str {&quot;</span>);
  <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">m</span> <span class="op">=</span> <span class="ident">Match::new</span>(<span class="string">&quot;opc&quot;</span>);
    <span class="kw">for</span> <span class="ident">inst</span> <span class="kw">in</span> <span class="ident">all_inst</span>.<span class="ident">iter</span>() {
      <span class="ident">m</span>.<span class="ident">arm_no_fields</span>(
        <span class="macro">format!</span>(<span class="string">&quot;Opcode::{}&quot;</span>, <span class="ident">inst</span>.<span class="ident">camel_name</span>),
        <span class="macro">format!</span>(<span class="string">&quot;\&quot;{}\&quot;&quot;</span>, <span class="ident">inst</span>.<span class="ident">name</span>),
      );
    }
    <span class="ident">fmt</span>.<span class="ident">add_match</span>(<span class="ident">m</span>);
  });
  <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;}&quot;</span>);
  <span class="ident">fmt</span>.<span class="ident">empty_line</span>();

  <span class="comment">// Generate an opcode hash table for looking up opcodes by name.</span>
  <span class="kw">let</span> <span class="ident">hash_table</span> <span class="op">=</span> <span class="ident">constant_hash::generate_table</span>(<span class="ident">all_inst</span>.<span class="ident">iter</span>(), <span class="ident">all_inst</span>.<span class="ident">len</span>(), <span class="op">|</span><span class="ident">inst</span><span class="op">|</span> {
    <span class="ident">constant_hash::simple_hash</span>(<span class="kw-2">&amp;</span><span class="ident">inst</span>.<span class="ident">name</span>)
  });
  <span class="macro">fmtln!</span>(
    <span class="ident">fmt</span>,
    <span class="string">&quot;const OPCODE_HASH_TABLE: [Option&lt;Opcode&gt;; {}] = [&quot;</span>,
    <span class="ident">hash_table</span>.<span class="ident">len</span>()
  );
  <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="ident">hash_table</span> {
      <span class="kw">match</span> <span class="ident">i</span> {
        <span class="prelude-val">Some</span>(<span class="ident">i</span>) =&gt; <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;Some(Opcode::{}),&quot;</span>, <span class="ident">i</span>.<span class="ident">camel_name</span>),
        <span class="prelude-val">None</span> =&gt; <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;None,&quot;</span>),
      }
    }
  });
  <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;];&quot;</span>);
  <span class="ident">fmt</span>.<span class="ident">empty_line</span>();
}

<span class="kw">fn</span> <span class="ident">gen_try_from</span>(<span class="ident">all_inst</span>: <span class="kw-2">&amp;</span><span class="ident">AllInstructions</span>, <span class="ident">fmt</span>: <span class="kw-2">&amp;mut</span> <span class="ident">Formatter</span>) {
  <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;impl core::convert::TryFrom&lt;u16&gt; for Opcode {&quot;</span>);
  <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
    <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;type Error = ();&quot;</span>);
    <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;#[inline]&quot;</span>);
    <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;fn try_from(x: u16) -&gt; Result&lt;Self, ()&gt; {&quot;</span>);
    <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
      <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;if 0 &lt; x &amp;&amp; x &lt;= {} {{&quot;</span>, <span class="ident">all_inst</span>.<span class="ident">len</span>());
      <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;Ok(unsafe { core::mem::transmute(x) })&quot;</span>));
      <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;} else {&quot;</span>);
      <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;Err(())&quot;</span>));
      <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;}&quot;</span>);
    });
    <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;}&quot;</span>);
  });
  <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;}&quot;</span>);
}

<span class="doccomment">/// Get the value type constraint for an SSA value operand, where</span>
<span class="doccomment">/// `ctrl_typevar` is the controlling type variable.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Each operand constraint is represented as a string, one of:</span>
<span class="doccomment">/// - `Concrete(vt)`, where `vt` is a value type name.</span>
<span class="doccomment">/// - `Free(idx)` where `idx` is an index into `type_sets`.</span>
<span class="doccomment">/// - `Same`, `Lane`, `AsBool` for controlling typevar-derived constraints.</span>
<span class="kw">fn</span> <span class="ident">get_constraint</span><span class="op">&lt;</span><span class="lifetime">&#39;entries</span>, <span class="lifetime">&#39;table</span><span class="op">&gt;</span>(
  <span class="ident">operand</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;entries</span> <span class="ident">Operand</span>,
  <span class="ident">ctrl_typevar</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">TypeVar</span><span class="op">&gt;</span>,
  <span class="ident">type_sets</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;table</span> <span class="kw-2">mut</span> <span class="ident">UniqueTable</span><span class="op">&lt;</span><span class="lifetime">&#39;entries</span>, <span class="ident">TypeSet</span><span class="op">&gt;</span>,
) -&gt; <span class="ident">String</span> {
  <span class="macro">assert!</span>(<span class="ident">operand</span>.<span class="ident">is_value</span>());
  <span class="kw">let</span> <span class="ident">type_var</span> <span class="op">=</span> <span class="ident">operand</span>.<span class="ident">type_var</span>().<span class="ident">unwrap</span>();

  <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">typ</span>) <span class="op">=</span> <span class="ident">type_var</span>.<span class="ident">singleton_type</span>() {
    <span class="kw">return</span> <span class="macro">format!</span>(<span class="string">&quot;Concrete({})&quot;</span>, <span class="ident">typ</span>.<span class="ident">rust_name</span>());
  }

  <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">free_typevar</span>) <span class="op">=</span> <span class="ident">type_var</span>.<span class="ident">free_typevar</span>() {
    <span class="kw">if</span> <span class="ident">ctrl_typevar</span>.<span class="ident">is_some</span>() <span class="op">&amp;&amp;</span> <span class="ident">free_typevar</span> <span class="op">!</span><span class="op">=</span> <span class="kw-2">*</span><span class="ident">ctrl_typevar</span>.<span class="ident">unwrap</span>() {
      <span class="macro">assert!</span>(<span class="ident">type_var</span>.<span class="ident">base</span>.<span class="ident">is_none</span>());
      <span class="kw">return</span> <span class="macro">format!</span>(<span class="string">&quot;Free({})&quot;</span>, <span class="ident">type_sets</span>.<span class="ident">add</span>(<span class="kw-2">&amp;</span><span class="ident">type_var</span>.<span class="ident">get_raw_typeset</span>()));
    }
  }

  <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">base</span>) <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">type_var</span>.<span class="ident">base</span> {
    <span class="macro">assert!</span>(<span class="ident">base</span>.<span class="ident">type_var</span> <span class="op">==</span> <span class="kw-2">*</span><span class="ident">ctrl_typevar</span>.<span class="ident">unwrap</span>());
    <span class="kw">return</span> <span class="ident">camel_case</span>(<span class="ident">base</span>.<span class="ident">derived_func</span>.<span class="ident">name</span>());
  }

  <span class="macro">assert!</span>(<span class="ident">type_var</span> <span class="op">==</span> <span class="ident">ctrl_typevar</span>.<span class="ident">unwrap</span>());
  <span class="string">&quot;Same&quot;</span>.<span class="ident">into</span>()
}

<span class="kw">fn</span> <span class="ident">gen_bitset</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">T</span>: <span class="ident">IntoIterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">u16</span><span class="op">&gt;</span><span class="op">&gt;</span>(
  <span class="ident">iterable</span>: <span class="ident">T</span>,
  <span class="ident">name</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span>,
  <span class="ident">field_size</span>: <span class="ident">u8</span>,
  <span class="ident">fmt</span>: <span class="kw-2">&amp;mut</span> <span class="ident">Formatter</span>,
) {
  <span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">iterable</span>.<span class="ident">into_iter</span>().<span class="ident">fold</span>(<span class="number">0</span>, <span class="op">|</span><span class="ident">acc</span>, <span class="ident">x</span><span class="op">|</span> {
    <span class="macro">assert!</span>(<span class="ident">x</span>.<span class="ident">is_power_of_two</span>());
    <span class="macro">assert!</span>(<span class="ident">u32::from</span>(<span class="kw-2">*</span><span class="ident">x</span>) <span class="op">&lt;</span> (<span class="number">1</span> <span class="op">&lt;</span><span class="op">&lt;</span> <span class="ident">u32::from</span>(<span class="ident">field_size</span>)));
    <span class="ident">acc</span> <span class="op">|</span> <span class="ident">x</span>
  });
  <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;{}: BitSet::&lt;u{}&gt;({}),&quot;</span>, <span class="ident">name</span>, <span class="ident">field_size</span>, <span class="ident">bits</span>);
}

<span class="kw">fn</span> <span class="ident">iterable_to_string</span><span class="op">&lt;</span><span class="ident">I</span>: <span class="ident">fmt::Display</span>, <span class="ident">T</span>: <span class="ident">IntoIterator</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident">I</span><span class="op">&gt;</span><span class="op">&gt;</span>(<span class="ident">iterable</span>: <span class="ident">T</span>) -&gt; <span class="ident">String</span> {
  <span class="kw">let</span> <span class="ident">elems</span> <span class="op">=</span> <span class="ident">iterable</span>
    .<span class="ident">into_iter</span>()
    .<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span>.<span class="ident">to_string</span>())
    .<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>()
    .<span class="ident">join</span>(<span class="string">&quot;, &quot;</span>);
  <span class="macro">format!</span>(<span class="string">&quot;{{{}}}&quot;</span>, <span class="ident">elems</span>)
}

<span class="kw">fn</span> <span class="ident">typeset_to_string</span>(<span class="ident">ts</span>: <span class="kw-2">&amp;</span><span class="ident">TypeSet</span>) -&gt; <span class="ident">String</span> {
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">result</span> <span class="op">=</span> <span class="macro">format!</span>(<span class="string">&quot;TypeSet(lanes={}&quot;</span>, <span class="ident">iterable_to_string</span>(<span class="kw-2">&amp;</span><span class="ident">ts</span>.<span class="ident">lanes</span>));
  <span class="kw">if</span> <span class="op">!</span><span class="ident">ts</span>.<span class="ident">ints</span>.<span class="ident">is_empty</span>() {
    <span class="ident">result</span> <span class="op">+</span><span class="op">=</span> <span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">&quot;, ints={}&quot;</span>, <span class="ident">iterable_to_string</span>(<span class="kw-2">&amp;</span><span class="ident">ts</span>.<span class="ident">ints</span>));
  }
  <span class="kw">if</span> <span class="op">!</span><span class="ident">ts</span>.<span class="ident">floats</span>.<span class="ident">is_empty</span>() {
    <span class="ident">result</span> <span class="op">+</span><span class="op">=</span> <span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">&quot;, floats={}&quot;</span>, <span class="ident">iterable_to_string</span>(<span class="kw-2">&amp;</span><span class="ident">ts</span>.<span class="ident">floats</span>));
  }
  <span class="kw">if</span> <span class="op">!</span><span class="ident">ts</span>.<span class="ident">bools</span>.<span class="ident">is_empty</span>() {
    <span class="ident">result</span> <span class="op">+</span><span class="op">=</span> <span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">&quot;, bools={}&quot;</span>, <span class="ident">iterable_to_string</span>(<span class="kw-2">&amp;</span><span class="ident">ts</span>.<span class="ident">bools</span>));
  }
  <span class="kw">if</span> <span class="op">!</span><span class="ident">ts</span>.<span class="ident">specials</span>.<span class="ident">is_empty</span>() {
    <span class="ident">result</span> <span class="op">+</span><span class="op">=</span> <span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">&quot;, specials=[{}]&quot;</span>, <span class="ident">iterable_to_string</span>(<span class="kw-2">&amp;</span><span class="ident">ts</span>.<span class="ident">specials</span>));
  }
  <span class="kw">if</span> <span class="op">!</span><span class="ident">ts</span>.<span class="ident">refs</span>.<span class="ident">is_empty</span>() {
    <span class="ident">result</span> <span class="op">+</span><span class="op">=</span> <span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">&quot;, refs={}&quot;</span>, <span class="ident">iterable_to_string</span>(<span class="kw-2">&amp;</span><span class="ident">ts</span>.<span class="ident">refs</span>));
  }
  <span class="ident">result</span> <span class="op">+</span><span class="op">=</span> <span class="string">&quot;)&quot;</span>;
  <span class="ident">result</span>
}

<span class="doccomment">/// Generate the table of ValueTypeSets described by type_sets.</span>
<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">gen_typesets_table</span>(<span class="ident">type_sets</span>: <span class="kw-2">&amp;</span><span class="ident">UniqueTable</span><span class="op">&lt;</span><span class="ident">TypeSet</span><span class="op">&gt;</span>, <span class="ident">fmt</span>: <span class="kw-2">&amp;mut</span> <span class="ident">Formatter</span>) {
  <span class="kw">if</span> <span class="ident">type_sets</span>.<span class="ident">len</span>() <span class="op">==</span> <span class="number">0</span> {
    <span class="kw">return</span>;
  }

  <span class="ident">fmt</span>.<span class="ident">comment</span>(<span class="string">&quot;Table of value type sets.&quot;</span>);
  <span class="macro">assert!</span>(<span class="ident">type_sets</span>.<span class="ident">len</span>() <span class="op">&lt;</span><span class="op">=</span> <span class="ident">TYPESET_LIMIT</span>, <span class="string">&quot;Too many type sets!&quot;</span>);
  <span class="macro">fmtln!</span>(
    <span class="ident">fmt</span>,
    <span class="string">&quot;const TYPE_SETS: [ir::instructions::ValueTypeSet; {}] = [&quot;</span>,
    <span class="ident">type_sets</span>.<span class="ident">len</span>()
  );
  <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
    <span class="kw">for</span> <span class="ident">ts</span> <span class="kw">in</span> <span class="ident">type_sets</span>.<span class="ident">iter</span>() {
      <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;ir::instructions::ValueTypeSet {&quot;</span>);
      <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
        <span class="ident">fmt</span>.<span class="ident">comment</span>(<span class="ident">typeset_to_string</span>(<span class="ident">ts</span>));
        <span class="ident">gen_bitset</span>(<span class="kw-2">&amp;</span><span class="ident">ts</span>.<span class="ident">lanes</span>, <span class="string">&quot;lanes&quot;</span>, <span class="number">16</span>, <span class="ident">fmt</span>);
        <span class="ident">gen_bitset</span>(<span class="kw-2">&amp;</span><span class="ident">ts</span>.<span class="ident">ints</span>, <span class="string">&quot;ints&quot;</span>, <span class="number">8</span>, <span class="ident">fmt</span>);
        <span class="ident">gen_bitset</span>(<span class="kw-2">&amp;</span><span class="ident">ts</span>.<span class="ident">floats</span>, <span class="string">&quot;floats&quot;</span>, <span class="number">8</span>, <span class="ident">fmt</span>);
        <span class="ident">gen_bitset</span>(<span class="kw-2">&amp;</span><span class="ident">ts</span>.<span class="ident">bools</span>, <span class="string">&quot;bools&quot;</span>, <span class="number">8</span>, <span class="ident">fmt</span>);
        <span class="ident">gen_bitset</span>(<span class="kw-2">&amp;</span><span class="ident">ts</span>.<span class="ident">refs</span>, <span class="string">&quot;refs&quot;</span>, <span class="number">8</span>, <span class="ident">fmt</span>);
      });
      <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;},&quot;</span>);
    }
  });
  <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;];&quot;</span>);
}

<span class="doccomment">/// Generate value type constraints for all instructions.</span>
<span class="doccomment">/// - Emit a compact constant table of ValueTypeSet objects.</span>
<span class="doccomment">/// - Emit a compact constant table of OperandConstraint objects.</span>
<span class="doccomment">/// - Emit an opcode-indexed table of instruction constraints.</span>
<span class="kw">fn</span> <span class="ident">gen_type_constraints</span>(<span class="ident">all_inst</span>: <span class="kw-2">&amp;</span><span class="ident">AllInstructions</span>, <span class="ident">fmt</span>: <span class="kw-2">&amp;mut</span> <span class="ident">Formatter</span>) {
  <span class="comment">// Table of TypeSet instances.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">type_sets</span> <span class="op">=</span> <span class="ident">UniqueTable::new</span>();

  <span class="comment">// Table of operand constraint sequences (as tuples). Each operand</span>
  <span class="comment">// constraint is represented as a string, one of:</span>
  <span class="comment">// - `Concrete(vt)`, where `vt` is a value type name.</span>
  <span class="comment">// - `Free(idx)` where `idx` is an index into `type_sets`.</span>
  <span class="comment">// - `Same`, `Lane`, `AsBool` for controlling typevar-derived constraints.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">operand_seqs</span> <span class="op">=</span> <span class="ident">UniqueSeqTable::new</span>();

  <span class="comment">// Preload table with constraints for typical binops.</span>
  <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">clippy::useless_vec</span>)]</span>
  <span class="ident">operand_seqs</span>.<span class="ident">add</span>(<span class="kw-2">&amp;</span><span class="macro">vec!</span>[<span class="string">&quot;Same&quot;</span>.<span class="ident">to_string</span>(); <span class="number">3</span>]);

  <span class="ident">fmt</span>.<span class="ident">comment</span>(<span class="string">&quot;Table of opcode constraints.&quot;</span>);
  <span class="macro">fmtln!</span>(
    <span class="ident">fmt</span>,
    <span class="string">&quot;const OPCODE_CONSTRAINTS: [OpcodeConstraints; {}] = [&quot;</span>,
    <span class="ident">all_inst</span>.<span class="ident">len</span>()
  );
  <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
        <span class="kw">for</span> <span class="ident">inst</span> <span class="kw">in</span> <span class="ident">all_inst</span>.<span class="ident">iter</span>() {
            <span class="kw">let</span> (<span class="ident">ctrl_typevar</span>, <span class="ident">ctrl_typeset</span>) <span class="op">=</span> <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">poly</span>) <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">inst</span>.<span class="ident">polymorphic_info</span> {
                <span class="kw">let</span> <span class="ident">index</span> <span class="op">=</span> <span class="ident">type_sets</span>.<span class="ident">add</span>(<span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">poly</span>.<span class="ident">ctrl_typevar</span>.<span class="ident">get_raw_typeset</span>());
                (<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="ident">poly</span>.<span class="ident">ctrl_typevar</span>), <span class="ident">index</span>)
            } <span class="kw">else</span> {
                (<span class="prelude-val">None</span>, <span class="ident">TYPESET_LIMIT</span>)
            };

            <span class="comment">// Collect constraints for the value results, not including `variable_args` results</span>
            <span class="comment">// which are always special cased.</span>
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">constraints</span> <span class="op">=</span> <span class="ident">Vec::new</span>();
            <span class="kw">for</span> <span class="kw-2">&amp;</span><span class="ident">index</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">inst</span>.<span class="ident">value_results</span> {
                <span class="ident">constraints</span>.<span class="ident">push</span>(<span class="ident">get_constraint</span>(<span class="kw-2">&amp;</span><span class="ident">inst</span>.<span class="ident">operands_out</span>[<span class="ident">index</span>], <span class="ident">ctrl_typevar</span>, <span class="kw-2">&amp;mut</span> <span class="ident">type_sets</span>));
            }
            <span class="kw">for</span> <span class="kw-2">&amp;</span><span class="ident">index</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">inst</span>.<span class="ident">value_opnums</span> {
                <span class="ident">constraints</span>.<span class="ident">push</span>(<span class="ident">get_constraint</span>(<span class="kw-2">&amp;</span><span class="ident">inst</span>.<span class="ident">operands_in</span>[<span class="ident">index</span>], <span class="ident">ctrl_typevar</span>, <span class="kw-2">&amp;mut</span> <span class="ident">type_sets</span>));
            }

            <span class="kw">let</span> <span class="ident">constraint_offset</span> <span class="op">=</span> <span class="ident">operand_seqs</span>.<span class="ident">add</span>(<span class="kw-2">&amp;</span><span class="ident">constraints</span>);

            <span class="kw">let</span> <span class="ident">fixed_results</span> <span class="op">=</span> <span class="ident">inst</span>.<span class="ident">value_results</span>.<span class="ident">len</span>();
            <span class="kw">let</span> <span class="ident">fixed_values</span> <span class="op">=</span> <span class="ident">inst</span>.<span class="ident">value_opnums</span>.<span class="ident">len</span>();

            <span class="comment">// Can the controlling type variable be inferred from the designated operand?</span>
            <span class="kw">let</span> <span class="ident">use_typevar_operand</span> <span class="op">=</span> <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">poly</span>) <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">inst</span>.<span class="ident">polymorphic_info</span> {
                <span class="ident">poly</span>.<span class="ident">use_typevar_operand</span>
            } <span class="kw">else</span> {
                <span class="bool-val">false</span>
            };

            <span class="comment">// Can the controlling type variable be inferred from the result?</span>
            <span class="kw">let</span> <span class="ident">use_result</span> <span class="op">=</span> <span class="ident">fixed_results</span> <span class="op">&gt;</span> <span class="number">0</span> <span class="op">&amp;&amp;</span> <span class="ident">inst</span>.<span class="ident">operands_out</span>[<span class="ident">inst</span>.<span class="ident">value_results</span>[<span class="number">0</span>]].<span class="ident">type_var</span>() <span class="op">==</span> <span class="ident">ctrl_typevar</span>;

            <span class="comment">// Are we required to use the designated operand instead of the result?</span>
            <span class="kw">let</span> <span class="ident">requires_typevar_operand</span> <span class="op">=</span> <span class="ident">use_typevar_operand</span> <span class="op">&amp;&amp;</span> <span class="op">!</span><span class="ident">use_result</span>;

            <span class="ident">fmt</span>.<span class="ident">comment</span>(
                <span class="macro">format!</span>(<span class="string">&quot;{}: fixed_results={}, use_typevar_operand={}, requires_typevar_operand={}, fixed_values={}&quot;</span>,
                <span class="ident">inst</span>.<span class="ident">camel_name</span>,
                <span class="ident">fixed_results</span>,
                <span class="ident">use_typevar_operand</span>,
                <span class="ident">requires_typevar_operand</span>,
                <span class="ident">fixed_values</span>)
            );
            <span class="ident">fmt</span>.<span class="ident">comment</span>(<span class="macro">format!</span>(<span class="string">&quot;Constraints=[{}]&quot;</span>, <span class="ident">constraints</span>
                .<span class="ident">iter</span>()
                .<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="macro">format!</span>(<span class="string">&quot;&#39;{}&#39;&quot;</span>, <span class="ident">x</span>))
                .<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>()
                .<span class="ident">join</span>(<span class="string">&quot;, &quot;</span>)));
            <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">poly</span>) <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">inst</span>.<span class="ident">polymorphic_info</span> {
                <span class="ident">fmt</span>.<span class="ident">comment</span>(<span class="macro">format!</span>(<span class="string">&quot;Polymorphic over {}&quot;</span>, <span class="ident">typeset_to_string</span>(<span class="kw-2">&amp;</span><span class="ident">poly</span>.<span class="ident">ctrl_typevar</span>.<span class="ident">get_raw_typeset</span>())));
            }

            <span class="comment">// Compute the bit field encoding, c.f. instructions.rs.</span>
            <span class="macro">assert!</span>(<span class="ident">fixed_results</span> <span class="op">&lt;</span> <span class="number">8</span> <span class="op">&amp;&amp;</span> <span class="ident">fixed_values</span> <span class="op">&lt;</span> <span class="number">8</span>, <span class="string">&quot;Bit field encoding too tight&quot;</span>);
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">flags</span> <span class="op">=</span> <span class="ident">fixed_results</span>; <span class="comment">// 3 bits</span>
            <span class="kw">if</span> <span class="ident">use_typevar_operand</span> {
                <span class="ident">flags</span> <span class="op">|</span><span class="op">=</span> <span class="number">1</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="number">3</span>; <span class="comment">// 4th bit</span>
            }
            <span class="kw">if</span> <span class="ident">requires_typevar_operand</span> {
                <span class="ident">flags</span> <span class="op">|</span><span class="op">=</span> <span class="number">1</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="number">4</span>; <span class="comment">// 5th bit</span>
            }
            <span class="ident">flags</span> <span class="op">|</span><span class="op">=</span> <span class="ident">fixed_values</span> <span class="op">&lt;</span><span class="op">&lt;</span> <span class="number">5</span>; <span class="comment">// 6th bit and more</span>

            <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;OpcodeConstraints {&quot;</span>);
            <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
                <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;flags: {:#04x},&quot;</span>, <span class="ident">flags</span>);
                <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;typeset_offset: {},&quot;</span>, <span class="ident">ctrl_typeset</span>);
                <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;constraint_offset: {},&quot;</span>, <span class="ident">constraint_offset</span>);
            });
            <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;},&quot;</span>);
        }
    });
  <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;];&quot;</span>);
  <span class="ident">fmt</span>.<span class="ident">empty_line</span>();

  <span class="ident">gen_typesets_table</span>(<span class="kw-2">&amp;</span><span class="ident">type_sets</span>, <span class="ident">fmt</span>);
  <span class="ident">fmt</span>.<span class="ident">empty_line</span>();

  <span class="ident">fmt</span>.<span class="ident">comment</span>(<span class="string">&quot;Table of operand constraint sequences.&quot;</span>);
  <span class="macro">fmtln!</span>(
    <span class="ident">fmt</span>,
    <span class="string">&quot;const OPERAND_CONSTRAINTS: [OperandConstraint; {}] = [&quot;</span>,
    <span class="ident">operand_seqs</span>.<span class="ident">len</span>()
  );
  <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
    <span class="kw">for</span> <span class="ident">constraint</span> <span class="kw">in</span> <span class="ident">operand_seqs</span>.<span class="ident">iter</span>() {
      <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;OperandConstraint::{},&quot;</span>, <span class="ident">constraint</span>);
    }
  });
  <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;];&quot;</span>);
}

<span class="doccomment">/// Emit member initializers for an instruction format.</span>
<span class="kw">fn</span> <span class="ident">gen_member_inits</span>(<span class="ident">format</span>: <span class="kw-2">&amp;</span><span class="ident">InstructionFormat</span>, <span class="ident">fmt</span>: <span class="kw-2">&amp;mut</span> <span class="ident">Formatter</span>) {
  <span class="comment">// Immediate operands.</span>
  <span class="comment">// We have local variables with the same names as the members.</span>
  <span class="kw">for</span> <span class="ident">f</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">format</span>.<span class="ident">imm_fields</span> {
    <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;{},&quot;</span>, <span class="ident">f</span>.<span class="ident">member</span>);
  }

  <span class="comment">// Value operands.</span>
  <span class="kw">if</span> <span class="ident">format</span>.<span class="ident">has_value_list</span> {
    <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;args,&quot;</span>);
  } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">format</span>.<span class="ident">num_value_operands</span> <span class="op">==</span> <span class="number">1</span> {
    <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;arg: arg0,&quot;</span>);
  } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">format</span>.<span class="ident">num_value_operands</span> <span class="op">&gt;</span> <span class="number">1</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">args</span> <span class="op">=</span> <span class="ident">Vec::new</span>();
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">format</span>.<span class="ident">num_value_operands</span> {
      <span class="ident">args</span>.<span class="ident">push</span>(<span class="macro">format!</span>(<span class="string">&quot;arg{}&quot;</span>, <span class="ident">i</span>));
    }
    <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;args: [{}],&quot;</span>, <span class="ident">args</span>.<span class="ident">join</span>(<span class="string">&quot;, &quot;</span>));
  }
}

<span class="doccomment">/// Emit a method for creating and inserting an instruction format.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// All instruction formats take an `opcode` argument and a `ctrl_typevar` argument for deducing</span>
<span class="doccomment">/// the result types.</span>
<span class="kw">fn</span> <span class="ident">gen_format_constructor</span>(<span class="ident">format</span>: <span class="kw-2">&amp;</span><span class="ident">InstructionFormat</span>, <span class="ident">fmt</span>: <span class="kw-2">&amp;mut</span> <span class="ident">Formatter</span>) {
  <span class="comment">// Construct method arguments.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">args</span> <span class="op">=</span> <span class="macro">vec!</span>[
    <span class="string">&quot;self&quot;</span>.<span class="ident">to_string</span>(),
    <span class="string">&quot;opcode: Opcode&quot;</span>.<span class="ident">into</span>(),
    <span class="string">&quot;ctrl_typevar: Type&quot;</span>.<span class="ident">into</span>(),
  ];

  <span class="comment">// Normal operand arguments. Start with the immediate operands.</span>
  <span class="kw">for</span> <span class="ident">f</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">format</span>.<span class="ident">imm_fields</span> {
    <span class="ident">args</span>.<span class="ident">push</span>(<span class="macro">format!</span>(<span class="string">&quot;{}: {}&quot;</span>, <span class="ident">f</span>.<span class="ident">member</span>, <span class="ident">f</span>.<span class="ident">kind</span>.<span class="ident">rust_type</span>));
  }

  <span class="comment">// Then the value operands.</span>
  <span class="kw">if</span> <span class="ident">format</span>.<span class="ident">has_value_list</span> {
    <span class="comment">// Take all value arguments as a finished value list. The value lists</span>
    <span class="comment">// are created by the individual instruction constructors.</span>
    <span class="ident">args</span>.<span class="ident">push</span>(<span class="string">&quot;args: ir::ValueList&quot;</span>.<span class="ident">into</span>());
  } <span class="kw">else</span> {
    <span class="comment">// Take a fixed number of value operands.</span>
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">format</span>.<span class="ident">num_value_operands</span> {
      <span class="ident">args</span>.<span class="ident">push</span>(<span class="macro">format!</span>(<span class="string">&quot;arg{}: Value&quot;</span>, <span class="ident">i</span>));
    }
  }

  <span class="kw">let</span> <span class="ident">proto</span> <span class="op">=</span> <span class="macro">format!</span>(
    <span class="string">&quot;{}({}) -&gt; (Inst, &amp;&#39;f mut ir::DataFlowGraph)&quot;</span>,
    <span class="ident">format</span>.<span class="ident">name</span>,
    <span class="ident">args</span>.<span class="ident">join</span>(<span class="string">&quot;, &quot;</span>)
  );

  <span class="kw">let</span> <span class="ident">imms_need_sign_extension</span> <span class="op">=</span> <span class="ident">format</span>
    .<span class="ident">imm_fields</span>
    .<span class="ident">iter</span>()
    .<span class="ident">any</span>(<span class="op">|</span><span class="ident">f</span><span class="op">|</span> <span class="ident">f</span>.<span class="ident">kind</span>.<span class="ident">rust_type</span> <span class="op">==</span> <span class="string">&quot;ir::immediates::Imm64&quot;</span>);

  <span class="ident">fmt</span>.<span class="ident">doc_comment</span>(<span class="ident">format</span>.<span class="ident">to_string</span>());
  <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;#[allow(non_snake_case)]&quot;</span>);
  <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;fn {} {{&quot;</span>, <span class="ident">proto</span>);
  <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
    <span class="comment">// Generate the instruction data.</span>
    <span class="macro">fmtln!</span>(
      <span class="ident">fmt</span>,
      <span class="string">&quot;let{} data = ir::InstructionData::{} {{&quot;</span>,
      <span class="kw">if</span> <span class="ident">imms_need_sign_extension</span> { <span class="string">&quot; mut&quot;</span> } <span class="kw">else</span> { <span class="string">&quot;&quot;</span> },
      <span class="ident">format</span>.<span class="ident">name</span>
    );
    <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
      <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;opcode,&quot;</span>);
      <span class="ident">gen_member_inits</span>(<span class="ident">format</span>, <span class="ident">fmt</span>);
    });
    <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;};&quot;</span>);

    <span class="kw">if</span> <span class="ident">imms_need_sign_extension</span> {
      <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;data.sign_extend_immediates(ctrl_typevar);&quot;</span>);
    }

    <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;self.build(data, ctrl_typevar)&quot;</span>);
  });
  <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;}&quot;</span>);
}

<span class="doccomment">/// Emit a method for generating the instruction `inst`.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The method will create and insert an instruction, then return the result values, or the</span>
<span class="doccomment">/// instruction reference itself for instructions that don&#39;t have results.</span>
<span class="kw">fn</span> <span class="ident">gen_inst_builder</span>(<span class="ident">inst</span>: <span class="kw-2">&amp;</span><span class="ident">Instruction</span>, <span class="ident">format</span>: <span class="kw-2">&amp;</span><span class="ident">InstructionFormat</span>, <span class="ident">fmt</span>: <span class="kw-2">&amp;mut</span> <span class="ident">Formatter</span>) {
  <span class="comment">// Construct method arguments.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">args</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="kw">if</span> <span class="ident">format</span>.<span class="ident">has_value_list</span> {
    <span class="string">&quot;mut self&quot;</span>
  } <span class="kw">else</span> {
    <span class="string">&quot;self&quot;</span>
  }
  .<span class="ident">to_string</span>()];

  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">args_doc</span> <span class="op">=</span> <span class="ident">Vec::new</span>();
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rets_doc</span> <span class="op">=</span> <span class="ident">Vec::new</span>();

  <span class="comment">// The controlling type variable will be inferred from the input values if</span>
  <span class="comment">// possible. Otherwise, it is the first method argument.</span>
  <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">poly</span>) <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">inst</span>.<span class="ident">polymorphic_info</span> {
    <span class="kw">if</span> <span class="op">!</span><span class="ident">poly</span>.<span class="ident">use_typevar_operand</span> {
      <span class="ident">args</span>.<span class="ident">push</span>(<span class="macro">format!</span>(<span class="string">&quot;{}: crate::ir::Type&quot;</span>, <span class="ident">poly</span>.<span class="ident">ctrl_typevar</span>.<span class="ident">name</span>));
      <span class="ident">args_doc</span>.<span class="ident">push</span>(<span class="macro">format!</span>(
        <span class="string">&quot;- {} (controlling type variable): {}&quot;</span>,
        <span class="ident">poly</span>.<span class="ident">ctrl_typevar</span>.<span class="ident">name</span>, <span class="ident">poly</span>.<span class="ident">ctrl_typevar</span>.<span class="ident">doc</span>
      ));
    }
  }

  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">tmpl_types</span> <span class="op">=</span> <span class="ident">Vec::new</span>();
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">into_args</span> <span class="op">=</span> <span class="ident">Vec::new</span>();
  <span class="kw">for</span> <span class="ident">op</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">inst</span>.<span class="ident">operands_in</span> {
    <span class="kw">let</span> <span class="ident">t</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">op</span>.<span class="ident">is_immediate</span>() {
      <span class="kw">let</span> <span class="ident">t</span> <span class="op">=</span> <span class="macro">format!</span>(<span class="string">&quot;T{}&quot;</span>, <span class="ident">tmpl_types</span>.<span class="ident">len</span>() <span class="op">+</span> <span class="number">1</span>);
      <span class="ident">tmpl_types</span>.<span class="ident">push</span>(<span class="macro">format!</span>(<span class="string">&quot;{}: Into&lt;{}&gt;&quot;</span>, <span class="ident">t</span>, <span class="ident">op</span>.<span class="ident">kind</span>.<span class="ident">rust_type</span>));
      <span class="ident">into_args</span>.<span class="ident">push</span>(<span class="ident">op</span>.<span class="ident">name</span>);
      <span class="ident">t</span>
    } <span class="kw">else</span> {
      <span class="ident">op</span>.<span class="ident">kind</span>.<span class="ident">rust_type</span>.<span class="ident">to_string</span>()
    };
    <span class="ident">args</span>.<span class="ident">push</span>(<span class="macro">format!</span>(<span class="string">&quot;{}: {}&quot;</span>, <span class="ident">op</span>.<span class="ident">name</span>, <span class="ident">t</span>));
    <span class="ident">args_doc</span>.<span class="ident">push</span>(<span class="macro">format!</span>(
      <span class="string">&quot;- {}: {}&quot;</span>,
      <span class="ident">op</span>.<span class="ident">name</span>,
      <span class="ident">op</span>.<span class="ident">doc</span>()
        .<span class="ident">expect</span>(<span class="string">&quot;every instruction&#39;s input operand must be documented&quot;</span>)
    ));
  }

  <span class="kw">for</span> <span class="ident">op</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">inst</span>.<span class="ident">operands_out</span> {
    <span class="ident">rets_doc</span>.<span class="ident">push</span>(<span class="macro">format!</span>(
      <span class="string">&quot;- {}: {}&quot;</span>,
      <span class="ident">op</span>.<span class="ident">name</span>,
      <span class="ident">op</span>.<span class="ident">doc</span>()
        .<span class="ident">expect</span>(<span class="string">&quot;every instruction&#39;s output operand must be documented&quot;</span>)
    ));
  }

  <span class="kw">let</span> <span class="ident">rtype</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">inst</span>.<span class="ident">value_results</span>.<span class="ident">len</span>() {
    <span class="number">0</span> =&gt; <span class="string">&quot;Inst&quot;</span>.<span class="ident">into</span>(),
    <span class="number">1</span> =&gt; <span class="string">&quot;Value&quot;</span>.<span class="ident">into</span>(),
    <span class="kw">_</span> =&gt; <span class="macro">format!</span>(<span class="string">&quot;({})&quot;</span>, <span class="macro">vec!</span>[<span class="string">&quot;Value&quot;</span>; <span class="ident">inst</span>.<span class="ident">value_results</span>.<span class="ident">len</span>()].<span class="ident">join</span>(<span class="string">&quot;, &quot;</span>)),
  };

  <span class="kw">let</span> <span class="ident">tmpl</span> <span class="op">=</span> <span class="kw">if</span> <span class="op">!</span><span class="ident">tmpl_types</span>.<span class="ident">is_empty</span>() {
    <span class="macro">format!</span>(<span class="string">&quot;&lt;{}&gt;&quot;</span>, <span class="ident">tmpl_types</span>.<span class="ident">join</span>(<span class="string">&quot;, &quot;</span>))
  } <span class="kw">else</span> {
    <span class="string">&quot;&quot;</span>.<span class="ident">into</span>()
  };

  <span class="kw">let</span> <span class="ident">proto</span> <span class="op">=</span> <span class="macro">format!</span>(
    <span class="string">&quot;{}{}({}) -&gt; {}&quot;</span>,
    <span class="ident">inst</span>.<span class="ident">snake_name</span>(),
    <span class="ident">tmpl</span>,
    <span class="ident">args</span>.<span class="ident">join</span>(<span class="string">&quot;, &quot;</span>),
    <span class="ident">rtype</span>
  );

  <span class="ident">fmt</span>.<span class="ident">doc_comment</span>(<span class="kw-2">&amp;</span><span class="ident">inst</span>.<span class="ident">doc</span>);
  <span class="kw">if</span> <span class="op">!</span><span class="ident">args_doc</span>.<span class="ident">is_empty</span>() {
    <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;///&quot;</span>);
    <span class="ident">fmt</span>.<span class="ident">doc_comment</span>(<span class="string">&quot;Inputs:&quot;</span>);
    <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;///&quot;</span>);
    <span class="kw">for</span> <span class="ident">doc_line</span> <span class="kw">in</span> <span class="ident">args_doc</span> {
      <span class="ident">fmt</span>.<span class="ident">doc_comment</span>(<span class="ident">doc_line</span>);
    }
  }
  <span class="kw">if</span> <span class="op">!</span><span class="ident">rets_doc</span>.<span class="ident">is_empty</span>() {
    <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;///&quot;</span>);
    <span class="ident">fmt</span>.<span class="ident">doc_comment</span>(<span class="string">&quot;Outputs:&quot;</span>);
    <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;///&quot;</span>);
    <span class="kw">for</span> <span class="ident">doc_line</span> <span class="kw">in</span> <span class="ident">rets_doc</span> {
      <span class="ident">fmt</span>.<span class="ident">doc_comment</span>(<span class="ident">doc_line</span>);
    }
  }

  <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;#[allow(non_snake_case)]&quot;</span>);
  <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;fn {} {{&quot;</span>, <span class="ident">proto</span>);
  <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
    <span class="comment">// Convert all of the `Into&lt;&gt;` arguments.</span>
    <span class="kw">for</span> <span class="ident">arg</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">into_args</span> {
      <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;let {} = {}.into();&quot;</span>, <span class="ident">arg</span>, <span class="ident">arg</span>);
    }

    <span class="comment">// Arguments for instruction constructor.</span>
    <span class="kw">let</span> <span class="ident">first_arg</span> <span class="op">=</span> <span class="macro">format!</span>(<span class="string">&quot;Opcode::{}&quot;</span>, <span class="ident">inst</span>.<span class="ident">camel_name</span>);
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">args</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="ident">first_arg</span>.<span class="ident">as_str</span>()];
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">poly</span>) <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">inst</span>.<span class="ident">polymorphic_info</span> {
      <span class="kw">if</span> <span class="ident">poly</span>.<span class="ident">use_typevar_operand</span> {
        <span class="comment">// Infer the controlling type variable from the input operands.</span>
        <span class="kw">let</span> <span class="ident">op_num</span> <span class="op">=</span> <span class="ident">inst</span>.<span class="ident">value_opnums</span>[<span class="ident">format</span>.<span class="ident">typevar_operand</span>.<span class="ident">unwrap</span>()];
        <span class="macro">fmtln!</span>(
          <span class="ident">fmt</span>,
          <span class="string">&quot;let ctrl_typevar = self.data_flow_graph().value_type({});&quot;</span>,
          <span class="ident">inst</span>.<span class="ident">operands_in</span>[<span class="ident">op_num</span>].<span class="ident">name</span>
        );

        <span class="comment">// The format constructor will resolve the result types from the type var.</span>
        <span class="ident">args</span>.<span class="ident">push</span>(<span class="string">&quot;ctrl_typevar&quot;</span>);
      } <span class="kw">else</span> {
        <span class="comment">// This was an explicit method argument.</span>
        <span class="ident">args</span>.<span class="ident">push</span>(<span class="kw-2">&amp;</span><span class="ident">poly</span>.<span class="ident">ctrl_typevar</span>.<span class="ident">name</span>);
      }
    } <span class="kw">else</span> {
      <span class="comment">// No controlling type variable needed.</span>
      <span class="ident">args</span>.<span class="ident">push</span>(<span class="string">&quot;types::INVALID&quot;</span>);
    }

    <span class="comment">// Now add all of the immediate operands to the constructor arguments.</span>
    <span class="kw">for</span> <span class="kw-2">&amp;</span><span class="ident">op_num</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">inst</span>.<span class="ident">imm_opnums</span> {
      <span class="ident">args</span>.<span class="ident">push</span>(<span class="ident">inst</span>.<span class="ident">operands_in</span>[<span class="ident">op_num</span>].<span class="ident">name</span>);
    }

    <span class="comment">// Finally, the value operands.</span>
    <span class="kw">if</span> <span class="ident">format</span>.<span class="ident">has_value_list</span> {
      <span class="comment">// We need to build a value list with all the arguments.</span>
      <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;let mut vlist = ir::ValueList::default();&quot;</span>);
      <span class="ident">args</span>.<span class="ident">push</span>(<span class="string">&quot;vlist&quot;</span>);
      <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;{&quot;</span>);
      <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
        <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;let pool = &amp;mut self.data_flow_graph_mut().value_lists;&quot;</span>);
        <span class="kw">for</span> <span class="ident">op</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">inst</span>.<span class="ident">operands_in</span> {
          <span class="kw">if</span> <span class="ident">op</span>.<span class="ident">is_value</span>() {
            <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;vlist.push({}, pool);&quot;</span>, <span class="ident">op</span>.<span class="ident">name</span>);
          } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">op</span>.<span class="ident">is_varargs</span>() {
            <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;vlist.extend({}.iter().cloned(), pool);&quot;</span>, <span class="ident">op</span>.<span class="ident">name</span>);
          }
        }
      });
      <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;}&quot;</span>);
    } <span class="kw">else</span> {
      <span class="comment">// With no value list, we&#39;re guaranteed to just have a set of fixed value operands.</span>
      <span class="kw">for</span> <span class="kw-2">&amp;</span><span class="ident">op_num</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">inst</span>.<span class="ident">value_opnums</span> {
        <span class="ident">args</span>.<span class="ident">push</span>(<span class="ident">inst</span>.<span class="ident">operands_in</span>[<span class="ident">op_num</span>].<span class="ident">name</span>);
      }
    }

    <span class="comment">// Call to the format constructor,</span>
    <span class="kw">let</span> <span class="ident">fcall</span> <span class="op">=</span> <span class="macro">format!</span>(<span class="string">&quot;self.{}({})&quot;</span>, <span class="ident">format</span>.<span class="ident">name</span>, <span class="ident">args</span>.<span class="ident">join</span>(<span class="string">&quot;, &quot;</span>));

    <span class="kw">if</span> <span class="ident">inst</span>.<span class="ident">value_results</span>.<span class="ident">is_empty</span>() {
      <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;{}.0&quot;</span>, <span class="ident">fcall</span>);
      <span class="kw">return</span>;
    }

    <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;let (inst, dfg) = {};&quot;</span>, <span class="ident">fcall</span>);
    <span class="kw">if</span> <span class="ident">inst</span>.<span class="ident">value_results</span>.<span class="ident">len</span>() <span class="op">==</span> <span class="number">1</span> {
      <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;dfg.first_result(inst)&quot;</span>);
    } <span class="kw">else</span> {
      <span class="macro">fmtln!</span>(
        <span class="ident">fmt</span>,
        <span class="string">&quot;let results = &amp;dfg.inst_results(inst)[0..{}];&quot;</span>,
        <span class="ident">inst</span>.<span class="ident">value_results</span>.<span class="ident">len</span>()
      );
      <span class="macro">fmtln!</span>(
        <span class="ident">fmt</span>,
        <span class="string">&quot;({})&quot;</span>,
        <span class="ident">inst</span>
          .<span class="ident">value_results</span>
          .<span class="ident">iter</span>()
          .<span class="ident">enumerate</span>()
          .<span class="ident">map</span>(<span class="op">|</span>(<span class="ident">i</span>, <span class="kw">_</span>)<span class="op">|</span> <span class="macro">format!</span>(<span class="string">&quot;results[{}]&quot;</span>, <span class="ident">i</span>))
          .<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>()
          .<span class="ident">join</span>(<span class="string">&quot;, &quot;</span>)
      );
    }
  });
  <span class="macro">fmtln!</span>(<span class="ident">fmt</span>, <span class="string">&quot;}&quot;</span>)
}

<span class="doccomment">/// Generate a Builder trait with methods for all instructions.</span>
<span class="kw">fn</span> <span class="ident">gen_builder</span>(
  <span class="ident">instructions</span>: <span class="kw-2">&amp;</span><span class="ident">AllInstructions</span>,
  <span class="ident">formats</span>: <span class="kw-2">&amp;</span>[<span class="kw-2">&amp;</span><span class="ident">InstructionFormat</span>],
  <span class="ident">fmt</span>: <span class="kw-2">&amp;mut</span> <span class="ident">Formatter</span>,
) {
  <span class="ident">fmt</span>.<span class="ident">doc_comment</span>(
    <span class="string">r#&quot;
        Convenience methods for building instructions.

        The `InstBuilder` trait has one method per instruction opcode for
        conveniently constructing the instruction with minimum arguments.
        Polymorphic instructions infer their result types from the input
        arguments when possible. In some cases, an explicit `ctrl_typevar`
        argument is required.

        The opcode methods return the new instruction&#39;s result values, or
        the `Inst` itself for instructions that don&#39;t have any results.

        There is also a method per instruction format. These methods all
        return an `Inst`.
    &quot;#</span>,
  );
  <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;pub trait InstBuilder&lt;&#39;f&gt;: InstBuilderBase&lt;&#39;f&gt; {&quot;</span>);
  <span class="ident">fmt</span>.<span class="ident">indent</span>(<span class="op">|</span><span class="ident">fmt</span><span class="op">|</span> {
    <span class="kw">for</span> <span class="ident">inst</span> <span class="kw">in</span> <span class="ident">instructions</span>.<span class="ident">iter</span>() {
      <span class="ident">gen_inst_builder</span>(<span class="ident">inst</span>, <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">inst</span>.<span class="ident">format</span>, <span class="ident">fmt</span>);
      <span class="ident">fmt</span>.<span class="ident">empty_line</span>();
    }
    <span class="kw">for</span> (<span class="ident">i</span>, <span class="ident">format</span>) <span class="kw">in</span> <span class="ident">formats</span>.<span class="ident">iter</span>().<span class="ident">enumerate</span>() {
      <span class="ident">gen_format_constructor</span>(<span class="ident">format</span>, <span class="ident">fmt</span>);
      <span class="kw">if</span> <span class="ident">i</span> <span class="op">+</span> <span class="number">1</span> <span class="op">!</span><span class="op">=</span> <span class="ident">formats</span>.<span class="ident">len</span>() {
        <span class="ident">fmt</span>.<span class="ident">empty_line</span>();
      }
    }
  });
  <span class="ident">fmt</span>.<span class="ident">line</span>(<span class="string">&quot;}&quot;</span>);
}

<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">generate</span>(
  <span class="ident">formats</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">InstructionFormat</span><span class="op">&gt;</span>,
  <span class="ident">all_inst</span>: <span class="kw-2">&amp;</span><span class="ident">AllInstructions</span>,
  <span class="ident">opcode_filename</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>,
  <span class="ident">inst_builder_filename</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>,
  <span class="ident">out_dir</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>,
) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">error::Error</span><span class="op">&gt;</span> {
  <span class="comment">// Opcodes.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">fmt</span> <span class="op">=</span> <span class="ident">Formatter::new</span>();
  <span class="ident">gen_formats</span>(<span class="kw-2">&amp;</span><span class="ident">formats</span>, <span class="kw-2">&amp;mut</span> <span class="ident">fmt</span>);
  <span class="ident">gen_instruction_data</span>(<span class="kw-2">&amp;</span><span class="ident">formats</span>, <span class="kw-2">&amp;mut</span> <span class="ident">fmt</span>);
  <span class="ident">fmt</span>.<span class="ident">empty_line</span>();
  <span class="ident">gen_instruction_data_impl</span>(<span class="kw-2">&amp;</span><span class="ident">formats</span>, <span class="kw-2">&amp;mut</span> <span class="ident">fmt</span>);
  <span class="ident">fmt</span>.<span class="ident">empty_line</span>();
  <span class="ident">gen_opcodes</span>(<span class="ident">all_inst</span>, <span class="kw-2">&amp;mut</span> <span class="ident">fmt</span>);
  <span class="ident">fmt</span>.<span class="ident">empty_line</span>();
  <span class="ident">gen_type_constraints</span>(<span class="ident">all_inst</span>, <span class="kw-2">&amp;mut</span> <span class="ident">fmt</span>);
  <span class="ident">fmt</span>.<span class="ident">empty_line</span>();
  <span class="ident">gen_try_from</span>(<span class="ident">all_inst</span>, <span class="kw-2">&amp;mut</span> <span class="ident">fmt</span>);
  <span class="ident">fmt</span>.<span class="ident">update_file</span>(<span class="ident">opcode_filename</span>, <span class="ident">out_dir</span>)<span class="question-mark">?</span>;

  <span class="comment">// Instruction builder.</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">fmt</span> <span class="op">=</span> <span class="ident">Formatter::new</span>();
  <span class="ident">gen_builder</span>(<span class="ident">all_inst</span>, <span class="kw-2">&amp;</span><span class="ident">formats</span>, <span class="kw-2">&amp;mut</span> <span class="ident">fmt</span>);
  <span class="ident">fmt</span>.<span class="ident">update_file</span>(<span class="ident">inst_builder_filename</span>, <span class="ident">out_dir</span>)<span class="question-mark">?</span>;

  <span class="prelude-val">Ok</span>(())
}
</code></pre></div>
</section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="cranelift_codegen_meta" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div>
    <script src="../../main.js"></script><script src="../../source-script.js"></script><script src="../../scrape-examples.js"></script><script src="../../source-files.js"></script>
</body></html>